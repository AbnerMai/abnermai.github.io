{"meta":{"title":"FlyingFish's Blog","subtitle":"FlyingFish's Blog","description":"随笔记","author":"maiyikai","url":"https://maiyikai.github.io"},"pages":[{"title":"","date":"2019-10-12T12:21:09.266Z","updated":"2019-10-12T12:21:09.266Z","comments":true,"path":"about/index.html","permalink":"https://maiyikai.github.io/about/index.html","excerpt":"","text":"关于我我是一名加入Java大家庭将近2年的小兵性格：对各种新鲜都喜欢摸清楚它的内在 近期学习目标 JVM Spring Boot+Druid配置及多数据源 线程 Spring Boot Redis … … 往期学习目标 Spring Boot-单元测试 代码重构 … …联系我暂时不支持联系我,卖个萌"},{"title":"","date":"2020-04-07T14:29:23.281Z","updated":"2020-04-07T14:29:23.281Z","comments":true,"path":"staticHTML/Redis.html","permalink":"https://maiyikai.github.io/staticHTML/Redis.html","excerpt":"","text":"Redis body{ margin: 0; } #content-info{ width: auto; margin: 0 auto; text-align: center; } #author-info{ white-space: nowrap; text-overflow: ellipsis; overflow: hidden; } #title{ text-overflow: ellipsis; white-space: nowrap; overflow: hidden; padding-top: 10px; margin-bottom: 2px; font-size: 34px; color: #505050; } .text{ white-space:nowrap; text-overflow: ellipsis; display: inline-block; margin-right: 20px; margin-bottom: 2px; font-size: 20px; color: #8c8c8c; } #navBar{ width: auto; height: auto; position: fixed; right:0; bottom: 0; background-color: #f0f3f4; overflow-y: auto; text-align: center; } #svg-container{ width: 100%; overflow-x: scroll; min-width: 0px; margin: 0 10px; } #nav-thumbs{ overflow-y: scroll; padding: 0 5px; } .nav-thumb{ position: relative; margin: 10px auto; } .nav-thumb >p{ text-align: center; font-size: 12px; margin: 4px 0 0 0; } .nav-thumb >div{ position: relative; display: inline-block; border: 1px solid #c6cfd5; } .nav-thumb img{ display: block; } #main-content{ bottom: 0; left: 0; right: 0; background-color: #d0cfd8; display: flex; height: auto; flex-flow: row wrap; text-align:center; } #svg-container >svg{ display: block; margin:10px auto; margin-bottom: 0; } #copyright{ bottom: 0; left: 50%; margin: 5px auto; font-size: 16px; color: #515151; } #copyright >a{ text-decoration: none; color: #77C; } .number{ position: absolute; top:0; left:0; border-top:22px solid #08a1ef; border-right: 22px solid transparent; } .pagenum{ font-size: 12px; color: #fff; position: absolute; top: -23px; left: 2px; } #navBar::-webkit-scrollbar{ width: 8px; background-color: #f5f5f5; } #navBar::-webkit-scrollbar-track{ -webkit-box-shadow: inset 0 0 4px rgba(0,0,0,.3); border-radius: 8px; background-color: #fff; } #navBar::-webkit-scrollbar-thumb{ border-radius: 8px; -webkit-box-shadow: inset 0 0 4px rgba(0,0,0,.3); background-color: #6b6b70; } #navBar::-webkit-scrollbar-thumb:hover{ background-color: #4a4a4f; } Redis Flying Fish 2020-04-02 布隆过滤器 注 EXPIRE、PEXPIRE、EXPIREAT 三个命令都会转换成 PEXPIREAT 命令来执行 占用太多的 CPU 时间，影响服务器的响应时间和吞吐量 占用太多内存，有内存泄漏的风险 为定时删除策略和惰性删除策略的整合和折中选择 阻塞进程 子进程并发处理 经过压缩的二进制文件 rdbSave 为 Redis 内部函数，用于创建 RDB 文件 默认值 增量持久化 镜像持久化 监听 master 一旦一个 slave 被提升为一个 master，它将开始独立的清理过期的 key 拓展 流程 Redis C语言 数据类型 String Lists Sets Hashes SortedSet 数据结构 HyperLogLog 使用场景 用来做基数统计的算法 优点 在输入元素的数量或者提及非常大时，计算基数所需的空间总是固定的、并且很 小的 每个键花费 12KB 内存，就可以计算接近 2^64 个不同元素的基数 只会根据输入元素来计算基数，而不会存储输入元素本身 pub/sub(发布与订阅) GEO 支持存储地理位置信息来实现诸如附近位置、摇一摇这类似依赖于地理位置信息 的功能 事务 Redis 事务可以保证一次执行多个命令， 并且带有三个保证 批量操作在发送 EXEC 命令前被放入队列缓存 收到 EXEC 命令后进入事务执行，事务中任意命令执行失败，其余的命令依然被 执行 在事务执行过程中，其他客户端提交的命令请求不会插入到事务执行命令序列中 不具备原子性；事务执行过程中，如果中间有指令执行失败，其他的指令仍然可 以继续执行，已执行的指令不会回滚。 脚本 Redis 脚本使用 Lua 解释器执行脚本 BooleanFilter Java 接口 RBloomFilter Redis Module Redis Search 优缺点 优点 缺点 空间效率和查询时间都比一般的算法要好 有一点的误识别率 存储空间和插入/查询时间都是常数 O(k) 散列函数相互之间没有关系，方便由硬件并行实现 不需要不能出元素本身，在某些对保密要求非常严格的场合有优势 补救方法 建立一个白名单，存储那些可能被误判的元素，如果元素数量太少，则使用删列 表足矣 应用 网页URL的去重，垃圾邮件的判别，集合重复元素的判别，查询加速（比如基于 key-value的存储系统）等 使用 命令 bf.add 添加元素 bf.exists bf.madd bf.mexists 查询元素是否存在 一次添加多个元素 一次查询多个元素是否存在 设置准确率 命令 bf.reserve filterName error_rate inital_size filterName error_state inital_size 过滤器名字 允许布隆过滤器的错误率，这个值越低过滤器的位数组的大小越大，占用空间也 就越大 布隆过滤器可以存储的元素个数，当实际存储的元素个数超过这个值之后，过滤 器的准确率会下降 bf.reserve 必须要在 add 之前使用。否则如果 filterName 已经存在，则报 错。 如果不使用 bf.reserve ，默认的 error_rate 为 0.01 ,默认的 initial_size 为 100 原理 其本质就是一个只包含0和1的数组。具体操作当一个元素被加入到集合里面后， 该元素通过K个Hash函数运算得到K个hash后的值，然后将K个值映射到这个位数 组对应的位置，把对应位置的值设置为1。查询是否存在时，我们就看对应的映 射点位置如果全是1，他就很可能存在（跟hash函数的个数和hash函数的设计有 关），如果有一个位置是0，那这个元素就一定不存在。 持久化 过期时间与删除 主从复制 哨兵 分布式锁 分片(cluster) 过期时间 删除 过期时间设置 EXPIRE &lt;key> &lt;ttl> PEXPIRE &lt;key> &lt;ttl> EXPIREAT &lt;key> &lt;timestamp> PEXPIREAT &lt;key> &lt;timestamp> 用于将键 key 的生存时间设置为 ttl 秒 用于将键 key 的生存时间设置为 ttl 毫秒 用于将键 key 的过期时间设置为 timestamp 所指定的秒数时间戳 用于将键 key 的过期时间设置为 timestamp 所指定的毫秒数时间戳 移除过期时间 PERSIST &lt;key> PERSIST 命令是 PEXPIREAT 命令的反操作 计算返回剩余生存时间 TTL &lt;key> PTTL &lt;key> 返回剩余多少秒 返回剩余多少毫秒 过期键删除策略 定时删除 惰性删除 定期删除 在设置键的过期时间的同事，创建一个定时器，让定时器在键的过期时间来临 时，立即执行对键的删除操作 放任键过期不管，但是每次从键空间中获取键时，都检查取得的键是否过期，如 果过期的话，就删除该键；如果没有过期，就返回该键 每隔一段时间，程序就对数据库进行一次检查，删除里边的过期键。至于要删除 多少过期键，以及要检查多少个数据库，则由算法决定 对内存是最友好的 对 CPU 时间是最不友好的 通过使用定时器，定时删除策略可以保证过期键会尽可能快的被删除，并释放过 期键所占用的内存 在过期键比较多的情况下，删除过期键这一行为可能会占用相当一部分的 CPU 时间，在内存不紧张但是 CPU 时间非常紧张的情况下，将 CPU 时间用在删除和 当前任务无关的过期键上，无疑会对服务器的相应时间和吞吐量造成影响 创建一个定时器你需要用到 Redis 服务器中的时间时间，而当前时间时间的实 现方式——无序列表，查找一个事件的时间复杂度为 O(N)——并不能高效地处 理大量时间时间 优缺点 对 CPU 时间是友好的 程序只会在取出键时才会对键进行过期检查，这个可以保证删除过期键的操作只 会在非做不可的情况下进行，并且删除的目标仅限于当前处理的键 对内存不友好 过期的键如果不被处理，键一直占用内存不被释放 优点 定期删除策略每隔一段时间执行一次删除过期键操作，并通过限制删除操作执行 的时长和频率来减少操作删除操作对 CPU 时间的浪费 通过定期删除过期键，定期删除策略有效地减少了因为过期键而带来的内存浪费 难点 如果删除操作执行的太频繁，或者执行时间太长，定期删除策略就会退化成定时 删除策略，以至于将 CPU 时间过多的消耗在删除过期键上 如果删除操作执行得太少，或者执行时间太短，定期删除策略又会和惰性删除策 略一样，出现浪费内存的情况 内存策略 RDB AOF 创建 RDB 文件 指令 SAVE BGSAVE 会阻塞 Redis 服务器进程直到 RDB 文件创建完毕为止，在服务器进程阻塞期 间，服务器不能处理任何命令请求 派生出一个子进程；子进程负责创建 RDB 文件，服务器进程继续处理命令请求 载入 RDB 文件 在服务器启动时自动载入 RDB 文件 与 AOF 使用 AOF 文件的更新频率通常比 RDB 文件的更新频率高 如果服务器开启了 AOF 持久化功能，那么服务器会优先使用 AOF 文件来还原数 据库状态 只有 AOF 持久化功能处于关闭状态时，服务器才会使用 RDB 文件来还原数据库 状态 执行时服务器状态 执行时服务器状态 Redis 服务器被阻塞，拒绝所有客户端发送的命令请求 在此期间如果执行 SAVE、BGSAVE、BGREWRITEAOF 三个命令 SAVE 避免服务器进程和子进程同时执行对 rdbSave 的调用，防止产生竞争条件，所 以 拒绝 SAVE 命令 BGSAVE 通知执行两个 BGSAVE 命令也会产生竞争条件，所以 拒绝 BGSAVE 命令 BGREWRITEAOF 如果 BGSAVE 命令在执行期间，那么客户端发送的 BGREWRITEAOF 命令会被 延迟 到 BGSAVE 命令执行完毕之后执行 如果 BGREWRITEAOF 命令正在执行，那么客户端发送的 BGSAVE 命令会被服务器 拒绝 因为 BGREWRITEAOF 和 BGSAVE 两个命令的实际工作都是由子进程执行，所以这 两个命令在操作方面并没有什么冲突的地方，不能同时执行它们只是一个性能方 面的考虑——并发出两个子进程，并且这两个子进程都同时执行大量的磁盘写入 操作，这不是一个号的方案 RDB 允许手动执行和定期执行 手动执行 执行 SAVE 或 BGSAVE 定期执行 通过设置服务器配置的 save 选项，让服务器每隔一段时间自动执行一次 BGSAVE 命令 save 保存设置 配置 save &lt;timestamp> &lt;changeNumber> 通过保存 Redis 服务器所执行的写命令来记录数据库状态 图 载入 AOF 持久化行为配置 appendfsync appendfsync 选项的值 always everysec no flushAppendOnlyFile 函数行为 将 aof_buf 缓冲区中的所有内容写入并同步到 AOF 文件 将 aof_buf 缓冲区中的所有内容写入到 AOF 文件中，如果上次同步 AOF文件的 时间距离现在超过一秒钟，那么再次对 AOF 文件进行同步，并且这个同步操作 是由一个线程专门负责执行的 将 aof_buf 缓冲区中的所有内容写入到 AOF 文件中，但并不对 AOF 文件进行 同步，何时同步由操作系统来决定 效率最慢 效率足够快；并且出现故障停机，数据库也只丢失一秒钟的命令数据 AOF 文件写入速度最快，但单次同步速度是最慢的；出现故障停机，怎会丢失上 次同步 AOF 文件之后的所有写命令 AOF 文件载入 流程 1.创建一个不带网络连接的伪客户端 2.从 AOF 文件中分析并读取出一条写命令 3.使用伪客户端执行被读出的写命令 4.一直执行步骤 2 和步骤 3，直到 AOF 文件中的所有写命令多被执行完为止 命令请求会先保存到 AOF 缓冲区里面，之后再定期写入并同步到 AOF 文件中 AOF 重写 因为 AOF 持久化是通过保存被执行的写命令来记录数据库状态，所以时间越 久，AOF 文件内容越多，文件体积越大，使用 AOF 文件进行数据还原所需时间 越多 避免了文件体积越来越大的问题，Redis 提供了 AOF 文件重写功能。新的 AOF 文件比旧的 AOF 文件的体积要小的多 首先从数据库中读取键现在的值，然后用一条命令去记录键值对，代替之前记录 这个键值对的多条命令， 原理 在执行 BGREWRITEAOF 命令是，Redis 服务器会维护一个 AOF 重写缓冲区，该 缓冲区会在子进程创建新 AOF 文件期间，记录服务器执行的所有命令，但子进 程完成创建新 AOF 文件的工作之后，服务器会将重写缓冲区中的所有内容追加 到新的 AOF 文件的末尾，使得新旧两个 AOF 文件所保存的数据库状态一致。最 后服务器用心得 AOF 文件替换旧的 AOF 文件，以此来完成 AOF 文件重写操 作。 内存配置 可通过 redis.conf 文件配置 maxmemory &lt;size> 设置 maxmemory 设置为 0 代表没有限制内存 64 位系统 32 位系统 默认为 0 系统默认内存限制为 3G 内存回收策略 noeviction allkeys-lru volatile-lru allkeys-random volatile-random volatile-ttl 返回错误；对外停止写服务，只允许读、删除操作。保证已有数据不丢失，但是 影响了写服务的可用性，这是默认的淘汰策略 使用 LRU 算法，尝试回收最近最少使用的 key 使用 LRU 算法，尝试回收最近最少使用的 key，但仅限于使用了过期时间的 key 使用 random 策略，在所有的 key 中，随机淘汰 使用 random 策略，在所有的 key 中，随机淘汰，但仅限于使用了过期时间的 key 从设置了过期时间的 key 中淘汰生存时间最少的 key，即越快过期的优先淘汰 近似 LRU 算法 通过调整每次回收时检查的采样数量，以实现调整算法的精度 配置 maxmemory-samples &lt;number> LRU 淘汰算法 实现需要一个字典和一个有序链表进行组合 字典用来存储数据，链表是根据最近访问来对数据进行排序，一端是最近访问， 另一端是最久访问 链表中的元素按照一定的顺序进行排序。当空间满时，会剔除链头的元素，当字 典的某个元素被访问，则会从链表原来的位置移至链尾 对比 LRU LRU 需要消耗大量的额外的内存，需要对现有的数据结构进行改造。近似 LRU 算法基于 Redis 现有的数据结构，使用 随机采样 来淘汰元素 近似 LRU 算法，给每个 key 增加一个额外的 24bit 字段，用来记录 key 最后 一次被访问的时间戳 近似 LRU 算法更具具体的 Redis 淘汰策略，从有过期时间的数据或者全部数据 中， 随机采样一定数量的数据 ，淘汰掉最少使用的数据，依次循环，直到 Redis 内存使用情况处于正常范围 Redis 复制能使 slave 能精确的复制 master 的内容。每次当 slave 和 master 之间的连接断开时， slave 会自动重连到 master 上，无论这期间 master 发生了什么，slave 都将尝试让自身成为 master 精确的副本。 运行机制 当一个 master 实例和一个 slave 实例连接正常时，master 会发送一连串命令 流来保持对 slave 的更新，以便将自身数据集赋值给 slave 当 master 和 slave 断开连接后，slave 重新连接上 master 并会尝试进行在 断开期间丢失的命令流 当 slave 无法进行部分命令流重新同步时，slave 会请求进行全量同步。 作用 Redis 使用的是异步复制， slave 和 master 之间异步地确认处理的数据量 一个 master 可以拥有很多个 slave slave 可以接受其他 slave 的连接 Redis 复制在 master 是非阻塞的 Redis 复制在 slave 大部分也是非阻塞的。 复制既可以被用在可伸缩性，以便只读查询可以由多个 slave 进行或者仅用于 数据安全 可以使用复制来避免 master 将全部数据集写入磁盘造成开销 配置 slave slaveof &lt;ip> &lt;port> ip master 的 ip 地址 port master 的端口 repl-diskless-sync 配置无磁盘复制 repl-disless-sync-delay 配置延迟启动数据传输，目的是可以在第一个 slave 就绪后，等待更多的 slave 就绪 正常情况下，全量同步要求在磁盘上创建一个 RDB 文件，然后将它从磁盘加载 进内存，然后 slave 以此进行数据同步。如果磁盘新能低，这对 master 是一 个压力很大的操作 有无磁盘参与 子进程直接发送 RDB 文件给 slave，无需使用磁盘作为中间存储介质 配置 slave 的只读性质 通过配置 slave-read-only 进行配置 slave 并不是只能读，也能写。不过写的数据不会持久化，更不会同步到这个 slave 下的 sub-slave。 sub-slave 始终只会接收与最顶层 master 向 intermediate slaves 发送的复制流相同的复制流 masterauth &lt;password> slave 对 master 的验证配置 配置 master 只有当至少有 N 个 slave 连接到 master 时，才有可能配置 master 接受 写查 询 因为 Redis 使用异步复制，所以无法确保 slave 是否实际接受到给定的命令， 所以总会有一个数据丢失的窗口期 工作原理 slave 每秒钟都会 ping master，确认已处理的复制流的数量 master 会记得上一次从每个 slave 都收到的 ping 的时间 用户可以配置一个最小的 slave 数量，使得它 滞后 &lt;= 最大秒数 参数配置 min-slaves-to-write &lt;slave数量> min-slaves-max-lag &lt;秒数> Redis 复制处理 Key 的过期 Redis 不能依靠主从使用同步时钟，因为这是一个无法解决问题并且会导致 race condition 和数据集不一致的问题 处理技术 slave 不会让 key 过期，而是等待 master 让 key 过期。当 master 让一个 key 到期（或者被 LRU 算法移除）时，它会合成一个 DEL 命令并传输到所有的 slave master 驱动的 key 的过期行为，master 无法及时的提供 DEL 命令，所以有时 候 slave 的内存中仍然可能存在已经过期的 key。 为了处理这个问题， slave 使用它的逻辑时钟以报告之后又在不违反数据集的 一致性的读取操作才存在的 key。用这种方法， slave 避免报告逻辑过期的 key 仍然存在 在Lua脚本执行期间，不执行任何 key 过期操作。当一个Lua脚本运行时，从概 念上讲，master 中的时间是被冻结的，这样脚本运行的时候，一个给定的键要 么存在要么不存在。这可以防止 key 在脚本中间过期，保证将相同的脚本发送 到 slave ，从而在二者的数据集中产生相同的效果。 slave of on one 取消复制 replicationID 和偏移量 每一个 master 启动之后都会有一个 replication ID， 和持有一个偏移量 slave 在连接到 master 之后，会使用 PSYNC 命令来发送其记录的 replication ID 和偏移量给 master。master 接收到之后，仅发送 slave 所需 的增量部分。 但是如果 master 缓冲区中没有足够多的命令积压缓冲记录，或者 slave 应用 的 replication ID 不是当前 master 的 replication ID。则会转而进行一次 全量同步，重头开始。 allkeys-lfu volatile-lfu 从所有的 key 中，淘汰使用频率最少的 key 从所有配置了过期时间的 key 中，淘汰使用频率最少的 key LFU 算法 淘汰掉使用评率最少的 key 作用 Sentinel 系统用来管理多个 Redis 服务器实例 任务 监控 提醒 自动故障迁移 Sentinel 会不断地检查 master 和 slave 是否运行正常 当被监控的某个 Redis 服务器出现问题时，Sentinel 可以通过 API 向管理员 或者其他应用程序发送通知 当一个 master 不能正常工作时， Sentinel 会开始一次自动故障迁移操作，它 会将失效的 master 的其中一个 slave 升级为新的 master，并让失效的 master 的其他 slaves 改为复制新的 master；当客户端试图连接失效的 master时，集群也会向客户端返回新的 master 的地址，使得集群可以使用新的 master 代替失效的 master。 配置 sentinel monitor &lt;master-name> &lt;ip> &lt;port> &lt;quorum> master-name master 名称 ip master ip 地址 port 端口 quorum 至少有 quorum 配置数量的 sentinel 认为 master 故障了，才算这个 master 主观下线 sentinel down-after-milliseconds &lt;master-name> &lt;times> 每个 sentinel 节点都会定期发送 ping 命令判断 Redis 节点和其余的 sentinel 节点是否可达，如果在 times 时间内没有收到 pong 内容，则主观判 定节点不可达 times sentinel parallel-syncs &lt;master-name> &lt;nums> sentinel failover-timeout &lt;master-name> &lt;times> nums 每次向新的 master 发起复制的节点个数，最多为 nums 个，如果不加控制会对 master 的网络和磁盘 IO 资源很大的开销 times 代表 sentinel 进行故障转义如果超过配置的 times 时间表示故障转义失败 sentinel auth-pass &lt;master-name> &lt;password> 主节点认证 下线类型 主观下线 客观下线 单个 sentinel 实例对服务器做出的下线判断 多个 sentinel 实例对同一个服务器做出的主观下线判断，并通过指令 SENTINEL is-master-down-by-addr 命令寻求其他 sentinel 的判断，当有认为 主观下线的 sentinel 数量超过配置的 quorum 时，则认为服务器已经下线 监控时间节点 10 秒 2 秒 1 秒 心跳检测：每个 sentinel 实例每秒都会向其他 sentinel 节点、 master 节点 和 slave 节点发送一次 ping 命令进行心跳检测。 每个 sentinel 实例每隔 2 秒都会向 Redis 的数据节点指定的频道 （sentinel:hello ）上发送当前 sentinel 对 master 的判断和其他 sentinel 节点的信息，同时每个 sentinel 实例都会订阅这个频道，来了解其他 sentinel 实例的信息和对 master 的判断。（pub/sub） 每个 sentinel 实例每隔 10 秒都会向 master 和 slave 发送 info 命令获取 最新的拓扑结构图。 sentinel 定期执行的任务 1.每隔 一秒 向其所知的所有 master、slave 和其他 sentinel 节点发送一次 PING 命令 2.如果一个实例距离最后一次有效回复 PING 的时间超过 down-after- milliseconds 选项所指定的值时，该实例将会被 sentinel 标记为主观下线 3.如果一个 master 被标记为主观下线，且有足够数量的 sentinel 实例在指定时 间内返回同样的结果，则这个 master 将会被标记为客观下线 4.一般情况下每个 sentinel 实例，每隔 10 秒 会向它所知道的所有的 master 和 slave 节点发送 INFO 命令。 当一个 master 被标记为客观下线时， sentinel 向 下线的 master 下的所有 slave 节点发送的 INFO 命令的频率会从 10 秒改为 1 秒一次。 5.当没有足够数量的 sentinel 实例同意 master 已经下线时，master 的客观下线 状态就会被移除。当 master 重新向 sentinel 的 PING 命令有恢复时，master 的 主观下线状态也会被移除 自动发现 sentinel 和 slave 一个 sentinel 实例可以与其他多个 sentinel 实例进行连接，各个 sentinel 之间都相互检查对方的可用性，并进行信息交换。 它们通过订阅通过订阅与发布功能来自动发现正在监控相同 master 的其他 sentinel ，这一个功能时通过向频道 sentinel：hello 发送消息来实现的 每个 sentinel 以 2 秒 一次的频率，通过发布与订阅功能，向它所监视的所有 master 和 slave 的 sentinel:hello 频道发送一条消息 每个 sentinel 都订阅了被它监视的 master 和 slave 的 sentinel:hello 频 道，查找之前没出现过的 sentinel。当发现一个新的 sentinel 时，会将它放 入到一个列表中，这个列表存放着这个 sentinel 已知的所有的 ，监视同一个 master 的所有其他的 sentinel。 sentinel 发送的信息中还包括了 master 当前的配置信息。如果一个 sentinel 包括的 master 的配置信息比另外一个 sentinel 发送的要旧，那么这个 sentinel 会立即升级到新的配置上。 在将一个新 Sentinel 添加到监视 master 的列表上面之前， Sentinel 会先检 查列表中是否已经包含了和要添加的 Sentinel 拥有相同 runID 或者相同地址 （包括 IP 地址和端口号）的 Sentinel ， 如果是的话， Sentinel 会先移除 列表中已有的那些拥有相同 runID 或者相同地址的 Sentinel ， 然后再添加新 Sentinel 。 故障转移流程 1.发现 master 已经进入客观下线状态 2.对我们当前的纪元进行自增，并尝试在这些纪元中当选 3.如果当选失败，则在设置的故障迁移时间超过 2 倍之后，重新尝试当选，如果当 选成功，则继续 4.选出一个 slave ，并将它升级为新的 master 5.向被选中的 slave 发送 slaveof no one 命令，让它转变为 master 6.通过发布与订阅功能，将更之后的配置传播给其他 sentinel，其他 sentinel 对 它们自己的配置进行更新 7.向已下线的 master 的 slave 发送 slaveof 命令，让它们复制新的 master 8.当所有的 slave 都复制了新的 master 时，新的 master 会终止这次故障迁移操 作 哨兵lerder选举流程 1.在失效 master 属下的 slave 当中， 那些被标记为主观下线、已断线、或者最 后一次回复 PING 命令的时间大于五秒钟的 slave 都会被淘汰。 2.在失效 master 属下的 slave 当中， 那些与失效 master 连接断开的时长超过 down-after 选项指定的时长十倍的 slave 都会被淘汰。 3.在经历了以上两轮淘汰之后剩下来的 slave 中， 我们选出复制偏移量 （replication offset）最大的那个 slave 作为新的 master； 如果复制偏移量不 可用， 或者 slave 的复制偏移量相同， 那么带有最小 runID 的那个 slave 成为 新的 master。 介绍 Redis 集群是一个提供了多个 Redis 节点间共享数据的程序集 Redis 集群通过分区来提供一定程度的可用性，在实际环境中当某个节点宕机或 者不可达的情况下继续处理命令 优势 自动分割数据到不同的节点上 整个集群的部分节点失败或者不可达的情况下能够继续处理命令 所以不支持多个 keys 命令，因为在需要在不同的节点间移动数据，从而打不打 向 Redis 那样的性能，在高负载的情况下可能会导致不可预料的错误 数据分片 引入了哈希槽的概念，不适用一致性 hash Redis 集群有 16384 个哈希槽，每个 key 通过 CRC16 校验后对 16384 取模来 决定放置在哪个槽，集群的每个节点负责一部分槽 集群的主从复制模型 为了使部分节点失败或者大部分节点无法通信的情况下集群仍然可用，所以集群 采用了主从复制模型，每个节点都会与 N-1 个复制品。 eg:集群中有三个节点 A、B、C，在没有复制模型的情况下，如果节点 B 通信失 败，那么整个模型会认为 B 节点负责的哈希槽不可用。如果我们为这三个节点 都添加从节点 A1、B1、C1，那么整个节点就有了三个 master 和三个 slave。 如果节点 B 失败了，集群便会选举 B1 为新的 master 继续。如果 B 和 B1 都 失败了，那就集群不可用了 一致性保证 Redis 并不能保证数据的强一致性，这意味着实际中集群在特定的条件下会丢失 写操作 原因 因为集群时用了异步复制，写操作过程 bit arrays 二进制安全的字符串 按插入顺序排序的字符串元素集合 不重复且无序的字符串元素的集合 由 field 和 value 组合起来的 map，field 和 value 都是字符串 类似于 Sets,但是每个字符串元素都关联到一个叫 score 浮动数值。里面的元 素总是根据 score 进行排序，所以不同的是，它是可以检索的一系列元素 通过特殊的命令，可以将 String 值当作一系列 bits 处理：可以设置和单独的 bits，数出所有设为 1 的 bits 的数量，找出最前的被设为 1 或 0 的 bit 这是被用于估计一个 set 中元素数量的概率性的数据结构 使用 Redis key 的规则 key 不能太长。过长的 key 不仅因为消耗内存，而且在数据中查找这类键值的 计算成本很高 也不能太短。太短的键不能明确键值的作用 最好坚持同一种格式，方便管理 命令 SET &lt;key> &lt;value> GET &lt;key> &lt;value> 值得长度不能超过 512MB INCR &lt;key> [&lt;number>] 原子递增 number 递增数量,如果未设置，则默认加 1 将字符串值解析成整型，将其加一，最后将结果保存为新的字符串值 即使多个客户端对同一个 key 发出 INCR 命令，也决不会导致竞争的情况 GETSET &lt;key> &lt;newValue> 将给定的 key 的值设为 newValue ，并返回 key 的旧值 ...... 命令 rpush &lt;key> &lt;value> 向列表的尾部添加一个值 lpush &lt;key> &lt;value> 向列表的头部添加一个值 lrange &lt;key> &lt;start> &lt;end> 从列表中取出一定范围的值，这两个索引都可以为负来告知 Redis 从尾部开始 计数 rpop &lt;key> 从列表右边删除元素并返回删除的值 lpop &lt;key> 从列表左边删除元素并返回删除的值 ...... 由唯一的，非重复的字符串元素组成 不是实际的数据类型，而是在 String 类型上定义的一组面向位的操作。由字符 串的二进制安全 Blob，并且最大长度为 512MB，因此它们适合设置多达 2^32 个不同的位 操作分类 固定时间的单个位操作 对位组的操作 优点 节约大量的空间 使用场景 各种实时分析 存储与对象 ID 相关的空间高效但高性能的布尔信息 存储的结构是： Sorted Set 不回滚的理由 Redis 命令只会因为错误的语法而失败，或是命令用在了错误的类型的 key 上。这是编写代码时的错误，不该通过 Redis 处理 因为不需要对回滚进行支持，所以 Redis 的内部可以保持简单且快速 RedisSearch 是一个高性能的全文搜索引擎，可作为一个 Redis Module 运行在 Redis 上 特点 简单，快速索引和搜索 数据存储在内存中，使用内存有效的自定义数据结构 支持多种使用 UTF-8 编码的语言 RedisSearch 是在 Redis 的基础上从 0 开始开发的一个全文搜索索引，使用新 的 Redis Modules API 来扩展 Redis 新命令和能力 文档和字段评分 结果的数值过滤 通过词干扩展查询 精确的短语搜索 按特定属性过滤结果 强大的自动提示引擎 增量索引（不需要对索引进行优化和压缩） 支持用作存储在另一数据库中的文档的搜索索引 支持已经在 Redis 中存在的 Hash 对象作为文件的索引 扩展多个 Redis 实例 ... ... 三个使用问题 缓存雪崩 缓存穿透 缓存击穿 问题 解决方法 问题 解决方法 问题 解决方法 所有的 key 都设置了同一个失效时间，当达到失效时间之后，所有的 key 都将 会失效，所有的请求转而直接访问数据库，造成数据库崩溃。 将所有 key 的失效时间都设置为不统一的时间——即所有的失效时间都加上一 个随机值 key 对应的数据，在缓存数据库中都不存在时，所有的请求都会访问数据库，从 而可能压垮数据库 可对部分数据进行过滤 指一个Key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问， 当这个Key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库 布隆过滤器 与 Memcached 对比 性能 由于 Redis 使用单核，而 Memcached 可以使用多核，所以平均每一个核上 Redis 在存储小数据时比 Memcached 性能更高。而在大于 100KB 以上的数据 中，memcached 的性能高于 Redis 数据存储类型 mamcached 数据结构单一，支持 key-value ，仅用来缓存数据 Redis 支持多种数据类型 数据量大小 Redis 一个 value 最大支持 512MB memcached 一个 value 最大只支持 1MB 持久化 Redis 具有持久化机制，可以定期将内存中的数据持久化到硬盘上，Redis 支持 RDB 和 AOF，依赖 RDB 进行持久化， AOF 增强可靠性的同时，对性能有所影响 memecached 不支持数据持久化，断电或重启，数据丢失。通常用字啊缓存数 据，提升性能 eval(atob('dmFyIG11YT13aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudDsNCnZhciB1YT0obXVhLmluZGV4T2YoJ3J2OjExJykrbXVhLmluZGV4T2YoJ01TSUUnKSk+PTA7DQpkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc3ZnLWNvbnRhaW5lcicpLm9uY29udGV4dG1lbnUgPSBmdW5jdGlvbiAoZXZlbnQpIHsNCiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpOw0KfQ0KZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3N2Zy1jb250YWluZXInKS5vbm1vdXNlZG93biA9IGZ1bmN0aW9uIChldmVudCkgew0KICAgIGlmKGV2ZW50LndoaWNoID09Myl7DQogICAgICAgIHRoaXMuc3R5bGUuY3Vyc29yID0gJ3BvaW50ZXInOw0KICAgICAgICB0aGlzLm9ubW91c2Vtb3ZlID0gZnVuY3Rpb24gKGV2KSB7DQogICAgICAgICAgICB0aGlzLnNjcm9sbEJ5KC0oZXYubW92ZW1lbnRYKSwgMCk7DQogICAgICAgICAgICB3aW5kb3cuc2Nyb2xsQnkoMCwtKGV2Lm1vdmVtZW50WSkpDQogICAgICAgIH0NCiAgICAgICAgdGhpcy5vbm1vdXNldXAgPSBmdW5jdGlvbiAoKSB7DQogICAgICAgICAgICB0aGlzLnN0eWxlLmN1cnNvciA9ICBudWxsOw0KICAgICAgICAgICAgdGhpcy5vbm1vdXNldXAgPSBudWxsOw0KICAgICAgICAgICAgdGhpcy5vbm1vdXNlbW92ZSA9IG51bGw7DQogICAgICAgIH0NCiAgICB9DQp9DQpOdW1iZXIucHJvdG90eXBlLnRvc3VpdHN2Zz1mdW5jdGlvbiAoKSB7DQogICAgdmFyIG51bT10aGlzLnZhbHVlT2YoKTsNCiAgICBpZihudW0lMT09PTApew0KICAgICAgICByZXR1cm4gbnVtKzAuNQ0KICAgIH1lbHNlIHJldHVybiBudW07DQp9Ow0KTnVtYmVyLnByb3RvdHlwZS5wbHVzej1mdW5jdGlvbigpIHsNCiAgICB2YXIgbnVtPXRoaXMudmFsdWVPZigpOw0KICAgIHJldHVybiBudW08MTA/JzAnK251bTpudW07DQp9Ow0KZnVuY3Rpb24gcGFyc2VEYXRlKG51bSkgew0KICAgIHZhciBkYXRlID0gbmV3IERhdGUobnVtKTsNCiAgICB2YXIgWSA9IGRhdGUuZ2V0RnVsbFllYXIoKSArICctJzsNCiAgICB2YXIgTSA9IChkYXRlLmdldE1vbnRoKCkrMSkucGx1c3ooKSArICctJzsNCiAgICB2YXIgRCA9IGRhdGUuZ2V0RGF0ZSgpLnBsdXN6KCkgKyAnICc7DQogICAgdmFyIGggPSBkYXRlLmdldEhvdXJzKCkucGx1c3ooKSArICc6JzsNCiAgICB2YXIgbW0gPSBkYXRlLmdldE1pbnV0ZXMoKS5wbHVzeigpICsgJzonOw0KICAgIHZhciBzID0gZGF0ZS5nZXRTZWNvbmRzKCkucGx1c3ooKTsNCiAgICByZXR1cm4gWStNK0QraCttbStzOw0KfQ0KLy8tLXByZWRlZmluZWQNCi8vY29tbWVudC0tDQp2YXIgY29tbWVudHM9ZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnZz5nW2VkXFw6Y29tbWVudF0nKTsNCmZ1bmN0aW9uIGdldGN3aChwb3B1cCkgew0KICAgIGRvY3VtZW50LmJvZHkuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3N2ZycpWzBdLmFwcGVuZENoaWxkKHBvcHVwKTsNCiAgICB2YXIgdz1wb3B1cC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aDsNCiAgICB2YXIgaD1wb3B1cC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQ7DQogICAgcmV0dXJuIFt3LGhdDQp9DQpmb3IodmFyIGk9MDtpPGNvbW1lbnRzLmxlbmd0aDtpKyspew0KICAgIHZhciBwb3B1cD1kb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJywnZycpOw0KICAgIHZhciBwb3B1cFI9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLCdyZWN0Jyk7DQogICAgdmFyIGhvdmVyPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLCdyZWN0Jyk7DQogICAgdmFyIG9saW5lPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLCdyZWN0Jyk7DQogICAgaG92ZXIuc2V0QXR0cmlidXRlKCdmaWxsJywnI2NkY2RmZicpOw0KICAgIGhvdmVyLnNldEF0dHJpYnV0ZSgneCcsJzAnKTsNCiAgICBob3Zlci5zZXRBdHRyaWJ1dGUoJ3knLCcwJyk7DQogICAgaG92ZXIuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCcxNicpOw0KICAgIGhvdmVyLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCcxNicpOw0KICAgIGhvdmVyLnNldEF0dHJpYnV0ZSgnZmlsbC1vcGFjaXR5JywnMC42Jyk7DQogICAgaG92ZXIuc2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nLGNvbW1lbnRzW2ldLnF1ZXJ5U2VsZWN0b3IoJ3VzZScpLmdldEF0dHJpYnV0ZSgndHJhbnNmb3JtJykpOw0KICAgIGhvdmVyLnN0eWxlLmRpc3BsYXk9J25vbmUnOw0KICAgIGNvbW1lbnRzW2ldLmFwcGVuZENoaWxkKGhvdmVyKTsNCiAgICB2YXIgYT1KU09OLnBhcnNlKGNvbW1lbnRzW2ldLmdldEF0dHJpYnV0ZSgnZWQ6Y29tbWVudCcpKTsNCiAgICB2YXIgaGVpZ2h0PTA7DQogICAgdmFyIGNhcnI9W107DQogICAgZm9yKHZhciBqPTA7ajxhLmxlbmd0aDtqKyspew0KICAgICAgICB2YXIgc3RhbXA9TnVtYmVyKGFbal0uRGF0ZSkqMTAwMDsNCiAgICAgICAgdmFyIHRpbWU9cGFyc2VEYXRlKHN0YW1wKTsNCiAgICAgICAgdmFyIG5hbWU9YVtqXS5OYW1lOw0KICAgICAgICB2YXIgbWVzc2FnZT1hW2pdLk1lc3NhZ2U7DQogICAgICAgIHZhciBtZXNzYWdlQXJyPW1lc3NhZ2Uuc3BsaXQoL1xuLyk7DQogICAgICAgIHZhciBvPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLCdnJyk7DQogICAgICAgIHZhciBuPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLCd0ZXh0Jyk7DQogICAgICAgIHZhciB0PWRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLCd0ZXh0Jyk7DQogICAgICAgIHZhciBtPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLCd0ZXh0Jyk7DQogICAgICAgIG4uc2V0QXR0cmlidXRlKCd4Jyw1KTsNCiAgICAgICAgbi5zZXRBdHRyaWJ1dGUoJ3knLDEyKTsNCiAgICAgICAgbi5zZXRBdHRyaWJ1dGUoJ2ZpbGwnLCcjMDA2ZWZmJyk7DQogICAgICAgIG4udGV4dENvbnRlbnQ9bmFtZSsnOiAnOw0KICAgICAgICBuLnNldEF0dHJpYnV0ZSgnZm9udC1zaXplJywnMTInKTsNCiAgICAgICAgdC5zZXRBdHRyaWJ1dGUoJ3gnLDIwMCk7DQogICAgICAgIHQuc2V0QXR0cmlidXRlKCd5JywxMik7DQogICAgICAgIHQuc2V0QXR0cmlidXRlKCdmaWxsJywnIzk2OTY5NicpOw0KICAgICAgICB0LnRleHRDb250ZW50PXRpbWU7DQogICAgICAgIHQuc2V0QXR0cmlidXRlKCdmb250LXNpemUnLCcxMCcpOw0KICAgICAgICBtLnNldEF0dHJpYnV0ZSgndHJhbnNmb3JtJywndHJhbnNsYXRlKDIwLDI3KScpOw0KICAgICAgICBtLnNldEF0dHJpYnV0ZSgnZm9udC1zaXplJywnMTInKTsNCiAgICAgICAgZm9yKHZhciBrPTA7azxtZXNzYWdlQXJyLmxlbmd0aDtrKyspew0KICAgICAgICAgICAgdmFyIHRzPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLCd0c3BhbicpOw0KICAgICAgICAgICAgdHMuc2V0QXR0cmlidXRlKCd4JywnMCcpOw0KICAgICAgICAgICAgdHMuc2V0QXR0cmlidXRlKCd5JyxrKjE2KTsNCiAgICAgICAgICAgIHRzLnRleHRDb250ZW50PW1lc3NhZ2VBcnJba107DQogICAgICAgICAgICBtLmFwcGVuZENoaWxkKHRzKTsNCiAgICAgICAgfQ0KICAgICAgICBvLnNldEF0dHJpYnV0ZSgndHJhbnNmb3JtJywndHJhbnNsYXRlKDAsJytoZWlnaHQrJyknKTsNCiAgICAgICAgby5hcHBlbmRDaGlsZChuKTsNCiAgICAgICAgby5hcHBlbmRDaGlsZCh0KTsNCiAgICAgICAgby5hcHBlbmRDaGlsZChtKTsNCiAgICAgICAgY2Fyci5wdXNoKG8pOw0KICAgICAgICBwb3B1cC5hcHBlbmRDaGlsZChvKTsNCiAgICAgICAgaGVpZ2h0PShtZXNzYWdlQXJyLmxlbmd0aCsxKSoxNitoZWlnaHQ7DQogICAgfQ0KICAgIHZhciB3YXJyPWdldGN3aChwb3B1cCk7DQogICAgb2xpbmUuc2V0QXR0cmlidXRlKCd4JywnMCcpOw0KICAgIG9saW5lLnNldEF0dHJpYnV0ZSgneScsJzAnKTsNCiAgICB2YXIgb3c9d2FyclswXSsxMC41Ow0KICAgIHZhciBvaD13YXJyWzFdKzM7DQogICAgb2xpbmUuc2V0QXR0cmlidXRlKCd3aWR0aCcsb3cpOw0KICAgIG9saW5lLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JyxvaCk7DQogICAgb2xpbmUuc2V0QXR0cmlidXRlKCdmaWxsJywnd2hpdGUnKTsNCiAgICBvbGluZS5zZXRBdHRyaWJ1dGUoJ3N0cm9rZScsJyM2NTY1NjUnKTsNCiAgICBwb3B1cC5hcHBlbmRDaGlsZChvbGluZSk7DQogICAgdmFyIGw9Y2Fyci5sZW5ndGg7DQogICAgd2hpbGUobC0tKXsNCiAgICAgICAgcG9wdXAuYXBwZW5kQ2hpbGQoY2FycltsXSk7DQogICAgfQ0KICAgIHBvcHVwLm9ubW91c2VvdmVyPWZ1bmN0aW9uICgpIHsNCiAgICAgICAgdGhpcy5zdHlsZS5kaXNwbGF5PSdibG9jayc7DQogICAgfTsNCiAgICBwb3B1cC5vbm1vdXNlb3V0PWZ1bmN0aW9uICgpIHsNCiAgICAgICAgdGhpcy5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnOw0KICAgIH07DQogICAgdmFyIGNzPWNvbW1lbnRzW2ldLnF1ZXJ5U2VsZWN0b3IoJ3VzZScpLmdldEF0dHJpYnV0ZSgndHJhbnNmb3JtJykubWF0Y2goL1woKFxTKnxcUypcc1xTKilcKS8pWzFdLnNwbGl0KC8gfCwvKTsNCiAgICB2YXIgcHM9Y29tbWVudHNbaV0ucGFyZW50Tm9kZS5nZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScpOw0KICAgIGlmKHBzLnN1YnN0cigwLDIpID09ICd0cicpew0KICAgICAgICB2YXIgcHBzID0gcHMubWF0Y2goL1woKFxTKnxcUypcc1xTKilcKS8pWzFdLnNwbGl0KC8gfCwvKTsNCiAgICAgICAgdmFyIHg9cGFyc2VGbG9hdChjc1swXSkrcGFyc2VGbG9hdChwcHNbMF0pOw0KICAgICAgICB2YXIgeT1wYXJzZUZsb2F0KHBwc1sxXSk7DQogICAgICAgIHg9eC50b3N1aXRzdmcoKTsNCiAgICAgICAgeT15LnRvc3VpdHN2ZygpOw0KICAgICAgICB2YXIgdHJzdHIgPSAndHJhbnNsYXRlKCcreCsnLCcreSsnKSc7DQogICAgfQ0KICAgIGVsc2UgaWYocHMuc3Vic3RyKDAsMikgPT0gJ21hJyl7DQogICAgICAgIHZhciBwcHMgPSBwcy5tYXRjaCgvKFwtP1xkKyhcLlxkKyk/KVtcLCBdKFwtP1xkKyhcLlxkKyk/KVtcLCBdKFwtP1xkKyhcLlxkKyk/KVtcLCBdKFwtP1xkKyhcLlxkKyk/KVtcLCBdKFwtP1xkKyhcLlxkKyk/KVtcLCBdKFwtP1xkKyhcLlxkKyk/KVwpJC8pOw0KICAgICAgICB2YXIgbWFBcnIgPSBbcGFyc2VGbG9hdChwcHNbMV0pLHBhcnNlRmxvYXQocHBzWzNdKSxwYXJzZUZsb2F0KHBwc1s1XSkscGFyc2VGbG9hdChwcHNbN10pLHBhcnNlRmxvYXQocHBzWzldKSxwYXJzZUZsb2F0KHBwc1sxMV0pXTsNCiAgICAgICAgaWYobWFBcnJbMV0gPT0gMCl7DQogICAgICAgICAgICB2YXIgeCA9IHBhcnNlRmxvYXQoY3NbMF0pOw0KICAgICAgICAgICAgdmFyIHk9IHBhcnNlRmxvYXQoY3NbMV0pKzE2Ow0KICAgICAgICAgICAgdmFyIHgxID0geCAqIG1hQXJyWzBdICsgeSAqIG1hQXJyWzJdICsgbWFBcnJbNF07DQogICAgICAgICAgICB2YXIgeTEgPSB4ICogbWFBcnJbMV0gKyB5ICogbWFBcnJbM10gKyBtYUFycls1XTsNCiAgICAgICAgICAgIHgxPXgxLnRvc3VpdHN2ZygpOw0KICAgICAgICAgICAgeTE9eTEudG9zdWl0c3ZnKCk7DQogICAgICAgICAgICB2YXIgdHJzdHIgPSAgJ3RyYW5zbGF0ZSgnK3gxKycsJyt5MSsnKSc7DQogICAgICAgIH1lbHNlew0KICAgICAgICAgICAgdmFyIHggPSBwYXJzZUZsb2F0KGNzWzBdKSsxNjsNCiAgICAgICAgICAgIHZhciB5ID0gcGFyc2VGbG9hdChjc1sxXSkrMTY7DQogICAgICAgICAgICB2YXIgeDEgPSB4ICogbWFBcnJbMF0gKyB5ICogbWFBcnJbMl0gKyBtYUFycls0XTsNCiAgICAgICAgICAgIHZhciB5MSA9IHggKiBtYUFyclsxXSArIHkgKiBtYUFyclszXSArIG1hQXJyWzVdOw0KICAgICAgICAgICAgeCA9IHBhcnNlRmxvYXQoY3NbMF0pKzE2Ow0KICAgICAgICAgICAgeSA9IHBhcnNlRmxvYXQoY3NbMV0pOw0KICAgICAgICAgICAgdmFyIHgyID0geCAqIG1hQXJyWzBdICsgeSAqIG1hQXJyWzJdICsgbWFBcnJbNF07DQogICAgICAgICAgICB2YXIgeTIgPSB4ICogbWFBcnJbMV0gKyB5ICogbWFBcnJbM10gKyBtYUFycls1XTsNCiAgICAgICAgICAgIHZhciBmeCA9IHgxPHgyP3gxLnRvc3VpdHN2ZygpOiB4Mi50b3N1aXRzdmcoKTsNCiAgICAgICAgICAgIHZhciBmeSA9IHkxPnkyP3kxLnRvc3VpdHN2ZygpOiB5Mi50b3N1aXRzdmcoKTsNCiAgICAgICAgICAgIHZhciBvZmZ5ID0gTWF0aC5hYnMoeTEteTIpOw0KICAgICAgICAgICAgdmFyIHRyc3RyID0gICd0cmFuc2xhdGUoJytmeCsnLCcrZnkrJyknOw0KICAgICAgICAgICAgcG9wdXBSLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JyxvZmZ5LnRvU3RyaW5nKCkpOw0KICAgICAgICAgICAgcG9wdXBSLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCcxNicpOw0KICAgICAgICAgICAgcG9wdXBSLnNldEF0dHJpYnV0ZSgneScsKC1vZmZ5KS50b1N0cmluZygpKTsNCiAgICAgICAgICAgIHBvcHVwUi5zZXRBdHRyaWJ1dGUoJ2ZpbGwnLCd0cmFuc3BhcmVudCcpOw0KICAgICAgICAgICAgcG9wdXAuYXBwZW5kQ2hpbGQocG9wdXBSKTsNCiAgICAgICAgfQ0KICAgIH0NCiAgICBwb3B1cC5zZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScsdHJzdHIpOw0KICAgIHBvcHVwLnNldEF0dHJpYnV0ZSgnY29tbWVudCcsJycpOw0KICAgIHBvcHVwLnN0eWxlLmRpc3BsYXk9J25vbmUnOw0KICAgIHBvcHVwLnNldEF0dHJpYnV0ZSgnZWQ6Y29tbWVudGlkJyxjb21tZW50c1tpXS5wYXJlbnROb2RlLmlkKTsNCiAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjc3ZnLWNvbnRhaW5lciA+IHN2ZycpLmFwcGVuZENoaWxkKHBvcHVwKTsNCiAgICBjb21tZW50c1tpXS5vbm1vdXNlb3Zlcj1mdW5jdGlvbiAoKSB7DQogICAgICAgIHZhciBjb21tZW50aWQ9dGhpcy5wYXJlbnROb2RlLmlkOw0KICAgICAgICB0aGlzLnF1ZXJ5U2VsZWN0b3IoJ3JlY3QnKS5zdHlsZS5kaXNwbGF5PSdibG9jayc7DQogICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoImdbZWRcXDpjb21tZW50aWQ9JyIrY29tbWVudGlkKyInXVtjb21tZW50XSIpLnN0eWxlLmRpc3BsYXk9J2Jsb2NrJzsNCiAgICB9Ow0KICAgIGNvbW1lbnRzW2ldLm9ubW91c2VvdXQ9ZnVuY3Rpb24gKCkgew0KICAgICAgICB2YXIgY29tbWVudGlkPXRoaXMucGFyZW50Tm9kZS5pZDsNCi8vICAgICAgICB3aW5kb3cuZ2V0U2VsZWN0aW9uKCkucmVtb3ZlQWxsUmFuZ2VzKCk7DQogICAgICAgIHRoaXMucXVlcnlTZWxlY3RvcigncmVjdCcpLnN0eWxlLmRpc3BsYXk9J25vbmUnOw0KICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCJnW2VkXFw6Y29tbWVudGlkPSciK2NvbW1lbnRpZCsiJ11bY29tbWVudF0iKS5zdHlsZS5kaXNwbGF5PSdub25lJzsNCiAgICB9DQp9DQovLy0tY29tbWVudA0KLy9ub3RlLS0NCmlmKCF1YSl7DQogICAgdmFyIG5vdGVzPWRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ2c+Z1tlZFxcOm5vdGVdJyk7DQogICAgZnVuY3Rpb24gZ2V0d2gocyxwKSB7DQogICAgICAgIHZhciBtYWlucD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTsNCiAgICAgICAgbWFpbnAuc3R5bGUuY3NzVGV4dD1zOw0KICAgICAgICBtYWlucC5zdHlsZS5kaXNwbGF5PSdpbmxpbmUtYmxvY2snOw0KCQltYWlucC5zdHlsZS5tYXhXaWR0aCA9ICc0MDBweCc7DQoJCW1haW5wLnN0eWxlLndvcmRCcmVhayA9ICdicmVhay1hbGwnOw0KICAgICAgICBtYWlucC5pbm5lckhUTUw9cDsNCiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChtYWlucCk7DQogICAgICAgIHZhciB3PW1haW5wLmNsaWVudFdpZHRoOw0KICAgICAgICB2YXIgaD1tYWlucC5jbGllbnRIZWlnaHQ7DQogICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQobWFpbnApOw0KICAgICAgICByZXR1cm4gW3csaF0NCiAgICB9DQogICAgZm9yKHZhciBpPTA7aTxub3Rlcy5sZW5ndGg7aSsrKXsNCiAgICAgICAgdmFyIGE9bm90ZXNbaV0uZ2V0QXR0cmlidXRlKCdlZDpub3RlJyk7DQoJCXZhciBub3RlTG9jayA9IG5vdGVzW2ldLmdldEF0dHJpYnV0ZSgnZWQ6bm90ZWxvY2snKTsNCiAgICAgICAgaWYobm90ZUxvY2sgPT0gJ3RydWUnKXsNCiAgICAgICAgICAgIGNvbnRpbnVlOw0KICAgICAgICB9DQogICAgICAgIHZhciBtYWlucD1hLm1hdGNoKC88Ym9keVtePl0qPiguKik8XC9ib2R5Pi8pWzFdOw0KICAgICAgICB2YXIgbWFpbnM9YS5tYXRjaCgvc3R5bGU9IiguKj8pIi8pWzFdOw0KICAgICAgICB2YXIgb3V0PWRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLCdnJyk7DQogICAgICAgIHZhciBvbGluZT1kb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJywncmVjdCcpOw0KICAgICAgICB2YXIgcG9wdXA9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsJ2ZvcmVpZ25PYmplY3QnKTsNCiAgICAgICAgdmFyIHBvcHVwUj0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsJ3JlY3QnKTsNCiAgICAgICAgdmFyIGhvdmVyPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLCdyZWN0Jyk7DQogICAgICAgIGhvdmVyLnNldEF0dHJpYnV0ZSgnZmlsbCcsJyNjZGNkZmYnKTsNCiAgICAgICAgaG92ZXIuc2V0QXR0cmlidXRlKCd4JywnMCcpOw0KICAgICAgICBob3Zlci5zZXRBdHRyaWJ1dGUoJ3knLCcwJyk7DQogICAgICAgIGhvdmVyLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywnMTYnKTsNCiAgICAgICAgaG92ZXIuc2V0QXR0cmlidXRlKCd3aWR0aCcsJzE2Jyk7DQogICAgICAgIGhvdmVyLnNldEF0dHJpYnV0ZSgnZmlsbC1vcGFjaXR5JywnMC42Jyk7DQogICAgICAgIGhvdmVyLnNldEF0dHJpYnV0ZSgndHJhbnNmb3JtJyxub3Rlc1tpXS5xdWVyeVNlbGVjdG9yKCd1c2UnKS5nZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScpKTsNCiAgICAgICAgaG92ZXIuc3R5bGUuZGlzcGxheT0nbm9uZSc7DQogICAgICAgIG5vdGVzW2ldLmFwcGVuZENoaWxkKGhvdmVyKTsNCiAgICAgICAgcG9wdXAuc3R5bGUuY3NzVGV4dD1tYWluczsNCiAgICAgICAgcG9wdXAuaW5uZXJIVE1MPW1haW5wOw0KICAgICAgICB2YXIgd2g9Z2V0d2gobWFpbnMsbWFpbnApOw0KICAgICAgICBwb3B1cC5zZXRBdHRyaWJ1dGUoJ3dpZHRoJyx3aFswXSk7DQogICAgICAgIHBvcHVwLnNldEF0dHJpYnV0ZSgnaGVpZ2h0Jyx3aFsxXSk7DQogICAgICAgIHBvcHVwLnNldEF0dHJpYnV0ZSgndHJhbnNmb3JtJywndHJhbnNsYXRlKDgsNCknKTsNCgkJcG9wdXAuc3R5bGUud29yZEJyZWFrID0gJ2JyZWFrLWFsbCc7DQogICAgICAgIHBvcHVwLnN0eWxlLnRleHRBbGlnbj0nbGVmdCc7DQogICAgICAgIG9saW5lLnNldEF0dHJpYnV0ZSgneCcsJzAnKTsNCiAgICAgICAgb2xpbmUuc2V0QXR0cmlidXRlKCd5JywnMCcpOw0KICAgICAgICBvbGluZS5zZXRBdHRyaWJ1dGUoJ3dpZHRoJyx3aFswXSsxNik7DQogICAgICAgIG9saW5lLnNldEF0dHJpYnV0ZSgnaGVpZ2h0Jyx3aFsxXSs4KTsNCiAgICAgICAgb2xpbmUuc2V0QXR0cmlidXRlKCdzdHJva2UnLCcjYTI3YTAwJyk7DQogICAgICAgIG9saW5lLnNldEF0dHJpYnV0ZSgnZmlsbCcsJyNmZmU3OWQnKTsNCiAgICAgICAgb3V0LmFwcGVuZENoaWxkKG9saW5lKTsNCiAgICAgICAgb3V0LmFwcGVuZENoaWxkKHBvcHVwKTsNCiAgICAgICAgb3V0LnNldEF0dHJpYnV0ZSgnbm90ZScsJycpOw0KICAgICAgICBvdXQuc3R5bGUuZGlzcGxheT0nbm9uZSc7DQogICAgICAgIG91dC5zZXRBdHRyaWJ1dGUoJ2VkOm5vdGVpZCcsbm90ZXNbaV0ucGFyZW50Tm9kZS5pZCk7DQogICAgICAgIG91dC5vbm1vdXNlb3Zlcj1mdW5jdGlvbiAoKSB7DQogICAgICAgICAgICB0aGlzLnN0eWxlLmRpc3BsYXk9J2Jsb2NrJzsNCiAgICAgICAgfTsNCiAgICAgICAgb3V0Lm9ubW91c2VvdXQ9ZnVuY3Rpb24gKCkgew0KLy8gICAgICAgIHdpbmRvdy5nZXRTZWxlY3Rpb24gPyB3aW5kb3cuZ2V0U2VsZWN0aW9uKCkucmVtb3ZlUmFuZ2Uod2luZG93LmdldFNlbGVjdGlvbigpLnJlKTpkb2N1bWVudC5zZWxlY3Rpb24uZW1wdHkoKTsNCg0KICAgICAgICAgICAgdGhpcy5zdHlsZS5kaXNwbGF5PSdub25lJzsNCiAgICAgICAgfTsNCiAgICAgICAgdmFyIGNzPW5vdGVzW2ldLnF1ZXJ5U2VsZWN0b3IoJ3VzZScpLmdldEF0dHJpYnV0ZSgndHJhbnNmb3JtJykubWF0Y2goL1woKFxTKnxcUypcc1xTKilcKS8pWzFdLnNwbGl0KC8gfCwvKTsNCiAgICAgICAgdmFyIHBzPW5vdGVzW2ldLnBhcmVudE5vZGUuZ2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nKTsNCiAgICAgICAgaWYocHMuc3Vic3RyKDAsMikgPT0gJ3RyJyl7DQogICAgICAgICAgICB2YXIgcHBzID0gcHMubWF0Y2goL1woKFxTKnxcUypcc1xTKilcKS8pWzFdLnNwbGl0KC8gfCwvKTsNCiAgICAgICAgICAgIHZhciB4PXBhcnNlRmxvYXQoY3NbMF0pK3BhcnNlRmxvYXQocHBzWzBdKTsNCiAgICAgICAgICAgIHZhciB5PXBhcnNlRmxvYXQocHBzWzFdKTsNCiAgICAgICAgICAgIHg9eC50b3N1aXRzdmcoKTsNCiAgICAgICAgICAgIHk9eS50b3N1aXRzdmcoKTsNCiAgICAgICAgICAgIHZhciB0cnN0ciA9ICd0cmFuc2xhdGUoJyt4KycsJyt5KycpJzsNCiAgICAgICAgfWVsc2UgaWYocHMuc3Vic3RyKDAsMikgPT0gJ21hJyl7DQogICAgICAgICAgICB2YXIgcHBzID0gcHMubWF0Y2goLyhcLT9cZCsoXC5cZCspPylbXCwgXShcLT9cZCsoXC5cZCspPylbXCwgXShcLT9cZCsoXC5cZCspPylbXCwgXShcLT9cZCsoXC5cZCspPylbXCwgXShcLT9cZCsoXC5cZCspPylbXCwgXShcLT9cZCsoXC5cZCspPylcKSQvKTsNCiAgICAgICAgICAgIHZhciBtYUFyciA9IFtwYXJzZUZsb2F0KHBwc1sxXSkscGFyc2VGbG9hdChwcHNbM10pLHBhcnNlRmxvYXQocHBzWzVdKSxwYXJzZUZsb2F0KHBwc1s3XSkscGFyc2VGbG9hdChwcHNbOV0pLHBhcnNlRmxvYXQocHBzWzExXSldOw0KICAgICAgICAgICAgaWYobWFBcnJbMV0gPT0gMCl7DQogICAgICAgICAgICAgICAgdmFyIHggPSBwYXJzZUZsb2F0KGNzWzBdKTsNCiAgICAgICAgICAgICAgICB2YXIgeSA9IHBhcnNlRmxvYXQoY3NbMV0pKzE2Ow0KICAgICAgICAgICAgICAgIHZhciB4MSA9IHggKiBtYUFyclswXSArIHkgKiBtYUFyclsyXSArIG1hQXJyWzRdOw0KICAgICAgICAgICAgICAgIHZhciB5MSA9IHggKiBtYUFyclsxXSArIHkgKiBtYUFyclszXSArIG1hQXJyWzVdOw0KICAgICAgICAgICAgICAgIHgxPXgxLnRvc3VpdHN2ZygpOw0KICAgICAgICAgICAgICAgIHkxPXkxLnRvc3VpdHN2ZygpOw0KICAgICAgICAgICAgICAgIHZhciB0cnN0ciA9ICAndHJhbnNsYXRlKCcreDErJywnK3kxKycpJzsNCiAgICAgICAgICAgIH1lbHNlew0KICAgICAgICAgICAgICAgIHZhciB4ID0gcGFyc2VGbG9hdChjc1swXSkrMTY7DQogICAgICAgICAgICAgICAgdmFyIHkgPSBwYXJzZUZsb2F0KGNzWzFdKSsxNjsNCiAgICAgICAgICAgICAgICB2YXIgeDEgPSB4ICogbWFBcnJbMF0gKyB5ICogbWFBcnJbMl0gKyBtYUFycls0XTsNCiAgICAgICAgICAgICAgICB2YXIgeTEgPSB4ICogbWFBcnJbMV0gKyB5ICogbWFBcnJbM10gKyBtYUFycls1XTsNCiAgICAgICAgICAgICAgICB4ID0gcGFyc2VGbG9hdChjc1swXSkrMTY7DQogICAgICAgICAgICAgICAgeSA9IHBhcnNlRmxvYXQoY3NbMV0pOw0KICAgICAgICAgICAgICAgIHZhciB4MiA9IHggKiBtYUFyclswXSArIHkgKiBtYUFyclsyXSArIG1hQXJyWzRdOw0KICAgICAgICAgICAgICAgIHZhciB5MiA9IHggKiBtYUFyclsxXSArIHkgKiBtYUFyclszXSArIG1hQXJyWzVdOw0KICAgICAgICAgICAgICAgIHZhciBmeCA9IHgxPHgyP3gxLnRvc3VpdHN2ZygpOiB4Mi50b3N1aXRzdmcoKTsNCiAgICAgICAgICAgICAgICB2YXIgZnkgPSB5MT55Mj95MS50b3N1aXRzdmcoKTogeTIudG9zdWl0c3ZnKCk7DQoJCQkJdmFyIG9mZnkgPSBNYXRoLmFicyh5MS15Mik7CQkJCQkJCQkJCSAgDQogICAgICAgICAgICAgICAgdmFyIHRyc3RyID0gICd0cmFuc2xhdGUoJytmeCsnLCcrZnkrJyknOw0KICAgICAgICAgICAgICAgIHBvcHVwUi5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsb2ZmeS50b1N0cmluZygpKTsNCiAgICAgICAgICAgICAgICBwb3B1cFIuc2V0QXR0cmlidXRlKCd3aWR0aCcsJzE2Jyk7DQogICAgICAgICAgICAgICAgcG9wdXBSLnNldEF0dHJpYnV0ZSgneScsKC1vZmZ5KS50b1N0cmluZygpKTsNCiAgICAgICAgICAgICAgICBwb3B1cFIuc2V0QXR0cmlidXRlKCdmaWxsJywndHJhbnNwYXJlbnQnKTsNCiAgICAgICAgICAgICAgICBwb3B1cC5hcHBlbmRDaGlsZChwb3B1cFIpOw0KICAgICAgICAgICAgfQ0KICAgICAgICB9DQogICAgICAgIG91dC5zZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScsdHJzdHIpOw0KICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjc3ZnLWNvbnRhaW5lciA+IHN2ZycpLmFwcGVuZENoaWxkKG91dCk7DQogICAgICAgIG5vdGVzW2ldLm9ubW91c2VvdmVyPWZ1bmN0aW9uICgpIHsNCiAgICAgICAgICAgIHZhciBub3RlaWQ9dGhpcy5wYXJlbnROb2RlLmlkOw0KICAgICAgICAgICAgdGhpcy5xdWVyeVNlbGVjdG9yKCdyZWN0Jykuc3R5bGUuZGlzcGxheT0nYmxvY2snOw0KICAgICAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcigiZ1tlZFxcOm5vdGVpZD0nIitub3RlaWQrIiddW25vdGVdIikuc3R5bGUuZGlzcGxheT0nYmxvY2snOw0KICAgICAgICB9Ow0KICAgICAgICBub3Rlc1tpXS5vbm1vdXNlb3V0PWZ1bmN0aW9uICgpIHsNCiAgICAgICAgICAgIHZhciBub3RlaWQ9dGhpcy5wYXJlbnROb2RlLmlkOw0KLy8gICAgICAgIHdpbmRvdy5nZXRTZWxlY3Rpb24oKS5yZW1vdmVBbGxSYW5nZXMoKTsNCiAgICAgICAgICAgIHRoaXMucXVlcnlTZWxlY3RvcigncmVjdCcpLnN0eWxlLmRpc3BsYXk9J25vbmUnOw0KICAgICAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcigiZ1tlZFxcOm5vdGVpZD0nIitub3RlaWQrIiddW25vdGVdIikuc3R5bGUuZGlzcGxheT0nbm9uZSc7DQogICAgICAgIH0NCiAgICB9DQp9ZWxzZXsNCiAgICBjb25zb2xlLmxvZygn5oqx5q2J77yMSUXmtY/op4jlmajkuI3mlK/mjIFub3Rl6Kej5p6Q77yM6K+35L2/55So5YW25LuW5YaF5qC45rWP6KeI5Zmo44CC6LCi6LCi77yBJykNCn0NCi8vLS1ub3RlDQovL2h5cGVybGluay0tDQp2YXIgbGlua3M9ZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnZz5nW2VkXFw6aHlwZXJsaW5rXScpOw0KZnVuY3Rpb24gZ2V0bWF4bGVuKGFycixicnIpIHsNCiAgICB2YXIgbD0wOw0KICAgIHZhciBsbD0wOw0KICAgIGZvcih2YXIgaj0wO2o8YXJyLmxlbmd0aDtqKyspew0KICAgICAgICB2YXIgZT1kb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJywndGV4dCcpOw0KICAgICAgICBpZighaXNOYU4obGlua2FycltqXSkpew0KICAgICAgICAgICAgZS50ZXh0Q29udGVudD0nUGFnZS0nK2FycltqXTsNCiAgICAgICAgfWVsc2V7DQogICAgICAgICAgICBlLnRleHRDb250ZW50PWFycltqXTsNCiAgICAgICAgfQ0KICAgICAgICBlLnN0eWxlLmZvbnRTaXplPScxMnB4JzsNCiAgICAgICAgZG9jdW1lbnQuYm9keS5nZXRFbGVtZW50c0J5VGFnTmFtZSgnc3ZnJylbMF0uYXBwZW5kQ2hpbGQoZSk7DQogICAgICAgIHZhciBldz1lLmdldEJCb3goKS53aWR0aDsNCiAgICAgICAgZG9jdW1lbnQuYm9keS5nZXRFbGVtZW50c0J5VGFnTmFtZSgnc3ZnJylbMF0ucmVtb3ZlQ2hpbGQoZSk7DQogICAgICAgIHZhciBoPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLCd0ZXh0Jyk7DQogICAgICAgIGgudGV4dENvbnRlbnQ9YnJyW2pdOw0KICAgICAgICBoLnN0eWxlLmZvbnRTaXplPScxMnB4JzsNCiAgICAgICAgaC5zdHlsZS5mb250V2VpZ2h0PSdib2xkJzsNCiAgICAgICAgZG9jdW1lbnQuYm9keS5nZXRFbGVtZW50c0J5VGFnTmFtZSgnc3ZnJylbMF0uYXBwZW5kQ2hpbGQoaCk7DQogICAgICAgIHZhciBodz1oLmdldEJCb3goKS53aWR0aDsNCiAgICAgICAgZG9jdW1lbnQuYm9keS5nZXRFbGVtZW50c0J5VGFnTmFtZSgnc3ZnJylbMF0ucmVtb3ZlQ2hpbGQoaCk7DQogICAgICAgIGw9ZXc+aHc/ZXc6aHc7DQogICAgICAgIGxsPWw+bGw/bDpsbDsNCiAgICB9DQogICAgcmV0dXJuIGxsOw0KfQ0KZm9yKHZhciBpPTA7aTxsaW5rcy5sZW5ndGg7aSsrKXsNCiAgICB2YXIgcG9wdXA9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsJ2cnKTsNCiAgICB2YXIgcG9wdXBSPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJywncmVjdCcpOw0KICAgIHZhciBob3Zlcj1kb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJywncmVjdCcpOw0KICAgIHZhciBkZXNjYXJyPVtdOw0KICAgIHZhciBsaW5rYXJyPVtdOw0KICAgIGhvdmVyLnNldEF0dHJpYnV0ZSgnZmlsbCcsJyNjZGNkZmYnKTsNCiAgICBob3Zlci5zZXRBdHRyaWJ1dGUoJ3gnLCcwJyk7DQogICAgaG92ZXIuc2V0QXR0cmlidXRlKCd5JywnMCcpOw0KICAgIGhvdmVyLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywnMTYnKTsNCiAgICBob3Zlci5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywnMTYnKTsNCiAgICBob3Zlci5zZXRBdHRyaWJ1dGUoJ2ZpbGwtb3BhY2l0eScsJzAuNicpOw0KICAgIGhvdmVyLnNldEF0dHJpYnV0ZSgndHJhbnNmb3JtJyxsaW5rc1tpXS5xdWVyeVNlbGVjdG9yKCd1c2UnKS5nZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScpKTsNCiAgICBob3Zlci5zdHlsZS5kaXNwbGF5PSdub25lJzsNCiAgICBsaW5rc1tpXS5hcHBlbmRDaGlsZChob3Zlcik7DQogICAgLy8gY29uc29sZS5sb2cobGlua3NbaV0uZ2V0QXR0cmlidXRlKCdlZDpoeXBlcmxpbmsnKSk7DQogICAgdmFyIGE9SlNPTi5wYXJzZShsaW5rc1tpXS5nZXRBdHRyaWJ1dGUoJ2VkOmh5cGVybGluaycpKTsNCiAgICB2YXIgY3M9bGlua3NbaV0ucXVlcnlTZWxlY3RvcigndXNlJykuZ2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nKS5tYXRjaCgvXCgoXFMqfFxTKlxzXFMqKVwpLylbMV0uc3BsaXQoLyB8LC8pOw0KICAgIHZhciBwcz1saW5rc1tpXS5wYXJlbnROb2RlLmdldEF0dHJpYnV0ZSgndHJhbnNmb3JtJyk7DQogICAgaWYocHMuc3Vic3RyKDAsMikgPT0gJ3RyJyl7DQogICAgICAgIHZhciBwcHMgPSBwcy5tYXRjaCgvXCgoXFMqfFxTKlxzXFMqKVwpLylbMV0uc3BsaXQoLyB8LC8pOw0KICAgICAgICB2YXIgeD1wYXJzZUZsb2F0KGNzWzBdKStwYXJzZUZsb2F0KHBwc1swXSk7DQogICAgICAgIHZhciB5PXBhcnNlRmxvYXQocHBzWzFdKTsNCiAgICAgICAgeD14LnRvc3VpdHN2ZygpOw0KICAgICAgICB5PXkudG9zdWl0c3ZnKCk7DQogICAgICAgIHZhciB0cnN0ciA9ICd0cmFuc2xhdGUoJyt4KycsJyt5KycpJzsNCiAgICB9ZWxzZSBpZihwcy5zdWJzdHIoMCwyKSA9PSAnbWEnKXsNCiAgICAgICAgdmFyIHBwcyA9IHBzLm1hdGNoKC8oXC0/XGQrKFwuXGQrKT8pW1wsIF0oXC0/XGQrKFwuXGQrKT8pW1wsIF0oXC0/XGQrKFwuXGQrKT8pW1wsIF0oXC0/XGQrKFwuXGQrKT8pW1wsIF0oXC0/XGQrKFwuXGQrKT8pW1wsIF0oXC0/XGQrKFwuXGQrKT8pXCkkLyk7DQogICAgICAgIHZhciBtYUFyciA9IFtwYXJzZUZsb2F0KHBwc1sxXSkscGFyc2VGbG9hdChwcHNbM10pLHBhcnNlRmxvYXQocHBzWzVdKSxwYXJzZUZsb2F0KHBwc1s3XSkscGFyc2VGbG9hdChwcHNbOV0pLHBhcnNlRmxvYXQocHBzWzExXSldOw0KICAgICAgICBpZihtYUFyclsxXSA9PSAwKXsNCiAgICAgICAgICAgIHZhciB4ID0gcGFyc2VGbG9hdChjc1swXSk7DQogICAgICAgICAgICB2YXIgeSA9IHBhcnNlRmxvYXQoY3NbMV0pKzE2Ow0KICAgICAgICAgICAgdmFyIHgxID0geCAqIG1hQXJyWzBdICsgeSAqIG1hQXJyWzJdICsgbWFBcnJbNF07DQogICAgICAgICAgICB2YXIgeTEgPSB4ICogbWFBcnJbMV0gKyB5ICogbWFBcnJbM10gKyBtYUFycls1XTsNCiAgICAgICAgICAgIHgxPXgxLnRvc3VpdHN2ZygpOw0KICAgICAgICAgICAgeTE9eTEudG9zdWl0c3ZnKCk7DQogICAgICAgICAgICB2YXIgdHJzdHIgPSAgJ3RyYW5zbGF0ZSgnK3gxKycsJyt5MSsnKSc7DQogICAgICAgIH1lbHNlew0KICAgICAgICAgICAgdmFyIHggPSBwYXJzZUZsb2F0KGNzWzBdKSsxNjsNCiAgICAgICAgICAgIHZhciB5ID0gcGFyc2VGbG9hdChjc1sxXSkrMTY7DQogICAgICAgICAgICB2YXIgeDEgPSB4ICogbWFBcnJbMF0gKyB5ICogbWFBcnJbMl0gKyBtYUFycls0XTsNCiAgICAgICAgICAgIHZhciB5MSA9IHggKiBtYUFyclsxXSArIHkgKiBtYUFyclszXSArIG1hQXJyWzVdOw0KICAgICAgICAgICAgeCA9IHBhcnNlRmxvYXQoY3NbMF0pKzE2Ow0KICAgICAgICAgICAgeSA9IHBhcnNlRmxvYXQoY3NbMV0pOw0KICAgICAgICAgICAgdmFyIHgyID0geCAqIG1hQXJyWzBdICsgeSAqIG1hQXJyWzJdICsgbWFBcnJbNF07DQogICAgICAgICAgICB2YXIgeTIgPSB4ICogbWFBcnJbMV0gKyB5ICogbWFBcnJbM10gKyBtYUFycls1XTsNCiAgICAgICAgICAgIHZhciBmeCA9IHgxPHgyP3gxLnRvc3VpdHN2ZygpOiB4Mi50b3N1aXRzdmcoKTsNCiAgICAgICAgICAgIHZhciBmeSA9IHkxPnkyP3kxLnRvc3VpdHN2ZygpOiB5Mi50b3N1aXRzdmcoKTsNCgkJCXZhciBvZmZ5ID0gTWF0aC5hYnMoeTEteTIpOwkJCQkJCQkJCQkgIA0KICAgICAgICAgICAgdmFyIHRyc3RyID0gICd0cmFuc2xhdGUoJytmeCsnLCcrZnkrJyknOw0KICAgICAgICAgICAgcG9wdXBSLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JyxvZmZ5LnRvU3RyaW5nKCkpOw0KICAgICAgICAgICAgcG9wdXBSLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCcxNicpOw0KICAgICAgICAgICAgcG9wdXBSLnNldEF0dHJpYnV0ZSgneScsKC1vZmZ5KS50b1N0cmluZygpKTsNCiAgICAgICAgICAgIHBvcHVwUi5zZXRBdHRyaWJ1dGUoJ2ZpbGwnLCd0cmFuc3BhcmVudCcpOw0KICAgICAgICAgICAgcG9wdXAuYXBwZW5kQ2hpbGQocG9wdXBSKTsNCiAgICAgICAgfQ0KICAgIH0NCiAgICB2YXIgYWw9YS5sZW5ndGg7DQogICAgZm9yKHZhciBqPTA7ajxhbDtqKyspew0KICAgICAgICBsaW5rYXJyLnB1c2goYVtqXS5saW5rKTsNCiAgICAgICAgZGVzY2Fyci5wdXNoKGFbal0uZGVzYyk7DQogICAgfQ0KICAgIHBvcHVwLnNldEF0dHJpYnV0ZSgndHJhbnNmb3JtJyx0cnN0cik7DQogICAgdmFyIG1heD1nZXRtYXhsZW4obGlua2FycixkZXNjYXJyKTsNCiAgICBmb3IodmFyIGs9MDtrPGFsO2srKyl7DQogICAgICAgIHZhciBjPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLCdhJyk7DQogICAgICAgIHZhciBkPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLCdyZWN0Jyk7DQogICAgICAgIHZhciBlPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLCd0ZXh0Jyk7DQogICAgICAgIHZhciBmPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLCd0ZXh0Jyk7DQogICAgICAgIGlmKGlzTmFOKGxpbmthcnJba10pKXsNCiAgICAgICAgICAgIGMuc2V0QXR0cmlidXRlTlMoImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiwgInhsaW5rIiwgImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiKTsNCiAgICAgICAgICAgIGMuc2V0QXR0cmlidXRlTlMoImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiLCAiaHJlZiIsIGxpbmthcnJba10pOw0KICAgICAgICAgICAgYy5zZXRBdHRyaWJ1dGUoJ3RhcmdldCcsJ19ibGFuaycpOw0KICAgICAgICAgICAgZS50ZXh0Q29udGVudD1saW5rYXJyW2tdOw0KICAgICAgICB9ZWxzZXsNCiAgICAgICAgICAgIGUudGV4dENvbnRlbnQ9J1BhZ2UtJytsaW5rYXJyW2tdOw0KICAgICAgICAgICAgYy5zZXRBdHRyaWJ1dGVOUygiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciLCAieGxpbmsiLCAiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIpOw0KICAgICAgICAgICAgYy5zZXRBdHRyaWJ1dGVOUygiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIsICJocmVmIiwgIiMiK2xpbmthcnJba10pOw0KICAgICAgICB9DQogICAgICAgIGQuc2V0QXR0cmlidXRlKCd3aWR0aCcsbWF4KzEwKTsNCiAgICAgICAgZC5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsJzMzJyk7DQogICAgICAgIGQuc2V0QXR0cmlidXRlKCdzdHJva2UnLCcjOTk5OTk5Jyk7DQogICAgICAgIGQuc2V0QXR0cmlidXRlKCdmaWxsJywnd2hpdGUnKTsNCiAgICAgICAgZC5zZXRBdHRyaWJ1dGUoJ3knLDMzKmspOw0KICAgICAgICBmLnRleHRDb250ZW50PWRlc2NhcnJba107DQogICAgICAgIGYuc3R5bGUuZm9udFNpemU9JzEycHgnOw0KICAgICAgICBmLnN0eWxlLmZvbnRXZWlnaHQ9J2JvbGQnOw0KICAgICAgICBmLnNldEF0dHJpYnV0ZSgneCcsNSk7DQogICAgICAgIGYuc2V0QXR0cmlidXRlKCd5JywzMyprKzEyKTsNCiAgICAgICAgZS5zdHlsZS5mb250U2l6ZT0nMTJweCc7DQogICAgICAgIGUuc2V0QXR0cmlidXRlKCd5JywzMyprKzI4KTsNCiAgICAgICAgZS5zZXRBdHRyaWJ1dGUoJ3gnLDUpOw0KICAgICAgICBjLmFwcGVuZENoaWxkKGQpOw0KICAgICAgICBjLmFwcGVuZENoaWxkKGYpOw0KICAgICAgICBjLmFwcGVuZENoaWxkKGUpOw0KICAgICAgICBjLm9ubW91c2VvdmVyPWZ1bmN0aW9uICgpIHsNCiAgICAgICAgICAgIHRoaXMucXVlcnlTZWxlY3RvcigncmVjdCcpLnN0eWxlLmZpbGw9JyNlMWUxZmYnDQogICAgICAgIH07DQogICAgICAgIGMub25tb3VzZW91dD1mdW5jdGlvbiAoKSB7DQogICAgICAgICAgICB0aGlzLnF1ZXJ5U2VsZWN0b3IoJ3JlY3QnKS5zdHlsZS5maWxsPSd3aGl0ZScNCiAgICAgICAgfTsNCiAgICAgICAgcG9wdXAuYXBwZW5kQ2hpbGQoYyk7DQogICAgfQ0KICAgIHBvcHVwLnN0eWxlLmRpc3BsYXk9J25vbmUnOw0KICAgIHBvcHVwLnNldEF0dHJpYnV0ZSgnaHlwZXJsaW5rJywnJyk7DQogICAgcG9wdXAuc2V0QXR0cmlidXRlKCdlZDpsaW5raWQnLGxpbmtzW2ldLnBhcmVudE5vZGUuaWQpOw0KICAgIHBvcHVwLm9ubW91c2VvdmVyPWZ1bmN0aW9uICgpIHsNCiAgICAgICAgdGhpcy5zdHlsZS5kaXNwbGF5PSdibG9jayc7DQogICAgfTsNCiAgICBwb3B1cC5vbmNsaWNrPWZ1bmN0aW9uICgpIHsNCiAgICAgICAgdGhpcy5zdHlsZS5kaXNwbGF5PSdub25lJzsNCiAgICB9Ow0KICAgIHBvcHVwLm9ubW91c2VvdXQ9ZnVuY3Rpb24gKCkgew0KICAgICAgICB0aGlzLnN0eWxlLmRpc3BsYXk9J25vbmUnOw0KICAgIH07DQogICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI3N2Zy1jb250YWluZXIgPiBzdmcnKS5hcHBlbmRDaGlsZChwb3B1cCk7DQogICAgbGlua3NbaV0ub25tb3VzZW92ZXI9ZnVuY3Rpb24gKCkgew0KICAgICAgICB2YXIgbGlua2lkPXRoaXMucGFyZW50Tm9kZS5pZDsNCiAgICAgICAgdGhpcy5xdWVyeVNlbGVjdG9yKCdyZWN0Jykuc3R5bGUuZGlzcGxheT0nYmxvY2snOw0KICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCJnW2VkXFw6bGlua2lkPSciK2xpbmtpZCsiJ11baHlwZXJsaW5rXSIpLnN0eWxlLmRpc3BsYXk9J2Jsb2NrJzsNCiAgICB9DQogICAgbGlua3NbaV0ub25tb3VzZW91dD1mdW5jdGlvbiAoKSB7DQogICAgICAgIHZhciBsaW5raWQ9dGhpcy5wYXJlbnROb2RlLmlkOw0KICAgICAgICB0aGlzLnF1ZXJ5U2VsZWN0b3IoJ3JlY3QnKS5zdHlsZS5kaXNwbGF5PSdub25lJzsNCiAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcigiZ1tlZFxcOmxpbmtpZD0nIitsaW5raWQrIiddW2h5cGVybGlua10iKS5zdHlsZS5kaXNwbGF5PSdub25lJzsNCiAgICB9DQp9DQovLy0taHlwZXJsaW5rDQovL2luaXRpYWxpemUtLQ0KdmFyIHNoYXBlPWRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ2dbZWRcXDp0b2d0b3BpY2lkXScpOw0KdmFyIG1JZD1kb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdnW2VkXFw6dG9waWN0eXBlXScpOw0KdmFyIGRhdGFUcmVlPXt9Ow0KdmFyIGV4dHJhUmVsYT17fTsNCnZhciBjaGVja0lEPScnOw0KZm9yKHZhciBpPTA7aTxtSWQubGVuZ3RoO2krKyl7DQogICAgdmFyIHR5cGU9bUlkW2ldLmdldEF0dHJpYnV0ZSgnZWQ6dG9waWN0eXBlJyk7DQogICAgdmFyIHNpZD1tSWRbaV0uaWQ7DQogICAgaWYodHlwZSE9PSdjYWxsb3V0Jyl7DQogICAgICAgIGluaXQoc2lkLGRhdGFUcmVlKQ0KICAgIH0NCn0NCmZ1bmN0aW9uIGluaXQoaWQsIG9iaikgew0KICAgIHZhciBjaGlsZHMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCJnW2VkXFw6cGFyZW50aWQ9JyIgKyBpZCArICInXTpub3QoW2VkXFw6dG9waWN0eXBlXSkiKTsNCiAgICB2YXIgY2FsbHMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCJnW2VkXFw6cGFyZW50aWQ9JyIgKyBpZCArICInXVtlZFxcOnRvcGljdHlwZV0iKTsNCiAgICB2YXIgc3VtbWFyeSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoInBhdGhbZWRcXDpwYXJlbnRpZCo9JyIgKyBpZCArICInXVtlZFxcOnR5cGU9J3N1bW1hcnknXSIpOw0KICAgIHZhciBib3VuZGFyeT0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgicGF0aFtlZFxcOnBhcmVudGlkKj0nIiArIGlkICsgIiddW2VkXFw6dHlwZT0nYm91bmRhcnknXSIpOw0KICAgIHZhciByZWxhZnJvbT1kb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCJnW2VkXFw6ZnJvbWlkKj0nIiArIGlkICsgIiddW2VkXFw6dHlwZT0ncmVsYXRpb24nXSIpOw0KICAgIHZhciByZWxhdG89ZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgiZ1tlZFxcOnRvaWQqPSciICsgaWQgKyAiJ11bZWRcXDp0eXBlPSdyZWxhdGlvbiddIik7DQogICAgb2JqWyJtIiArIGlkXSA9IHt9Ow0KICAgIHZhciB0eXBlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpLmdldEF0dHJpYnV0ZSgnZWQ6dG9waWN0eXBlJyk7DQogICAgdmFyIGl3PWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKS5nZXRBdHRyaWJ1dGUoJ2VkOndpZHRoJyk7DQogICAgdmFyIGloPWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKS5nZXRBdHRyaWJ1dGUoJ2VkOmhlaWdodCcpOw0KICAgIGlmICh0eXBlKSB7DQogICAgICAgIG9ialsibSIgKyBpZF0udHlwZSA9IHR5cGU7DQogICAgfQ0KICAgIGlmKGl3JiZpaCl7DQogICAgICAgIG9ialsibSIgKyBpZF0ud2lkdGggPWl3Ow0KICAgICAgICBvYmpbIm0iICsgaWRdLmhlaWdodCA9aWg7DQogICAgfQ0KICAgIGlmIChyZWxhZnJvbS5sZW5ndGggIT09IDApIHsNCiAgICAgICAgb2JqWyJtIiArIGlkXS5yZWxhZnJvbSA9IHt9Ow0KICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlbGFmcm9tLmxlbmd0aDsgaSsrKSB7DQogICAgICAgICAgICB2YXIgaW5kZXhpZCA9IHJlbGFmcm9tW2ldLmlkOw0KICAgICAgICAgICAgdmFyIHRvaWQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpbmRleGlkKS5nZXRBdHRyaWJ1dGUoJ2VkOnRvaWQnKTsNCiAgICAgICAgICAgIGlmIChleHRyYVJlbGFbaW5kZXhpZF0gPT09IHVuZGVmaW5lZCkgew0KICAgICAgICAgICAgICAgIGV4dHJhUmVsYVtpbmRleGlkXSA9IHsNCiAgICAgICAgICAgICAgICAgICAgaWQ6IGluZGV4aWQsDQogICAgICAgICAgICAgICAgICAgIGZyb21pZDogaWQsDQogICAgICAgICAgICAgICAgICAgIHRvaWQ6IHRvaWQsDQogICAgICAgICAgICAgICAgICAgIGlzQzogZmFsc2UNCiAgICAgICAgICAgICAgICB9Ow0KICAgICAgICAgICAgfQ0KICAgICAgICAgICAgb2JqWyJtIiArIGlkXS5yZWxhZnJvbVtpbmRleGlkXT17fTsNCiAgICAgICAgICAgIG9ialsibSIgKyBpZF0ucmVsYWZyb20uZGlzcGxheT1kb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCkuc3R5bGUuZGlzcGxheSAhPT0gJ25vbmUnPydibG9jayc6J25vbmUnOw0KICAgICAgICB9DQogICAgfQ0KICAgIGlmIChyZWxhdG8ubGVuZ3RoICE9PSAwKSB7DQogICAgICAgIG9ialsibSIgKyBpZF0ucmVsYXRvID0ge307DQogICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVsYXRvLmxlbmd0aDsgaSsrKSB7DQogICAgICAgICAgICB2YXIgaW5kZXhpZD1yZWxhdG9baV0uaWQ7DQogICAgICAgICAgICB2YXIgZnJvbWlkPWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGluZGV4aWQpLmdldEF0dHJpYnV0ZSgnZWQ6ZnJvbWlkJyk7DQogICAgICAgICAgICBpZihleHRyYVJlbGFbaW5kZXhpZF0gPT09IHVuZGVmaW5lZCl7DQogICAgICAgICAgICAgICAgZXh0cmFSZWxhW2luZGV4aWRdPXsNCiAgICAgICAgICAgICAgICAgICAgaWQ6aW5kZXhpZCwNCiAgICAgICAgICAgICAgICAgICAgZnJvbWlkOmZyb21pZCwNCiAgICAgICAgICAgICAgICAgICAgdG9pZDppZCwNCiAgICAgICAgICAgICAgICAgICAgaXNDOmZhbHNlDQogICAgICAgICAgICAgICAgfTsNCiAgICAgICAgICAgIH0NCiAgICAgICAgICAgIG9ialsibSIgKyBpZF0ucmVsYXRvW2luZGV4aWRdPXt9Ow0KICAgICAgICAgICAgb2JqWyJtIiArIGlkXS5yZWxhdG8uZGlzcGxheT1kb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCkuc3R5bGUuZGlzcGxheSAhPT0gJ25vbmUnPydibG9jayc6J25vbmUnOw0KICAgICAgICB9DQogICAgfQ0KICAgIGlmIChjaGlsZHMubGVuZ3RoICE9PSAwKSB7DQogICAgICAgIG9ialsibSIgKyBpZF0uY2hpbGQgPSB7fTsNCiAgICAgICAgaWYgKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoImdbZWRcXDp0b2d0b3BpY2lkPSciICsgaWQgKyAiJ10iKSkgew0KICAgICAgICAgICAgLy8gY29uc29sZS5sb2coZG9jdW1lbnQucXVlcnlTZWxlY3RvcigiZ1tlZFxcOnRvZ3RvcGljaWQ9JyIgKyBpZCArICInXSIpLmNoaWxkTm9kZXNbMF0uZ2V0QXR0cmlidXRlKCd4bGluazpocmVmJykpOw0KICAgICAgICAgICAgdmFyIHRvZyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoImdbZWRcXDp0b2d0b3BpY2lkPSciICsgaWQgKyAiJ10iKS5nZXRFbGVtZW50c0J5VGFnTmFtZSgndXNlJylbMF0uZ2V0QXR0cmlidXRlKCd4bGluazpocmVmJykuc2xpY2UoMSk7DQogICAgICAgICAgICBvYmpbIm0iICsgaWRdLnRvZ3R5cGUgPSB0b2c7DQogICAgICAgIH0NCiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHMubGVuZ3RoOyBpKyspIHsNCiAgICAgICAgICAgIHZhciBjaWQgPSBjaGlsZHNbaV0uaWQ7DQogICAgICAgICAgICBpbml0KGNpZCwgb2JqWyJtIiArIGlkXS5jaGlsZCk7DQogICAgICAgIH0NCiAgICB9DQogICAgaWYgKGNhbGxzLmxlbmd0aCAhPT0gMCkgew0KICAgICAgICBvYmpbIm0iICsgaWRdLmNhbGwgPSB7fTsNCiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYWxscy5sZW5ndGg7IGkrKykgew0KICAgICAgICAgICAgdmFyIGNpZCA9IGNhbGxzW2ldLmlkOw0KICAgICAgICAgICAgaW5pdChjaWQsIG9ialsibSIgKyBpZF0uY2FsbCk7DQogICAgICAgIH0NCiAgICB9DQogICAgaWYgKGJvdW5kYXJ5Lmxlbmd0aCAhPT0gMCkgew0KICAgICAgICBvYmpbIm0iICsgaWRdLmJvdW5kYXJ5ID0ge307DQogICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYm91bmRhcnkubGVuZ3RoOyBpKyspIHsNCiAgICAgICAgICAgIHZhciBjaWQgPWJvdW5kYXJ5W2ldLmlkOw0KICAgICAgICAgICAgaW5pdChjaWQsIG9ialsibSIgKyBpZF0uYm91bmRhcnkpOw0KICAgICAgICB9DQogICAgfQ0KICAgIGlmIChzdW1tYXJ5Lmxlbmd0aCAhPT0gMCkgew0KICAgICAgICBvYmpbIm0iICsgaWRdLnN1bW1hcnkgPSB7fTsNCiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdW1tYXJ5Lmxlbmd0aDsgaSsrKSB7DQogICAgICAgICAgICB2YXIgY2lkID0gc3VtbWFyeVtpXS5pZDsNCiAgICAgICAgICAgIGluaXQoY2lkLCBvYmpbIm0iICsgaWRdLnN1bW1hcnkpOw0KICAgICAgICB9DQogICAgfQ0KfQ0KLy8tLWluaXRpYWxpemUNCi8vdG9nZ2xlZGlzcGxheS0tDQp2YXIgY2hhaW5BcnI9W107DQpmdW5jdGlvbiBnZXRjaGFpbihpZCl7DQogICAgY2hhaW5BcnIudW5zaGlmdCgnbScraWQpOw0KICAgIHZhciBwYXJlbnQ9ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpLmdldEF0dHJpYnV0ZSgnZWQ6cGFyZW50aWQnKTsNCiAgICBpZighcGFyZW50KXsNCiAgICAgICAgcmV0dXJuOw0KICAgIH0NCglpZihwYXJlbnQubWF0Y2goL1wsLykpew0KICAgICAgICBwYXJlbnQgPSBwYXJlbnQubWF0Y2goL1xkKyg/PVwsKS8pWzBdDQogICAgfQ0KICAgIGdldGNoYWluKHBhcmVudCk7DQp9DQpmdW5jdGlvbiBnZXRvYmooaWQpIHsNCiAgICBjaGFpbkFycj1bXTsNCiAgICBnZXRjaGFpbihpZCk7DQogICAgdmFyIG1haW49Y2hhaW5BcnJbMF07DQogICAgaWYoY2hhaW5BcnIubGVuZ3RoPjEpew0KICAgICAgICB2YXIgb2JqPWRhdGFUcmVlW21haW5dOw0KICAgICAgICAvLyBjb25zb2xlLmxvZyhjaGFpbkFycik7DQogICAgICAgIGZvcih2YXIgaT0xO2k8Y2hhaW5BcnIubGVuZ3RoO2krKykgew0KICAgICAgICAgICAgdmFyIGEgPSBjaGFpbkFycltpXTsNCiAgICAgICAgICAgIGZvcih2YXIgaj0wO2o8T2JqZWN0LmtleXMob2JqKS5sZW5ndGg7aisrKXsNCiAgICAgICAgICAgICAgICB2YXIgY29iaj0gb2JqW09iamVjdC5rZXlzKG9iailbal1dW2FdOw0KICAgICAgICAgICAgICAgIGlmKGNvYmopew0KICAgICAgICAgICAgICAgICAgICBvYmo9Y29iajsNCiAgICAgICAgICAgICAgICAgICAgY29udGludWUNCiAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICB9DQogICAgICAgIH0NCiAgICAgICAgcmV0dXJuIG9iag0KICAgIH1lbHNlew0KICAgICAgICB2YXIgb2JqPWRhdGFUcmVlW21haW5dOw0KICAgICAgICByZXR1cm4gb2JqDQogICAgfQ0KDQp9DQpmb3IodmFyIGk9MDtpPHNoYXBlLmxlbmd0aDtpKyspew0KICAgIHNoYXBlW2ldLm9uY2xpY2s9ZnVuY3Rpb24gKCkgew0KICAgICAgICB2YXIgaWQ9TnVtYmVyKHRoaXMuZ2V0QXR0cmlidXRlKCdlZDp0b2d0b3BpY2lkJykpOw0KICAgICAgICB2YXIgb2JqPWdldG9iaihpZCk7DQoNCiAgICAgICAgdmFyIHR5cGU9b2JqLnRvZ3R5cGU9PT0nbWludXMnPydwbHVzJzonbWludXMnOw0KICAgICAgICB2YXIgZGlzcGxheT1vYmoudG9ndHlwZT09PSdtaW51cyc/J25vbmUnOidibG9jayc7DQogICAgICAgIHRoaXMuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3VzZScpWzBdLnNldEF0dHJpYnV0ZSgneGxpbms6aHJlZicsJyMnK3R5cGUpOw0KICAgICAgICBvYmoudG9ndHlwZT10eXBlOw0KICAgICAgICBjaGVja0lEPW9iajsNCg0KICAgICAgICB1dGQob2JqLGlkLGRpc3BsYXkpOw0KICAgICAgICBleHRyYVJlbGFGaW4oKTsNCiAgICB9DQp9DQpmdW5jdGlvbiB1dGQob2JqLGlkLHNob3csb2MpIHsNCg0KICAgIHZhciBwc2hvdz1kb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCkuc3R5bGUuZGlzcGxheSE9PSAnbm9uZSc/J2Jsb2NrJzonbm9uZSc7DQogICAgaWYgKG9iai5yZWxhZnJvbSl7DQogICAgICAgIGlmKG9iai5yZWxhZnJvbS5kaXNwbGF5IT09IHBzaG93KXsNCiAgICAgICAgICAgIHZhciByZWxhZnJvbXM9T2JqZWN0LmtleXMob2JqLnJlbGFmcm9tKTsNCiAgICAgICAgICAgIHJlbGFmcm9tcy5zcGxpY2UocmVsYWZyb21zLmluZGV4T2YoJ2Rpc3BsYXknKSwxKTsNCiAgICAgICAgICAgIGZvcih2YXIgaz0wO2s8cmVsYWZyb21zLmxlbmd0aDtrKyspew0KICAgICAgICAgICAgICAgIHZhciBkPXJlbGFmcm9tc1trXTsNCiAgICAgICAgICAgICAgICBleHRyYVJlbGFbZF0uaXNDPXRydWU7DQogICAgICAgICAgICB9DQogICAgICAgICAgICBvYmoucmVsYWZyb20uZGlzcGxheSA9IHBzaG93Ow0KICAgICAgICB9DQogICAgfQ0KICAgIGlmIChvYmoucmVsYXRvKXsNCiAgICAgICAgaWYob2JqLnJlbGF0by5kaXNwbGF5IT09IHBzaG93KXsNCiAgICAgICAgICAgIHZhciByZWxhdG9zPU9iamVjdC5rZXlzKG9iai5yZWxhdG8pOw0KICAgICAgICAgICAgcmVsYXRvcy5zcGxpY2UocmVsYXRvcy5pbmRleE9mKCdkaXNwbGF5JyksMSk7DQogICAgICAgICAgICBmb3IodmFyIGs9MDtrPHJlbGF0b3MubGVuZ3RoO2srKyl7DQogICAgICAgICAgICAgICAgdmFyIGQ9cmVsYXRvc1trXTsNCiAgICAgICAgICAgICAgICBleHRyYVJlbGFbZF0uaXNDPXRydWU7DQogICAgICAgICAgICB9DQogICAgICAgICAgICBvYmoucmVsYXRvLmRpc3BsYXkgPSBwc2hvdzsNCiAgICAgICAgfQ0KICAgIH0NCiAgICBpZihvYmouY2FsbCl7DQogICAgICAgIHZhciBjYWxscz1PYmplY3Qua2V5cyhvYmouY2FsbCk7DQogICAgICAgIGlmKGNoZWNrSUQhPT1vYmopew0KICAgICAgICAgICAgZm9yKHZhciBpPTA7aSA8IGNhbGxzLmxlbmd0aDtpKyspew0KICAgICAgICAgICAgICAgIHZhciBhPWNhbGxzW2ldLnNsaWNlKDEpOw0KICAgICAgICAgICAgICAgIHZhciBiPW9iai5jYWxsW2NhbGxzW2ldXTsNCiAgICAgICAgICAgICAgICB2YXIgYz1iLnRvZ3R5cGU7DQogICAgICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoYSkuc3R5bGUuZGlzcGxheT1zaG93Ow0KICAgICAgICAgICAgICAgIGlmIChiLnJlbGFmcm9tJiYhYyl7DQogICAgICAgICAgICAgICAgICAgIGlmKGIucmVsYWZyb20uZGlzcGxheSE9PSBzaG93KXsNCiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZWxhZnJvbXM9T2JqZWN0LmtleXMoYi5yZWxhZnJvbSk7DQogICAgICAgICAgICAgICAgICAgICAgICByZWxhZnJvbXMuc3BsaWNlKHJlbGFmcm9tcy5pbmRleE9mKCdkaXNwbGF5JyksMSk7DQogICAgICAgICAgICAgICAgICAgICAgICBmb3IodmFyIGs9MDtrPHJlbGFmcm9tcy5sZW5ndGg7aysrKXsNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZD1yZWxhZnJvbXNba107DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0cmFSZWxhW2RdLmlzQz10cnVlOw0KICAgICAgICAgICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgICAgICAgICAgICAgYi5yZWxhZnJvbS5kaXNwbGF5ID0gc2hvdzsNCiAgICAgICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgICAgIH0NCiAgICAgICAgICAgICAgICBpZiAoYi5yZWxhdG8mJiFjKXsNCiAgICAgICAgICAgICAgICAgICAgaWYoYi5yZWxhdG8uZGlzcGxheSE9PSBzaG93KXsNCiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZWxhdG9zPU9iamVjdC5rZXlzKGIucmVsYXRvKTsNCiAgICAgICAgICAgICAgICAgICAgICAgIHJlbGF0b3Muc3BsaWNlKHJlbGF0b3MuaW5kZXhPZignZGlzcGxheScpLDEpOw0KICAgICAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBrPTA7azxyZWxhdG9zLmxlbmd0aDtrKyspew0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkPXJlbGF0b3Nba107DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0cmFSZWxhW2RdLmlzQz10cnVlOw0KICAgICAgICAgICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgICAgICAgICAgICAgYi5yZWxhdG8uZGlzcGxheSA9IHNob3c7DQogICAgICAgICAgICAgICAgICAgIH0NCiAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICAgICAgaWYoYyl7DQogICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoImdbZWRcXDp0b2d0b3BpY2lkPSciK2ErIiddIikuc3R5bGUuZGlzcGxheT1zaG93Ow0KICAgICAgICAgICAgICAgICAgICBpZihjPT09J21pbnVzJyl7DQogICAgICAgICAgICAgICAgICAgICAgICB1dGQoYixhLHNob3cpDQogICAgICAgICAgICAgICAgICAgIH0NCiAgICAgICAgICAgICAgICAgICAgaWYgKChiLmNhbGx8fGIuYm91bmRhcnl8fGIuc3VtbWFyeSkmJmM9PT0ncGx1cycpIHsNCiAgICAgICAgICAgICAgICAgICAgICAgIHV0ZChiLGEsc2hvdyx0cnVlKQ0KICAgICAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgICAgIGlmKGIuY2FsbCYmIWMpIHsNCiAgICAgICAgICAgICAgICAgICAgdXRkKGIsYSxzaG93LHRydWUpDQogICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgICAgIGlmIChiLnN1bW1hcnkmJiFjKSB7DQogICAgICAgICAgICAgICAgICAgIHV0ZChiLGEsc2hvdykNCiAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICAgICAgaWYgKGIuYm91bmRhcnkmJiFjKSB7DQogICAgICAgICAgICAgICAgICAgIHV0ZChiLGEsc2hvdykNCiAgICAgICAgICAgICAgICB9DQoNCiAgICAgICAgICAgIH0NCiAgICAgICAgfQ0KICAgIH0NCiAgICBpZihvYmouc3VtbWFyeSl7DQogICAgICAgIHZhciBzdW1tYXJ5cz1PYmplY3Qua2V5cyhvYmouc3VtbWFyeSk7DQogICAgICAgIGlmKChjaGVja0lEIT09b2JqJiYob2JqLnRvZ3R5cGU9PT0nbWludXMnfHwhb2JqLnRvZ3R5cGUpKXx8Y2hlY2tJRD09PW9iail7DQogICAgICAgICAgICBmb3IodmFyIGk9MDtpPHN1bW1hcnlzLmxlbmd0aDtpKyspew0KICAgICAgICAgICAgICAgIHZhciBhPXN1bW1hcnlzW2ldLnNsaWNlKDEpOw0KCQkJCXZhciBvc3AgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChhKS5nZXRBdHRyaWJ1dGUoJ2VkOnBhcmVudGlkJyk7DQogICAgICAgICAgICAgICAgaWYob3NwLm1hdGNoKC9cLC8pKXsNCiAgICAgICAgICAgICAgICAgICAgdmFyIG9zcGEgPSBvc3Auc3BsaXQoJywnKTsNCiAgICAgICAgICAgICAgICAgICAgdmFyIG9zcEw9MDsNCg0KICAgICAgICAgICAgICAgICAgICBmb3IodmFyIGo9MDtqPG9zcGEubGVuZ3RoO2orKyl7DQogICAgICAgICAgICAgICAgICAgICAgICBpZihzaG93ID09ICdub25lJyl7DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQob3NwYVtqXSkuc3R5bGUuZGlzcGxheSAhPSAnbm9uZScpew0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhazsNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9ZWxzZXsNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3NwTCsrOw0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0NCiAgICAgICAgICAgICAgICAgICAgICAgIH1lbHNlew0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihkb2N1bWVudC5nZXRFbGVtZW50QnlJZChhKS5zdHlsZS5kaXNwbGF5ICE9ICdub25lJyl7DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhazsNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfWVsc2V7DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvc3BMKys7DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0NCiAgICAgICAgICAgICAgICAgICAgICAgIH0NCg0KICAgICAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICAgICAgICAgIGlmKG9zcEwgIT09IG9zcGEubGVuZ3RoKXsNCiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlOw0KICAgICAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgICAgIHZhciBiPW9iai5zdW1tYXJ5W3N1bW1hcnlzW2ldXTsNCiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhhKTsNCiAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChhKS5zdHlsZS5kaXNwbGF5PXNob3c7DQovLyAgICAgICAgICAgICAgICBpZihjKXsNCi8vICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCJnW2VkXFw6dG9ndG9waWNpZD0nIithKyInXSIpLnN0eWxlLmRpc3BsYXk9c2hvdzsNCi8vICAgICAgICAgICAgICAgICAgICBpZihjPT09J21pbnVzJyl7DQovLyAgICAgICAgICAgICAgICAgICAgICAgIHV0ZChiLHNob3cpDQovLyAgICAgICAgICAgICAgICAgICAgfQ0KLy8gICAgICAgICAgICAgICAgICAgIGlmIChiLmNhbGwmJmM9PT0ncGx1cycpIHsNCi8vICAgICAgICAgICAgICAgICAgICAgICAgdXRkKGIsc2hvdyx0cnVlKQ0KLy8gICAgICAgICAgICAgICAgICAgIH0NCi8vICAgICAgICAgICAgICAgIH0NCi8vICAgICAgICAgICAgICAgIGlmKGIuY2FsbCYmIWMpIHsNCi8vICAgICAgICAgICAgICAgICAgICB1dGQoYixzaG93LHRydWUpDQovLyAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICAgICAgaWYoT2JqZWN0LmtleXMoYikubGVuZ3RoIT09MCl7DQogICAgICAgICAgICAgICAgICAgIHV0ZChiLGEsc2hvdykNCiAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICB9DQogICAgICAgIH0NCiAgICB9DQogICAgaWYob2JqLmJvdW5kYXJ5KXsNCiAgICAgICAgdmFyIGJvdW5kYXJ5cz1PYmplY3Qua2V5cyhvYmouYm91bmRhcnkpOw0KICAgICAgICBpZihjaGVja0lEIT09b2JqKXsNCiAgICAgICAgICAgIGZvcih2YXIgaT0wO2k8Ym91bmRhcnlzLmxlbmd0aDtpKyspew0KICAgICAgICAgICAgICAgIHZhciBhPWJvdW5kYXJ5c1tpXS5zbGljZSgxKTsNCiAgICAgICAgICAgICAgICB2YXIgYj1vYmouYm91bmRhcnlbYm91bmRhcnlzW2ldXTsNCiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhhKTsNCiAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChhKS5zdHlsZS5kaXNwbGF5PXNob3c7DQovLyAgICAgICAgICAgICAgICBpZihjKXsNCi8vICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCJnW2VkXFw6dG9ndG9waWNpZD0nIithKyInXSIpLnN0eWxlLmRpc3BsYXk9c2hvdzsNCi8vICAgICAgICAgICAgICAgICAgICBpZihjPT09J21pbnVzJyl7DQovLyAgICAgICAgICAgICAgICAgICAgICAgIHV0ZChiLHNob3cpDQovLyAgICAgICAgICAgICAgICAgICAgfQ0KLy8gICAgICAgICAgICAgICAgICAgIGlmIChiLmNhbGwmJmM9PT0ncGx1cycpIHsNCi8vICAgICAgICAgICAgICAgICAgICAgICAgdXRkKGIsc2hvdyx0cnVlKQ0KLy8gICAgICAgICAgICAgICAgICAgIH0NCi8vICAgICAgICAgICAgICAgIH0NCi8vICAgICAgICAgICAgICAgIGlmKGIuY2FsbCYmIWMpIHsNCi8vICAgICAgICAgICAgICAgICAgICB1dGQoYixzaG93LHRydWUpDQovLyAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICAgICAgaWYoT2JqZWN0LmtleXMoYikubGVuZ3RoIT09MCl7DQogICAgICAgICAgICAgICAgICAgIHV0ZChiLGEsc2hvdykNCiAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICB9DQogICAgICAgIH0NCiAgICB9DQogICAgaWYoIW9jJiZvYmouY2hpbGQpIHsNCiAgICAgICAgdmFyIGNoaWxkcyA9IE9iamVjdC5rZXlzKG9iai5jaGlsZCk7DQogICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRzLmxlbmd0aDsgaSsrKSB7DQogICAgICAgICAgICB2YXIgYSA9IGNoaWxkc1tpXS5zbGljZSgxKTsNCiAgICAgICAgICAgIHZhciBiID0gb2JqLmNoaWxkW2NoaWxkc1tpXV07DQogICAgICAgICAgICB2YXIgYyA9IGIudG9ndHlwZTsNCiAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGEpLnN0eWxlLmRpc3BsYXkgPSBzaG93Ow0KCQkJdmFyIHRTUGF0aCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoInBhdGhbZWRcXDp0b3N1cGVyaWQ9JyIrYSsiJ10iKTsNCiAgICAgICAgICAgIGlmKHRTUGF0aCl7DQogICAgICAgICAgICAgICAgdFNQYXRoLnN0eWxlLmRpc3BsYXkgPSBzaG93Ow0KICAgICAgICAgICAgfQ0KCQkJdmFyIG5vdGVUaXAgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCJnW2VkXFw6bm90ZXRvPSciK2ErIiddIik7DQogICAgICAgICAgICBpZihub3RlVGlwKXsNCiAgICAgICAgICAgICAgICBub3RlVGlwLnN0eWxlLmRpc3BsYXkgPSBzaG93Ow0KICAgICAgICAgICAgfQ0KICAgICAgICAgICAgaWYgKGIucmVsYWZyb20mJiFjKXsNCiAgICAgICAgICAgICAgICBpZihiLnJlbGFmcm9tLmRpc3BsYXkhPT0gc2hvdyl7DQogICAgICAgICAgICAgICAgICAgIHZhciByZWxhZnJvbXM9T2JqZWN0LmtleXMoYi5yZWxhZnJvbSk7DQogICAgICAgICAgICAgICAgICAgIHJlbGFmcm9tcy5zcGxpY2UocmVsYWZyb21zLmluZGV4T2YoJ2Rpc3BsYXknKSwxKTsNCiAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBrPTA7azxyZWxhZnJvbXMubGVuZ3RoO2srKyl7DQogICAgICAgICAgICAgICAgICAgICAgICB2YXIgZD1yZWxhZnJvbXNba107DQogICAgICAgICAgICAgICAgICAgICAgICBleHRyYVJlbGFbZF0uaXNDPXRydWU7DQogICAgICAgICAgICAgICAgICAgIH0NCiAgICAgICAgICAgICAgICAgICAgYi5yZWxhZnJvbS5kaXNwbGF5ID0gc2hvdzsNCiAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICB9DQogICAgICAgICAgICBpZiAoYi5yZWxhdG8mJiFjKXsNCiAgICAgICAgICAgICAgICBpZihiLnJlbGF0by5kaXNwbGF5IT09IHNob3cpew0KICAgICAgICAgICAgICAgICAgICB2YXIgcmVsYXRvcz1PYmplY3Qua2V5cyhiLnJlbGF0byk7DQogICAgICAgICAgICAgICAgICAgIHJlbGF0b3Muc3BsaWNlKHJlbGF0b3MuaW5kZXhPZignZGlzcGxheScpLDEpOw0KICAgICAgICAgICAgICAgICAgICBmb3IodmFyIGs9MDtrPHJlbGF0b3MubGVuZ3RoO2srKyl7DQogICAgICAgICAgICAgICAgICAgICAgICB2YXIgZD1yZWxhdG9zW2tdOw0KICAgICAgICAgICAgICAgICAgICAgICAgZXh0cmFSZWxhW2RdLmlzQz10cnVlOw0KICAgICAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICAgICAgICAgIGIucmVsYXRvLmRpc3BsYXkgPSBzaG93Ow0KICAgICAgICAgICAgICAgIH0NCiAgICAgICAgICAgIH0NCiAgICAgICAgICAgIGlmIChjKSB7DQogICAgICAgICAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcigiZ1tlZFxcOnRvZ3RvcGljaWQ9JyIgKyBhICsgIiddIikuc3R5bGUuZGlzcGxheSA9IHNob3c7DQogICAgICAgICAgICAgICAgaWYgKGMgPT09ICdtaW51cycpIHsNCiAgICAgICAgICAgICAgICAgICAgdXRkKGIsYSxzaG93KQ0KICAgICAgICAgICAgICAgIH0NCiAgICAgICAgICAgICAgICBpZiAoKGIuY2FsbHx8Yi5ib3VuZGFyeXx8Yi5zdW1tYXJ5KSYmYz09PSdwbHVzJykgew0KICAgICAgICAgICAgICAgICAgICB1dGQoYixhLHNob3csdHJ1ZSkNCiAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICB9DQogICAgICAgICAgICBpZiAoYi5jYWxsJiYhYykgew0KICAgICAgICAgICAgICAgIHV0ZChiLGEsc2hvdyx0cnVlKQ0KICAgICAgICAgICAgfQ0KICAgICAgICAgICAgaWYgKGIuc3VtbWFyeSYmIWMpIHsNCiAgICAgICAgICAgICAgICB1dGQoYixhLHNob3cpDQogICAgICAgICAgICB9DQogICAgICAgICAgICBpZiAoYi5ib3VuZGFyeSYmIWMpIHsNCiAgICAgICAgICAgICAgICB1dGQoYixhLHNob3cpDQogICAgICAgICAgICB9DQogICAgICAgIH0NCiAgICB9DQp9DQoNCmZ1bmN0aW9uIGV4dHJhUmVsYUZpbigpIHsNCiAgICB2YXIgZXh0cmFrZXlzPU9iamVjdC5rZXlzKGV4dHJhUmVsYSk7DQogICAgZm9yKHZhciBpPTA7aTxleHRyYWtleXMubGVuZ3RoO2krKyl7DQogICAgICAgIHZhciBleHRyYU9iaj1leHRyYVJlbGFbZXh0cmFrZXlzW2ldXTsNCiAgICAgICAgaWYoZXh0cmFPYmouaXNDID09PSB0cnVlKXsNCiAgICAgICAgICAgIHZhciBmc2hvdz1kb2N1bWVudC5nZXRFbGVtZW50QnlJZChleHRyYU9iai5mcm9taWQpLnN0eWxlLmRpc3BsYXkgIT09J25vbmUnPyB0cnVlOiBmYWxzZTsNCiAgICAgICAgICAgIHZhciB0c2hvdz1kb2N1bWVudC5nZXRFbGVtZW50QnlJZChleHRyYU9iai50b2lkKS5zdHlsZS5kaXNwbGF5ICE9PSdub25lJz8gdHJ1ZTogZmFsc2U7DQogICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChleHRyYU9iai5pZCkuc3R5bGUuZGlzcGxheT1mc2hvdyAmJiB0c2hvdz8gJ2Jsb2NrJzogJ25vbmUnOw0KICAgICAgICAgICAgZXh0cmFSZWxhW2V4dHJha2V5c1tpXV0uaXNDID0gZmFsc2U7DQogICAgICAgIH0NCiAgICB9DQp9'))"}],"posts":[{"title":"Dockerfile基础学习","slug":"1582786566","date":"2020-09-08T21:57:00.000Z","updated":"2020-09-08T14:42:15.796Z","comments":true,"path":"2020/09/09/1582786566/","link":"","permalink":"https://maiyikai.github.io/2020/09/09/1582786566/","excerpt":"通过Dockerfile文件构建镜像","text":"通过Dockerfile文件构建镜像 Dockerfile是什么？Dockerfile是用来构建镜像的文本文件，通过Dockerfile的格式，按顺序编写脚本，编译之后，通过脚本的顺序执行对应的指令，构建一个镜像。 Dockerfile关键字Dockerfile书写需要注意，对于Dockerfile保留的关键字需要全部大写，且后边必须有至少一个字符，否则将报错。以下是Dockerfile的保留关键字和解释123456789101112FROM：基础镜像，当前镜像是基于FROM指定的对象构建的MAINTAINER：镜像维护者的姓名和邮箱地址RUN：容器构建时需要执行的指令EXPOSE：当前容器对外暴露的端口WORKDIR：指定在创建容器后，终端默认登录进来的工作目录ENV：用来在构建镜像过程中设置环境变量ADD：将宿主机目录下的文件拷贝到镜像中，且ADD命令会自动处理URL和解压tar压缩包COPY：类似ADD，拷贝文件或目录到镜像中。将从构建上下文目录中&lt;源路径&gt;的文件/目录复制到新的一层的镜像内的&lt;目标路径&gt;位置VOLUME：容器数据卷，用于数据保存和持久化工作（指定目录中的文件数据，将会与默认的宿主机文件目录象关联，默认路径可通过`docker inspect Name|ID` 查看）CMD：指定容器启动时要运行的命令；dockerfile中可以有多个CMD指令，但只有最后一个生效，CMD会被docker run之后的参数替换ENTRYPOINT：指定容器启动时要执行的命令；ENTRYPOINT的目的和CMD一样，但是CMD会被docker run之后的参数替换，而ENTRYPOINT会将docker run之后的参数进行拼接到命令中ONBUILD：当构建一个被继承的dockerfile时运行命令，父镜像被子镜像继承后，父镜像的onbuild被触发 Dockerfile构建镜像当编写好Dockerfile文件之后，通过指令对Dockerfile进行构建，创建一个新的镜像 镜像：docker build -f /dockerfilePath/dockerfile -t imageName[:TAG] . 总结dockerfile构建镜像，可以按照自己的意愿构建镜像，如Java程序镜像，或者其他的镜像内容。","categories":[{"name":"Dockerfile","slug":"Dockerfile","permalink":"https://maiyikai.github.io/categories/Dockerfile/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://maiyikai.github.io/tags/Docker/"},{"name":"Linux","slug":"Linux","permalink":"https://maiyikai.github.io/tags/Linux/"},{"name":"Dockerfile","slug":"Dockerfile","permalink":"https://maiyikai.github.io/tags/Dockerfile/"}]},{"title":"Docker基础学习","slug":"1582786565","date":"2020-09-08T18:57:00.000Z","updated":"2020-09-08T14:45:38.637Z","comments":true,"path":"2020/09/09/1582786565/","link":"","permalink":"https://maiyikai.github.io/2020/09/09/1582786565/","excerpt":"Docker是一开源的应用容器引擎，基于GO语言并遵循Apache2.0协议开源。","text":"Docker是一开源的应用容器引擎，基于GO语言并遵循Apache2.0协议开源。 概述简介Docker 是一个开源项目，诞生于 2013 年初，最初是 dotCloud 公司内部的一个业余项目。它基于 Google 公司推出的 Go 语言实现。 项目后来加入了 Linux 基金会，遵从了 Apache 2.0 协议，项目代码在 GitHub 上进行维护。 Docker 自开源后受到广泛的关注和讨论，以至于 dotCloud 公司后来都改名为 Docker Inc。Redhat 已经在其 RHEL6.5 中集中支持 Docker；Google 也在其 PaaS 产品中广泛应用。 Docker 项目的目标是实现轻量级的操作系统虚拟化解决方案。 Docker 的基础是 Linux 容器（LXC）等技术。 在 LXC 的基础上 Docker 进行了进一步的封装，让用户不需要去关心容器的管理，使得操作更为简便。用户操作 Docker 的容器就像操作一个快速轻量级的虚拟机一样简单。 限制Docker只能安装在CentOS6.5以及更高的版本，系统内核版本为2.6.32-431或者更高的本版。可以通过命令查看系统信息和内核版本1sudo uname -a 或者1sudo uname -r 结果1Linux maiyikai.docker1 3.10.0-957.el7.x86_64 #1 SMP Thu Nov 8 23:39:32 UTC 2018 x86_64 x86_64 x86_64 GNU/Linux 安装Docker参考Docker官网或者菜鸟教程 Docker三要素 仓库：集中存放镜像的场所 镜像：可以看作是一个只读模板，镜像可以用来创建Docker容器，一个镜像可以创建多个容器 容器：是用镜像创建的运行实例 Docker指令查看Docker帮助文档12345678#查看Docker版本docker version#查看Docker容器的描述docker info#查看Docker帮助文档docker --help ####Docker指令通过指令查看Docker支持的所有命令123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778[root@maiyikai ~]# docker --helpUsage: docker [OPTIONS] COMMANDA self-sufficient runtime for containersOptions: --config string Location of client config files (default &quot;/root/.docker&quot;) -c, --context string Name of the context to use to connect to the daemon (overrides DOCKER_HOST env var and default context set with &quot;docker context use&quot;) -D, --debug Enable debug mode -H, --host list Daemon socket(s) to connect to -l, --log-level string Set the logging level (&quot;debug&quot;|&quot;info&quot;|&quot;warn&quot;|&quot;error&quot;|&quot;fatal&quot;) (default &quot;info&quot;) --tls Use TLS; implied by --tlsverify --tlscacert string Trust certs signed only by this CA (default &quot;/root/.docker/ca.pem&quot;) --tlscert string Path to TLS certificate file (default &quot;/root/.docker/cert.pem&quot;) --tlskey string Path to TLS key file (default &quot;/root/.docker/key.pem&quot;) --tlsverify Use TLS and verify the remote -v, --version Print version information and quitManagement Commands: builder Manage builds config Manage Docker configs container Manage containers context Manage contexts engine Manage the docker engine image Manage images network Manage networks node Manage Swarm nodes plugin Manage plugins secret Manage Docker secrets service Manage services stack Manage Docker stacks swarm Manage Swarm system Manage Docker trust Manage trust on Docker images volume Manage volumesCommands: attach Attach local standard input, output, and error streams to a running container build Build an image from a Dockerfile commit Create a new image from a container&apos;s changes cp Copy files/folders between a container and the local filesystem create Create a new container diff Inspect changes to files or directories on a container&apos;s filesystem events Get real time events from the server exec Run a command in a running container export Export a container&apos;s filesystem as a tar archive history Show the history of an image images List images import Import the contents from a tarball to create a filesystem image info Display system-wide information inspect Return low-level information on Docker objects kill Kill one or more running containers load Load an image from a tar archive or STDIN login Log in to a Docker registry logout Log out from a Docker registry logs Fetch the logs of a container pause Pause all processes within one or more containers port List port mappings or a specific mapping for the container ps List containers pull Pull an image or a repository from a registry push Push an image or a repository to a registry rename Rename a container restart Restart one or more containers rm Remove one or more containers rmi Remove one or more images run Run a command in a new container save Save one or more images to a tar archive (streamed to STDOUT by default) search Search the Docker Hub for images start Start one or more stopped containers stats Display a live stream of container(s) resource usage statistics stop Stop one or more running containers tag Create a tag TARGET_IMAGE that refers to SOURCE_IMAGE top Display the running processes of a container unpause Unpause all processes within one or more containers update Update configuration of one or more containers version Show the Docker version information wait Block until one or more containers stop, then print their exit codes 指令解析-镜像部分镜像操作 指令：docker images [OPTIONS] [REPOSITORY[:TAG]]OPTIONNS -a：查看所有镜像（默认包含中间层的image） –digests：查看摘要 -f：显示满足条件的image –format：按指定的模板返回 -h：查看帮助文档 –no-trunc：显示完整的image信息 -q：仅显示image的ID列表 指令实现 指令：docker images -a1234567891011[root@maiyikai ~]# docker images -aREPOSITORY TAG IMAGE ID CREATED SIZEwurstmeister/kafka latest f1905dce9659 4 months ago 431MBredis 6.0.0 96812ab2b931 4 months ago 104MBrabbitmq latest c1a845de8052 4 months ago 151MBmysql 8.0.20 a7a67c95e831 4 months ago 541MBalpine latest f70734b6a266 4 months ago 5.61MBopenjdk 8u252-jdk 6cedfea72886 4 months ago 510MBcentos centos8 470671670cac 7 months ago 237MBnginx 1.16.0 ae893c58d83f 13 months ago 109MBwebcenter/activemq latest 3af156432993 3 years ago 422MB 指令：docker images -q123456789f1905dce965996812ab2b931c1a845de8052a7a67c95e831f70734b6a2666cedfea72886470671670cacae893c58d83f3af156432993 指令：docker images --digests12345678910REPOSITORY TAG DIGEST IMAGE ID CREATED SIZEwurstmeister/kafka latest sha256:a9980b591efe62a68de0acf5f5ce2f6fa7112ab07ec1099c976cdadc740c7ea4 f1905dce9659 4 months ago 431MBredis 6.0.0 sha256:9c2d321d367c582fc103ad36b7326a0edd5b558e0c987d0bea3b58bac008b20f 96812ab2b931 4 months ago 104MBrabbitmq latest sha256:ed12b6ac5b5bd92dca3a313db094c1687ad169f8e8d32ce0fa9cfdcc8d8948bc c1a845de8052 4 months ago 151MBmysql 8.0.20 sha256:61a2a33f4b8b4bc93b7b6b9e65e64044aaec594809f818aeffbff69a893d1944 a7a67c95e831 4 months ago 541MBalpine latest sha256:9a839e63dad54c3a6d1834e29692c8492d93f90c59c978c1ed79109ea4fb9a54 f70734b6a266 4 months ago 5.61MBopenjdk 8u252-jdk sha256:bedfb494645a0f9c48d333544986d5301df950e31f71e8861b5ba1601aedc587 6cedfea72886 4 months ago 510MBcentos centos8 sha256:fe8d824220415eed5477b63addf40fb06c3b049404242b31982106ac204f6700 470671670cac 7 months ago 237MBnginx 1.16.0 sha256:3e373fd5b8d41baeddc24be311c5c6929425c04cabf893b874ac09b72a798010 ae893c58d83f 13 months ago 109MBwebcenter/activemq latest sha256:35015988c4047a2ab1888466f5aae30420f7addde4c467e5db9ae64eea6b47b0 3af156432993 3 years ago 422MB 指令：docker images --no-trunc12345678910REPOSITORY TAG IMAGE ID CREATED SIZEwurstmeister/kafka latest sha256:f1905dce96591909cf3fcc7c329fb2a3e02bb1bf9258f75fe5c9cd58d0d629ab 4 months ago 431MBredis 6.0.0 sha256:96812ab2b9314569112fa58e7bef6641ff0a2b3cf7dace9ff8604a094f08228d 4 months ago 104MBrabbitmq latest sha256:c1a845de80526fcab136f9fab5f839e91b98c475d1a2f72165a3d04f03edf4c7 4 months ago 151MBmysql 8.0.20 sha256:a7a67c95e83189d60dd24cfeb13d9f235a95a7afd7749a7d09845f303fab239c 4 months ago 541MBalpine latest sha256:f70734b6a266dcb5f44c383274821207885b549b75c8e119404917a61335981a 4 months ago 5.61MBopenjdk 8u252-jdk sha256:6cedfea7288615050ac395405eb42cc2ad9a1cc02c7fd53324993f27e4447f94 4 months ago 510MBcentos centos8 sha256:470671670cac686c7cf0081e0b37da2e9f4f768ddc5f6a26102ccd1c6954c1ee 7 months ago 237MBnginx 1.16.0 sha256:ae893c58d83fe2bd391fbec97f5576c9a34fea55b4ee9daf15feb9620b14b226 13 months ago 109MBwebcenter/activemq latest sha256:3af15643299345851f234d4e66a41b1d64b751b6ace09a9a4b05d658fe5cd7c1 3 years ago 422MB 指令：docker images --format &quot;&amp;#123;&amp;#123;.ID&amp;#125;&amp;#125;:&amp;#123;&amp;#123;.Repository&amp;#125;&amp;#125;&quot;123456789f1905dce9659:wurstmeister/kafka96812ab2b931:redisc1a845de8052:rabbitmqa7a67c95e831:mysqlf70734b6a266:alpine6cedfea72886:openjdk470671670cac:centosae893c58d83f:nginx3af156432993:webcenter/activemq 指令：docker images --format &quot;table &amp;#123;&amp;#123;.ID&amp;#125;&amp;#125;\\t&amp;#123;&amp;#123;.Repository&amp;#125;&amp;#125;\\t&amp;#123;&amp;#123;.Tag&amp;#125;&amp;#125;&quot;12345678910IMAGE ID REPOSITORY TAGf1905dce9659 wurstmeister/kafka latest96812ab2b931 redis 6.0.0c1a845de8052 rabbitmq latesta7a67c95e831 mysql 8.0.20f70734b6a266 alpine latest6cedfea72886 openjdk 8u252-jdk470671670cac centos centos8ae893c58d83f nginx 1.16.03af156432993 webcenter/activemq latest 查看镜像 指令：docker search [OPTIONS] TERM：从hub.docker仓库搜索指定的镜像OPTIONS –no-trunc：显示完整镜像信息 -s：查询STARS大于指定数量的镜像 –limit：显示指定数量的镜像信息 –automated：显示automated类型的镜像 指令实现 指令：docker search mysql --no-trunc1234567NAME DESCRIPTION STARS OFFICIAL AUTOMATEDmysql MySQL is a widely used, open-source relational database management system (RDBMS). 9942 [OK] mariadb MariaDB is a community-developed fork of MySQL intended to remain free under the GNU GPL. 3636 [OK] mysql/mysql-server Optimized MySQL Server Docker images. Created, maintained and supported by the MySQL team at Oracle 724 [OK]percona Percona Server is a fork of the MySQL relational database management system created by Percona. 508 [OK] centos/mysql-57-centos7 MySQL 5.7 SQL database server 83 mysql/mysql-cluster Experimental MySQL Cluster Docker images. Created by the MySQL team at Oracle 75 指令：docker search mysql -s 900012NAME DESCRIPTION STARS OFFICIAL AUTOMATEDmysql MySQL is a widely used, open-source relation… 9942 [OK] 指令：docker search mysql --limit 2123NAME DESCRIPTION STARS OFFICIAL AUTOMATEDmysql MySQL is a widely used, open-source relation… 9942 [OK] mysql/mysql-server Optimized MySQL Server Docker images. Create… 724 [OK] 指令：docker search mysql --automated12345678910NAME DESCRIPTION STARS OFFICIAL AUTOMATEDmysql/mysql-server Optimized MySQL Server Docker images. Create… 724 [OK]centurylink/mysql Image containing mysql. Optimized to be link… 61 [OK]bitnami/mysql Bitnami MySQL Docker Image 44 [OK]deitch/mysql-backup REPLACED! Please use http://hub.docker.com/r… 41 [OK]prom/mysqld-exporter 31 [OK]schickling/mysql-backup-s3 Backup MySQL to S3 (supports periodic backup… 30 [OK]arey/mysql-client Run a MySQL client from a docker container 14 [OK]fradelg/mysql-cron-backup MySQL/MariaDB database backup using cron tas… 8 [OK]ansibleplaybookbundle/mysql-apb An APB which deploys RHSCL MySQL 2 [OK] 拉取镜像 指令：docker pull NAME[:TAG]:如果没有TAG则拉取latest版本的镜像 镜像删除 指令：docker rmi [OPTIONS] IMAGE [IMAGE...]：删除指定的镜像文件指令：docker rmi -f ${docker images -qa}OPTIONS -f：强制删除 指令解析-容器部分容器操作-创建容器 指令：docker run [OPTIONS] image [COMMAND] [ARGS...]OPTIONS –name=”Name”：指定容器名称 -d：后台运行容器，并返回容器ID，即启动守护式容器 -i：以交互模式运行容器，通常与-t同时使用 -t：为容器重新分配一个伪输入终端，通常与-i同时使用 -P：随机端口映射 -p：指定端口，有四种模式 ip:hostPort:containerPort ip:cantainerPort hostPort:containerPort cantainerPort 查询容器 指令：docker ps [OPTIONS]：查看正在运行的docker容器OPTIONS -a：查看所有正在运行的docker容器+历史运行的docker容器 –format：按指定格式查看 -n：查看指定数量的最近运行的docker容器 -l：显示最近创建的docker容器 -q：静默模式，只显示容器编号 -s：显示容器大小 –no-trunc：显示容器完整信息 启动容器 指令：docker start Name|ID 关闭容器 指令：docker restart Name|ID 强制关闭 指令：docker kill Name|ID 重启容器 指令：docker restart Name|ID 进入容器 指令：docker attach Name|ID指令：docker exec -it Name|ID指令：docker exec -t Name|ID [ls -l]：不进入容器，但让容器执行指令 退出容器 指令：exit：退出并关闭容器快捷键：Ctrl+Q+P，退出容器，但不关闭容器 删除容器 指令：docker rm -f Name|ID指令：docker rm -f ${docker ps -qa}:删除所有 查看容器日志 指令：docker logs [OPTIONS] Name|IDOPTIONS -t：显示日志时间戳 -f：显示最新的日志 –tail：显示最后指定行数的日志 查看容器内部运行的进程 指令：docker top Name|ID 查看容器内部细节 指令：docker inspect Name|ID Docker容器文件拷贝到宿主机 指令：docker cp Name|ID:容器内部路径 宿主机路径 通过容器创建镜像通过对原有容器的改造，优化为自己的容器，并将容器打包为一个镜像 指令：docker commit -m=&quot;提交的描述信息&quot; -a=&quot;作者&quot; NewName[:TAG] Docker容器与宿主机文件共享 指令：docker run -it -v 宿主机绝对路径（目录）:容器绝对路径（目录） imageNmae Docker容器与宿主机文件共享(设置只读权限) 指令：docker run -it -v 宿主机绝对路径（目录）:容器绝对路径（目录）:ro imageNmae 不同镜像的继承，数据共享不同镜像之间的继承，共享文件系统，对某一个容器内的文件进行操作，都将会进行同步。但如果删除其中的某一个容器，不会影响其他容器的文件123docker run -it --name=&quot;docker1&quot; imageNamedocker run -it --name=&quot;docker2&quot; --volume-from=&quot;docker1&quot; imageNamedocker run -it --name=&quot;docker3&quot; --volume-from=&quot;docker1&quot; imageName 总结对于容器的操作有很多，这边只是对个别操作进行展示。多练，多记…","categories":[{"name":"Docker","slug":"Docker","permalink":"https://maiyikai.github.io/categories/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://maiyikai.github.io/tags/Docker/"},{"name":"Linux","slug":"Linux","permalink":"https://maiyikai.github.io/tags/Linux/"}]},{"title":"SpringBoot 之更改 Tomcat 的 URL 校验规则","slug":"1582786564","date":"2020-02-27T14:57:00.000Z","updated":"2020-04-07T14:29:23.272Z","comments":true,"path":"2020/02/27/1582786564/","link":"","permalink":"https://maiyikai.github.io/2020/02/27/1582786564/","excerpt":"Spring Boot 项目中都会嵌入 Tomcat， 在不同版本的 Spring Boot 下，也会嵌入不同版本的 Tomcat 。Tomcat 作用和用途这里就不用再赘述了……","text":"Spring Boot 项目中都会嵌入 Tomcat， 在不同版本的 Spring Boot 下，也会嵌入不同版本的 Tomcat 。Tomcat 作用和用途这里就不用再赘述了……在项目的迁移过程中，由原先的 Servlet 项目 改造成了 Sprong Boot 项目，导致了一系列的问题，目前让我觉得可以记录的就是当前的这个 Tomcat 的问题了。因为在正常情况下不会涉及到这种问题，但是进行服务版本改造的时候应该会出现类似的问题。 抛转引玉访问地址：http://addression/ServerName/Web.jsp?json={&quot;balibali&quot;...}访问后端时报错： Invalid character found in the request target. The valid characters are defined in RFC 7230 and RFC 3986浏览器返回的结果是：400一开始，还不知道是什么原因，因为我用 PostMan 访问是正常的，但是用浏览器就出问题。Servlet 服务中是可以正常访问的，但是在 SpringBoot 项目中就不行了。于是乎开始针对这个这个问题排查，奇怪的是这个异常信息在多次访问的之后，只打印一次，一开始还不重视它，但是整个日志就没有其他的异常信息 网络搜寻一直找不到原因，于是就尝试使用这个异常去查，结果知道了原因：说是因为 Tomcat 对 URL 字符作了限制，而我地址中就存在了这些被限制的字符，于是乎对访问地址进行多次测试： http://addression/ServerName/Web.jsp –&gt; 没有报错 http://addression/ServerName/Web.jsp?json=balabala...---&gt; 没有报错 http://addression/ServerName/Web.jsp?json={}--&gt; 400 http://addression/ServerName/Web.jsp?json=%7B %7D–&gt; 正常(%7B %7D分别对应的是字符 { } ) 综上可知，是参数 json 赋值为一个对象时报错误，但是步骤 3 和 步骤 4 在某种意义上是一样的，因为在浏览器地址栏输入步骤 4 ，回车之后你看到的就是步骤 3 的地址…但是步骤 4 是正常的，步骤 3 是错的… 百度与谷歌知道了是 Tomcat 对 URL 的字符限制，就想先试试更改一下 Tomcat 的配置，网上找了一堆的教程 Tomcat 系列 更改 Tomcat 版本 配置tomcat支持|{}等字符的方法是:在 catalina.properties中添加 tomcat.util.http.parser.HttpParser.requestTargetAllow=|{} 但是只支持7.0.76, 8.0.42, 8.5.12 之后的版本 看到了这个答案，感觉有戏，结果才想起来， SpringBoot 项目中的 Tomcat 是内嵌的啊，难不成要重新引入一个？未免太过麻烦，而且后期还不好维护…等等一堆问题，怎么办呢？应该还有 Spring Boot 解决方案，再找找… SpringBoot 系列因为是公司项目，所以选用的 SpringBoot 版本一般不会改变，这里使用是 1.5.6 版本的。 SpringBoot 2.* 版本解决方案-工厂配置（未验证） 1234567//引入这个配置@Bean public ConfigurableServletWebServerFactory webServerFactory() &#123; TomcatServletWebServerFactory factory = new TomcatServletWebServerFactory(); factory.addConnectorCustomizers((TomcatConnectorCustomizer) connector -&gt; connector.setProperty(&quot;relaxedQueryChars&quot;, &quot;|&#123;&#125;[]\\\\&quot;)); return factory; &#125; SpringBoot 1.* 版本解决方案-工厂配置（未生效） 1234567891011121314151617/** * 解决异常信息： * java.lang.IllegalArgumentException: * Invalid character found in the request target. The valid characters are defined in RFC 7230 and RFC 3986 * @return */ @Bean public EmbeddedServletContainerCustomizer webServerFactory() &#123; TomcatServletWebServerFactory factory = new TomcatServletWebServerFactory(); factory.addConnectorCustomizers(new TomcatConnectorCustomizer() &#123; @Override public void customize(Connector connector) &#123; connector.setProperty(&quot;relaxedQueryChars&quot;, &quot;|&#123;&#125;[]&quot;); &#125; &#125;); return factory; &#125; SpringBoot 1.* 版本解决方案-工厂配置（已有的配置–未生效) 1234567891011121314151617@Componentpublic class PortalTomcatWebServerCustomizer implements EmbeddedServletContainerCustomizer &#123;@Overridepublic void customize(ConfigurableEmbeddedServletContainer container) &#123; if(container instanceof TomcatEmbeddedServletContainerFactory) &#123; TomcatEmbeddedServletContainerFactory containerFactory = (TomcatEmbeddedServletContainerFactory) container; containerFactory.addConnectorCustomizers(new TomcatConnectorCustomizer() &#123; @Override public void customize(Connector connector) &#123; connector.setAttribute(&quot;relaxedQueryChars&quot;, &quot;[]|&#123;&#125;:,^&amp;#x5c;&amp;#x60;&amp;quot;&amp;lt;&amp;gt;&quot;); connector.setAttribute(&quot;relaxedPathChars&quot;, &quot;[]|:,&quot;); &#125; &#125;); &#125; &#125;&#125; SpringBoot 1.* 版本解决方案-属性配置（生效） 12345678910@Configurationpublic class RfcConfig &#123; @Bean public Integer setRfc() &#123; // 指定jre系统属性，允许特殊符号， 如&#123;&#125; 做入参，其他符号按需添加。见 tomcat的HttpParser源码。 System.setProperty(&quot;tomcat.util.http.parser.HttpParser.requestTargetAllow&quot;, &quot;|&#123;&#125;&quot;); return 0; &#125;&#125; 根据查询结果尝试，在当前项目中只有第 4 个方案是有用的… 总结根据网络查询的结果不一定是可行的，需要多次查找，多次尝试，才能知道哪些是可行的。针对于技术型问题，谷歌查询的比较精准","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://maiyikai.github.io/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://maiyikai.github.io/tags/SpringBoot/"},{"name":"Spring","slug":"Spring","permalink":"https://maiyikai.github.io/tags/Spring/"},{"name":"Tomcat","slug":"Tomcat","permalink":"https://maiyikai.github.io/tags/Tomcat/"}]},{"title":"SpringBoot 之 @Scheduled 定时器规则","slug":"1577427502","date":"2019-12-27T14:15:00.000Z","updated":"2020-04-07T14:29:23.271Z","comments":true,"path":"2019/12/27/1577427502/","link":"","permalink":"https://maiyikai.github.io/2019/12/27/1577427502/","excerpt":"项目中，或多或少都会使用到定时器，定时执行某些特殊得功能。而在 SpringBoot 项目中，使用得定时器功能就是使用 @Scheduled 注解。","text":"项目中，或多或少都会使用到定时器，定时执行某些特殊得功能。而在 SpringBoot 项目中，使用得定时器功能就是使用 @Scheduled 注解。当然，定时器功能打开了，但是没有定时，这是不可行的。所以，在定时器使用中，使用 Cron 表达式作为定时器规则，在 @Scheduled 注解源码中可以看到，除了 cron 属性之外还有多个功能不一的属性。 Cron 表达式解释入口这里主要简述的是 Cron 表达式，在版本 1.5.6 版本的 SpringBoot 工程中，解析 Cron 表达式的源码如下（源码地址：org.springframework.scheduling.support.CronTrigger）：123456789101112131415161718private void parse(String expression) throws IllegalArgumentException &#123; String[] fields = StringUtils.tokenizeToStringArray(expression, &quot; &quot;); if (fields.length != 6) &#123; throw new IllegalArgumentException(String.format( &quot;Cron expression must consist of 6 fields (found %d in \\&quot;%s\\&quot;)&quot;, fields.length, expression)); &#125; setNumberHits(this.seconds, fields[0], 0, 60); setNumberHits(this.minutes, fields[1], 0, 60); setNumberHits(this.hours, fields[2], 0, 24); setDaysOfMonth(this.daysOfMonth, fields[3]); setMonths(this.months, fields[4]); setDays(this.daysOfWeek, replaceOrdinals(fields[5], &quot;SUN,MON,TUE,WED,THU,FRI,SAT&quot;), 8); if (this.daysOfWeek.get(7)) &#123; // Sunday can be represented as 0 or 7 this.daysOfWeek.set(0); this.daysOfWeek.clear(7); &#125;&#125; 从以上源码看出，当前版本的 SpringBoot 中，针对于 @Scheduled 的 Cron 表达式，只支持 6 位规则，而在网上有资料表示可以存在 7 位。 但是源码中，限制了只能有 6 位，否则抛出异常。 Cron 表达是对应的内容为： seconds minutes hours daysOfMonth months daysOfWeek 。 域的解释及源码针对不同属性解释： seconds：秒数；最小值为 0 ; 最大值为 60。 minutes：分钟；最小值为 0 ; 最大值为 60。 hours：小时；最小值为 0 ; 最大值为 23。 daysOfMonth：月中的某一天。 months：月份，这里使用的值为：FOO,JAN,FEB,MAR,APR,MAY,JUN,JUL,AUG,SEP,OCT,NOV,DEC 其中一个，且必须全部大写。 daysOfWeek：一周中的某一天，这里使用的值为：SUN,MON,TUE,WED,THU,FRI,SAT 其中一个，且必须全部大写。 在解释这个规则时，都是用了相同的两个方法，源码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859private void setNumberHits(BitSet bits, String value, int min, int max) &#123; String[] fields = StringUtils.delimitedListToStringArray(value, &quot;,&quot;); for (String field : fields) &#123; if (!field.contains(&quot;/&quot;)) &#123; // Not an incrementer so it must be a range (possibly empty) int[] range = getRange(field, min, max); bits.set(range[0], range[1] + 1); &#125; else &#123; String[] split = StringUtils.delimitedListToStringArray(field, &quot;/&quot;); if (split.length &gt; 2) &#123; throw new IllegalArgumentException(&quot;Incrementer has more than two fields: &apos;&quot; + field + &quot;&apos; in expression \\&quot;&quot; + this.expression + &quot;\\&quot;&quot;); &#125; int[] range = getRange(split[0], min, max); if (!split[0].contains(&quot;-&quot;)) &#123; range[1] = max - 1; &#125; int delta = Integer.valueOf(split[1]); if (delta &lt;= 0) &#123; throw new IllegalArgumentException(&quot;Incrementer delta must be 1 or higher: &apos;&quot; + field + &quot;&apos; in expression \\&quot;&quot; + this.expression + &quot;\\&quot;&quot;); &#125; for (int i = range[0]; i &lt;= range[1]; i += delta) &#123; bits.set(i); &#125; &#125; &#125;&#125;private int[] getRange(String field, int min, int max) &#123; int[] result = new int[2]; if (field.contains(&quot;*&quot;)) &#123; result[0] = min; result[1] = max - 1; return result; &#125; if (!field.contains(&quot;-&quot;)) &#123; result[0] = result[1] = Integer.valueOf(field); &#125; else &#123; String[] split = StringUtils.delimitedListToStringArray(field, &quot;-&quot;); if (split.length &gt; 2) &#123; throw new IllegalArgumentException(&quot;Range has more than two fields: &apos;&quot; + field + &quot;&apos; in expression \\&quot;&quot; + this.expression + &quot;\\&quot;&quot;); &#125; result[0] = Integer.valueOf(split[0]); result[1] = Integer.valueOf(split[1]); &#125; if (result[0] &gt;= max || result[1] &gt;= max) &#123; throw new IllegalArgumentException(&quot;Range exceeds maximum (&quot; + max + &quot;): &apos;&quot; + field + &quot;&apos; in expression \\&quot;&quot; + this.expression + &quot;\\&quot;&quot;); &#125; if (result[0] &lt; min || result[1] &lt; min) &#123; throw new IllegalArgumentException(&quot;Range less than minimum (&quot; + min + &quot;): &apos;&quot; + field + &quot;&apos; in expression \\&quot;&quot; + this.expression + &quot;\\&quot;&quot;); &#125; return result;&#125; 特殊字符解释及例子每个域都使用数字，或者使用连接符连接，含义： , ：连接符，表示列出枚举值。如在 minutes 域使用 2,15 ，表示 2 分和 15 分执行一次。 - ：连接符，表示范围。如在 minutes 域使用 2-15 ，表示从 2 分到 15 分，每分钟执行一次。 / ：连接符，表示值增加的幅度，如 n/m ，表示从第 n 秒开始，每隔 m 秒执执行一次，5/15 –&gt;&gt; 5, 20, 35, 50 * ：表示匹配该域的任意值，如在 minutes 域使用，表示每分钟都会触发一次 ? ：表示匹配该域的任意值，但只有 daysOfMonth 和 daysOfWeek 域才能使用，因为 daysOfMonth 和 daysOfWeek 域会相互影响，所以两个域不能同时使用 ? 。 注：在源码中未使用到的特殊符号有 L (表最后)、 W (表有效工作日)、 LW (表最后某月最后一个工作日)、 # (表用于确定每个月第几个星期几) 一些常用的例子，这里用表格展示： 规则 解释 0 0 10,14,16 * * ? 每天上午10点，下午2点，4点 0 0/30 9-17 * * ? 朝九晚五工作时间内每半小时 0 0 12 ? * WED 表示每个星期三中午12点 0 0 12 * * ? 每天中午12点触发 0 15 10 ? * * 每天上午10:15触发 0 15 10 * * ? 每天上午10:15触发 0 * 14 * * ? 在每天下午2点到下午2:59期间的每1分钟触发 0 0/5 14 * * ? 在每天下午2点到下午2:55期间的每5分钟触发 0 0/5 14,18 * * ? 在每天下午2点到2:55期间和下午6点到6:55期间的每5分钟触发 0 0-5 14 * * ? 在每天下午2点到下午2:05期间的每1分钟触发 0 10,44 14 ? 3 WED 每年三月的星期三的下午2:10和2:44触发 0 15 10 ? * MON-FRI 周一至周五的上午10:15触发 0 15 10 15 * ? 每月15日上午10:15触发 总结文章所述与网上资料有所不同，需要根据源码判断，是否正确使用。根据目前 SpringBoot 版本 1.5.6 来看，对于 Cron 表达式的使用相对简单。 参考资料 spring cron表达式(定时器) Spring 定时器的时间设置规则","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://maiyikai.github.io/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://maiyikai.github.io/tags/SpringBoot/"},{"name":"Spring","slug":"Spring","permalink":"https://maiyikai.github.io/tags/Spring/"},{"name":"Scheduled","slug":"Scheduled","permalink":"https://maiyikai.github.io/tags/Scheduled/"}]},{"title":"Schema 与数据类型优化-选择优化的数据类型","slug":"1574147663","date":"2019-11-19T15:15:00.000Z","updated":"2019-11-30T15:56:05.951Z","comments":true,"path":"2019/11/19/1574147663/","link":"","permalink":"https://maiyikai.github.io/2019/11/19/1574147663/","excerpt":"数据库的设计，决定后期对数据库的操作，和性能的优化难度；数据库结构设计不合理，那后期开发对数据库的操作和优化难度更高。但也不是说，数据库结构设计好了之后，后期就不再进行优化了；正如 MySQL 的版本一般，每次的更新都会带有一些新的变化，也会对某些过去版本出现的问题进行优化。","text":"数据库的设计，决定后期对数据库的操作，和性能的优化难度；数据库结构设计不合理，那后期开发对数据库的操作和优化难度更高。但也不是说，数据库结构设计好了之后，后期就不再进行优化了；正如 MySQL 的版本一般，每次的更新都会带有一些新的变化，也会对某些过去版本出现的问题进行优化。这篇文章最主要讲述的是对 MySQL 数据库数据结构中的数据类型的选择。主要参考来源为 《高性能 MySQL》 这本书 第 4 章 数据类型MySQL 是一个关系型数据库管理系统，定义的每一个列都需要一个数据类型，可以理解为类似 Java 定义变量一般，都需要指定类型。我们一起来看看 MySQL 都有哪些数据类型(表格数据来自网络)： 类型 大小 范围（有符号） 范围（无符号） 用途 TINYINT 1 字节 (-128，127) (0，255) 小整数值 SMALLINT 2 字节 (-32 768，32 767) (0，65 535) 大整数值 MEDIUMINT 3 字节 (-8 388 608，8 388 607) (0，16 777 215) 大整数值 INT或INTEGER 4 字节 (-2 147 483 648，2 147 483 647) (0，4 294 967 295) 大整数值 BIGINT 8 字节 (-9,223,372,036,854,775,808，9 223 372 036 854 775 807) (0，18 446 744 073 709 551 615) 极大整数值 FLOAT 4 字节 (-3.402 823 466 E+38，-1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38) 0，(1.175 494 351 E-38，3.402 823 466 E+38) 单精度浮点数值 DOUBLE 8 字节 (-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308) 0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308) 双精度浮点数值 DECIMAL 对DECIMAL(M,D) ，如果M&gt;D，为M+2否则为D+2 依赖于M和D的值 依赖于M和D的值 小数值 DATE 3 1000-01-01/9999-12-31 YYYY-MM-DD 日期值 TIME 3 ‘-838&#58;59&#58;59’/‘838&#58;59&#58;59’ HH&#58;MM&#58;SS 时间值或持续时间 YEAR 1 1901/2155 YYYY 年份值 DATETIME 8 1000-01-01 00&#58;00&#58;00/9999-12-31 23&#58;59&#58;59 YYYY-MM-DD HH&#58;MM&#58;SS 混合日期和时间值 TIMESTAMP 4 1970-01-01 00&#58;00&#58;00/2038 结束时间是第 2147483647 秒，北京时间 2038-1-19 11&#58;14&#58;07，格林尼治时间 2038年1月19日 凌晨 03&#58;14&#58;07 YYYYMMDD HHMMSS 混合日期和时间值，时间戳 CHAR 0-255字节 — — 定长字符串 VARCHAR 0-65535 字节 — — 变长字符串 TINYBLOB 0-255字节 — — 不超过 255 个字符的二进制字符串 TINYTEXT 0-255字节 — — 短文本字符串 BLOB 0-65 535字节 — — 二进制形式的长文本数据 TEXT 0-65 535字节 — — 长文本数据 MEDIUMBLOB 0-16 777 215字节 — — 二进制形式的中等长度文本数据 MEDIUMTEXT 0-16 777 215字节 — — 中等长度文本数据 LONGBLOB 0-4 294 967 295字节 — — 二进制形式的极大文本数据 LONGTEXT 0-4 294 967 295字节 — — 极大文本数据 数据类型的选择MySQL 支持的数据类型有非常多，选择正确的数据类型对于获得高性能至关重要。那么应该如何选择数据类型呢？以下是列举几个比较简单的选择原则： 更小的通常更好 一般情况下尽量使用可以正确存储数据的最小数据类型。 更小的数据类型占用更少的磁盘、内存和 CPU 缓存，并且处理时需要的 CPU 周期更小 简单就好 简单的数据类型的操作通常需要更少的 CPU 周期 尽量避免 NULL 如果查询中包含可为 NULL 的列，会使得索引、索引统计和值变得更复杂 可为 NULL 的列会使用更多的存储空间，在 MySQL 里也要特殊处理 可为 NULL 的列被索引时，每个索引记录需要一个额外的字节，在 MyISAM(存储引擎) 里甚至还可能导致固定大小的索引变成可变大小的索引 很多 MySQL 的数据类型可以存储相同的类型的数据，只是存储的长度和范围不一样、允许的精度不同，或者需要的物理空间（磁盘和内存空间）不同。相同大类型的不同子类型数据有时也有一些特殊的行为和属性。 整数类型根据上表，整数类型为：TINYINT,SMALLINT,MEDIUMINT,INT,BIGINT；分别使用 1 、 2 、 3 、 4、 8 个字节，分别使用 8 , 16 , 24 , 32 , 64 为存储空间。 它们的存储的值的范围从 -2( N - 1 ) 到 2( N - 1 ) - 1 ,其中 N 为存储空间的位数。 整型数值的定义可以使用 UNSIGNED 无符号整型属性，这大致可以使正数的上限提高一倍。 有符号和无符号类型使用相同的存储空间，并具有相同的性能，因此可以根据实际情况选择合适的类型。 MySQL 可以为整型类型指定宽度，如 INT(1) ,对大多数应用这是没有意义的：它不会限制值的合法范围，只是规定了 MYSQL 的一些交互工具用来显示字符的个数。对于存储和计算来说，INT(1) 和 INT(10) 是相同的。 实数类型 实数是带有小数部分的数字，类型为 FLOAT , DOUBLE , DECIMAL ; 它们不只是为了存储小数部分；也可以使用 DECIMAL 存储比 BIGINT 还大的整数。 MySQL 既支持精确类型，也支持不精确类型。 有多种方法可以指定浮点列所需要的精度，这会使得 MySQL 选择不同的数据类型，或者在存储时进行取舍。这些精度定义是非标准的，所以建议只指定数据类型，而不制定精度。 DECIMAL 类型最多允许 65 个数字；因为 DECIMAL 只是一种存储格式，在计算中 DECIMAL 会转换为 DOUBLE 类型。 MySQL 使用 DOUBLE 为内部浮点计算类型。 字符串类型MySQL 支持多种字符串类型，每种类型还有很多的变种。每个字符串列可以定义自己的字符集和排序规则，或者说是校对规则。这些东西会很大程度上影响性能。 VARCHAR 和 CHAR 类型 VARCHAR VARCHAR 类型用于存储可变长字符串，是最常见的字符串数据类型。它比定长类型更节省空间，因为它仅使用必要的空间。 VARCHAR 需要使用 1 或者 2 个额外字节记录字符串的长度。 VARCHAR 节省了存储空间，对性能提升有所帮助。但由于行是变长的，在 UPDATE 时可能使行变得比原来的长，这就导致需要做额外的工作。（如果一个行占用的空间增长，并且页内没有更多的空间可以存储的情况下，不同的引擎处理方式是不一样的——需参考存储引擎的工作原理） CHAR CAHR 类型是定长的，MySQL 根据定义的长度分配足够的空间 存储值时，MySQL 会将末尾的所有空格删除 注：更长的列列会消耗更多的内存，因为 MySQL 通常会分配固定大小的内存块来保存内部值。 BLOB 和 TEXT 类型大型数据存储类型：BLOB 和 TEXT ，分别采用二进制和字符方式存储。 MySQL 把每个 BLOB 和 TEXT 值当作一个独立的对象处理，存储引擎在存储时通常会做特殊的处理。当 BLOB 和 TEXT 值太大时， InnoDB 会使用专门的“外部”存储区域进行存储，此时每个值在行内需要 1~4 个字节的指针，外部存储区域存储的值。 BLOB 和 TEXT 不同的是： BLOB 类型存储的值时二进制数据，没有排序规则或字符集 TEXT 类型有排序规则和字符集 MySQL 对 BLOB 和 TEXT 列进行排序与其他的类型不同，MySQL 只对最前 max_sort_length 字节而不是整个字符串进行排序，可通过 ORDER BY SUSSTRING(column, length) 注：MySQL 不能将 BLOB 和 TEXT 列全部长度的字符串进行索引，也不能使用这些索引消除排序。 使用枚举代替字符串类型枚举列看可以将一些不重复的字符串存储成一个预定义的集合。 MySQL 在存储枚举时非常的紧凑，会根据列表值的数量压缩到一个或者两个字节中。 MySQL 在内部会将每个值在列表中的位置保存为整数，并且在表的 .frm 文件中保存“数字-字符串”映射关系的“查找表”。 使用枚举列会使得数据库表大小减小。 注：枚举字符串列表是固定的，故添加或删除字符串必须使用 ALTER TABLE。所以对于经常变换的字符串列表，不该使用枚举类型。枚举列与字符串 CHAR/VARCHAR 列关联会比使用两个枚举列关联速度要慢 日期和时间类型MySQL 能够存储的最小时间粒度为秒（MariaDB支持微秒级别的事件类型）。 MySQL 提供两种时间类型： DATETIME 保存大范围的值，从 1001 年到 9999 年，精度为秒。 时间日期封装格式为 YYYYMMDDHHMMSS 的整数 与时区无关 存储空间为 8 个字节 TIMESTAMP 保存从 1970 年 1 月 1 日午夜（格林尼治标准时间）以来的秒数，它和 UNIX 时间戳相同。 存储空间为 4 个字节 保存范围为 1970 年到 2038 年 与时区有关 比 DATETIME 空间效率更高 位数据类型MySQL 提供两种位数据类型： BIT 可以使用 BIT 列在一列中存储一个或者多个 true | false 值 最大长度为 64 个位 MySQL 将 BIT 当成是字符串类型，而不是数字类型 存储的值为二进制字串 SET 在 MySQL 内部是以一系列打包的位的集合来表示 缺点 改变列的代价较高，需要 ALTER TABLE； 无法在 SET 列上使用索引 选择标识符标识列可能在另外的表中作为外键使用，所以为标识列选择数据类型是，应该选择跟关联表中的对应列一样的类型。 选择标识列的类型时，要考虑存储类型，还要考虑 MySQL 对这种类型怎么执行计算和比较。 在可以满足值的范围的需求，并且预留未来增长空间的前提下，应该选择最小的数据类型。 注：一旦选定了一种类型，要确保在所有关联表中都使用同样的类型。类型之间需要精确的匹配，包括像 UNSIGNED 这样的属性。混用不同的数据类型可能导致性能问题，即使没有性能问题，在比较操作时隐式类型转换可能导致很难发现的错误。 整型类型 整数通常是标识列的最好的选择，因为它们很快并且可以使用 AUTO_INCREMENT ENUM 和 SET 类型 因为 ENUM 和 SET 类型定义值是比较固定的，并且修改的花销很大，所以对于标识列来说，这是一个不推荐的选择 字符串类型 字符串类型占用空间，并且比数字类型要慢得多 对于完全“随机”的字符串，如 MD5()、SHA1() 或者 UUID() 产生的字符串，这些函数生成的新值会任意分布在很大的空间内，这回导致 INSERT 以及 SELECT 语句变得很慢 因为插入值会随机地写索引在不同的位置，所以使得 INSERT 语句更慢。这回导致页分裂、磁盘随机访问，以及对于聚簇存储引擎产生聚簇索引碎片 SELECT 语句变得更慢，因为逻辑上相邻的行会分布在磁盘和内存的不同地方 随机值导致混村对所有类型的查询语句效果都很差，因为会使得缓存赖以工作的范文局部性原理失效。如果整个数据集都一样的“热”，那么缓存任何一部分特地给数据到内存都没有好处；如果工作集比内存大，缓存将会有很多刷新和不命中。 总结数据库表的设计需要根据需求选择合适的数据类型，避免不同的数据类型间相互影响，导致影响数据库的性能。 尽量避免使用在对列进行数据变更时对整张表的修改的数据类型 尽量使用占用空间较小且适合的数据类型 尽量避免数据可为 NULL 在进行表关联时，尽量使关联的列使用同一种数据类型，避免不必要的转换开销","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://maiyikai.github.io/categories/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://maiyikai.github.io/tags/MySQL/"},{"name":"Database","slug":"Database","permalink":"https://maiyikai.github.io/tags/Database/"},{"name":"MySQL DataType","slug":"MySQL-DataType","permalink":"https://maiyikai.github.io/tags/MySQL-DataType/"},{"name":"optimize","slug":"optimize","permalink":"https://maiyikai.github.io/tags/optimize/"}]},{"title":"MySQL 系列之 MySQL 架构和历史","slug":"1573376841","date":"2019-11-10T17:09:00.000Z","updated":"2019-11-30T16:00:10.444Z","comments":true,"path":"2019/11/11/1573376841/","link":"","permalink":"https://maiyikai.github.io/2019/11/11/1573376841/","excerpt":"","text":"MySQL 的逻辑结构先看看 MySQL 逻辑结构图吧MySQL 逻辑结构图 连接管理与安全性每个客户端连接都会在服务器进程中拥有一个线程，这个连接的查询只会在这个单独的线程中执行，该线程只能轮流在某个 CPU 核心或 CPU 中运行，服务器会负责缓存线程，因此不需要为每一个新建的连接创建或销毁线程 优化与执行 MySQL 会解析查询，并创建内部数据结构（解析树），然后对其进行各种优化、包括重写查询、决定表的读取顺序，以及选择合适的索引等。 优化器并不关心表使用的是什么存储引擎，但存储引擎对于优化查询是有影响的。 并发控制每种 MySQL 存储引擎都可以实现自己的锁策略和锁粒度。 读写锁 共享锁（shared lock），也称为读锁（read lock）。读锁是共享的，或者说是项目不阻塞的。多个客户在同一时刻可以同时读取同一个资源。 排他锁（exclusive lock），也称为写锁（write lock）。写锁则是排他的，一个写锁会阻塞其他的写锁和读锁。 锁粒度一种提高共享资源并发性的方式就是让锁定对象更有选择性。尽量修改部分数据，而不是所所有资源。更理想的方式是，只队会修改的数据片进行精确的锁定。任何时候在给定的资源上，锁定的数据量越少，则系统的并发程度更高，只要相互之间不发生冲突。 锁策略锁策略就是在开销和安全性之间寻求平衡 ，这种平衡会影响性能 表锁（table lock） 表锁是 MySQL 中最基本的锁策略，并且是开销最小的策略 行级锁（row lock） 行级锁可以最大程度地支持并发处理（同时也带来了最大的开销） 行级锁只在 MySQL 的存储引擎层实现 事务ACID 特性 原子性：一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有的操作要么全部提交成功，要么全部失败回滚 一致性：数据库总是从一个一致性的状态转换到另一个一致性的状态 隔离性：一个事务的操作对另一个事务时不可见的 持久性：事务一旦提交，所作的修改就会保存到数据库中 隔离级别每一种级别都规定了一个事务中所作的修改，哪些在事务内和事务间可见的，哪些时不可见的。较低级别的隔离通常可以执行更高的并发，系统的开销也更低。 可以通过 SQL 改变事务的隔离级别：SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;也可以更改配置文件，对整个数据库设置隔离级别。 四种隔离级别： READ UNCOMITTED（未提交读）：在 READ UNCOMMITTED 级别，事务中的修改，即使没有提交，对其他事务也都是可见的 READ COMMITTED（提交读）：一个事务开始之前只能获取已提交事务的所做更改（事务对其他事务不可见） REPEATABLE READ（可重复读）：保证了在同一个事务中多次读取同样的记录的结果是一只的。但是理论上，可重复读隔离界别还是无法解决另外一个幻读的问题 幻读：指的是当某个事务在读取某个范围的内数的记录时，另外一个事务又在该范围内插入了新的记录，当之前的事务再次读取该范围内的记录时，另外一个事务又在该范围内插入了新的记录 SERIALIZABLE（可串行化）：这种隔离级别是最高的；通过强制事务串行执行，避免了幻读的问题；SERIALIZABLE 会在读取的每一行数据上都加锁，所以可能导致大量的超时和锁争用的问题 死锁指的是两个或者多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环的现象 事务日志可以帮助提高事务的效率 MySQL 中的事务MySQL 提供两中事型的存储引擎： InnoDB 和 NDB Clister 自动提交（AUTOCOMMIT）：查询自动提交的命令：SHOW ARIABLES LIKE ‘AUTOCOMMIT’;设置 AUTOCOMMIT : SET AUTOCOMMIT=1;1 或者 ON 表示启用，0 或者 OFF 表示禁用。 MySQL 默认采用了自动提交模式 当 AUTOCOMMIT 被禁用时，需采用显式的方式进行提交（COMMIT）或者回滚（ROLLBACK） 显示和隐式锁定 显示锁定——在执行 SQL 时加入 LOCK TABLES 或者UNLOCK TABLES 进行锁定和释放（不推荐） 隐式锁定——在事务执行过程中，随时都可以执行锁定，锁只有在 COMMIT 或 ROLLBACK 时才会释放，并且在锁在同一时刻被释放 MVCC —— 多版本并发控制MVCC 是通过保存数据在某个时间点的快照来实现。在 InnoDB 存储引擎中，是通过在每行记录的后面保存两个隐藏的列来实现的。（这两个列分别存储了行的创建时间和行的过期时间（或删除时间），即为系统版本号）。 对隔离级别的支持 REPEATABLE READ SELECT：InnoDB 会根据两个条件检查每行记录，符合条件才能返回查询结果 INSERT：InnoDB 为新插入的记录板寸当前系统版本号作为行版本号 DELETE：InnoDB 为删除的记录保存当前系统版本号作为行删除标识 UPDATE：InnoDB 会插入的新纪录，保存当前系统版本号，同时保存当前系统版本号到原来的行作为删除标识 READ COMMITTED 不支持的给级别 READ UNCOMMITTED：因为此隔离级别总是读取最新的数据行，而不符合当前事务版本的数据据行 SERIALIZABLE：因为此隔离级别会对读取行加锁 存储引擎在文件系统中，MySQL 将每个数据库保存为数据目录下的子目录；创建表时，MySQL 会在数据库的子目录下创建一个和表名一样的 .frm 文件保存表的定义。可以使用 SQL 查询表的信息 SHOW TABLE STATUS LIKE &#39;TABKENAME&#39; 。 MySQL 内置多种存储引擎，而这里只介绍两种：InnoDB 和 MyISAM InnoDB 存储引擎InnoDB 是 MySQL 的默认事务性存储引擎，也是最重要的，使用最广泛的存储引擎。它被设计用来处理大量的短息事务。 InnoDB 储存引擎是将数据存储在表空间中，表空间是由 InnoDB 管理的一个黑盒子，有一系列的数据文件组成。 InnoDB 采用了 MVCC 来支持高并发，并且实现四个标准的隔离级别，其默认的隔离级别是 REPEATABLE READ ，并且通过“间隙锁”策略防止出现幻读。 注：间隙锁使得 InnoDB 不仅仅锁定查询涉及的行，还会对索引中的间隙进行锁定，防止幻读的出现 MyISAM 存储引擎MyISAM 提供了大量的特性，包括全文引擎、压缩、空间函数等，但 MyISAM 不支持事务和行级锁，而且有一个毫无疑问的缺陷就是崩溃后无法保存数据的安全恢复。 在存储方面， MyISAM 会将表存储在两个文件中，分别为数据文件和索引文件（.MYD 和 .MYI） 特性 加锁与并发：对整张表加锁，而不是针对行。读取时会对需要读到的表加共享锁，写入时则对表加排他锁。但是在表有读取查询的同时，也可以往表中插入新的记录。 修复：对于 MyISAM 表，MySQL 可以手工或者自动执行检查和修复操作，这里修复和事务恢复以及崩溃时不同的概念。执行表的修复可能会导致一些数据丢失，而且修复操作时非常慢的。 索引特性：对与长字段类型 BLOB 和 TEXT 等，可以基于其前 500 个字符创建索引。也支持全文索引。 延迟更新索引键：创建 MyISAM 表时，如果指定了 DELAY_KEY_WRITE 选项，在每次修改执行完成时，不会立刻将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区，只有在清理键缓冲区或关闭表的时候才会将对应的索引写入磁盘。 压缩表——在创建表并导入数据之后，不会被修改，可以使用 myisampack 对 MyISAM 表进行压缩。因为不能被修改，如果一定要修改，则需要先解压，修改之后再压缩。压缩表可以极大的减少磁盘空间的占用，因此也可以减少磁盘 I/O ，从而提升查询性能。压缩表也支持索引，但索引只能是只读恶的。 MySQL 其他存储引擎除了上边描述的连个存储引擎外，MySQL 还支持： Archive 引擎 Blackhole 引擎 CSV 引擎 Memory 引擎 Merge 引擎 … … 这里不过多的赘述了……","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://maiyikai.github.io/categories/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://maiyikai.github.io/tags/MySQL/"},{"name":"数据库","slug":"数据库","permalink":"https://maiyikai.github.io/tags/数据库/"}]},{"title":"LoadRunner之脚本运行","slug":"1571380749","date":"2019-10-22T10:35:00.000Z","updated":"2019-11-25T14:16:35.244Z","comments":true,"path":"2019/10/22/1571380749/","link":"","permalink":"https://maiyikai.github.io/2019/10/22/1571380749/","excerpt":"上一篇文章我们已经讲了如何编写一个简单的 LoadRunner 脚本，也讲了如何调试和查看日志；当然这只是准备阶段哦，脚本在编写的时候能跑，但是在真实的性能测试阶段就不一定能跑了，总之问题是有的，要慢慢解决。不要问我为啥知道，因为我在使用的时候就遇到了很多的问题，就不一一的讲了，试试就知道了。","text":"上一篇文章我们已经讲了如何编写一个简单的 LoadRunner 脚本，也讲了如何调试和查看日志；当然这只是准备阶段哦，脚本在编写的时候能跑，但是在真实的性能测试阶段就不一定能跑了，总之问题是有的，要慢慢解决。不要问我为啥知道，因为我在使用的时候就遇到了很多的问题，就不一一的讲了，试试就知道了。 工具准备编写脚本的时候我们只需要准备 LoadRunner 这个软件就可以了，但是作为性能测试阶段的时候，就要使用负载机了，因为我们的脚本需要发送到负载机上面运行，所以某种程度来说，这个东西比较耗资源。还记得我们上一篇文章讲的日志打印的问题吗？就是会把系统磁盘写满。多实例并发的时候有可能负载机也会扛不住的，所以建议是安装到其他的机器上，并使用多台负载机共同工作，不要使用本机。对于负载机的安装可以参考：LoadRunner添加负载机和安装总结 脚本准备这篇文章使用的上一篇文章 LoadRunner之脚本写作 中的例子。这样我们的脚本就已经准备好了，那就开始吧运行吧… 运行负载测试负载测试设计脚本选择打开 LoadRunner ，选择“运行负载测试” 第一次运行负载测试使用“新建”，在小窗口选择“浏览”，然后选择我们编写的脚本目录；或者从小窗口左边选择对应的脚本，然后选择“添加”即可。 负载机管理选择负载机管理，添加负载机并连接 负载机连接成功 场景组选择相应的负载机 运行时设置指定负载机设置思考时间思考时间，即为每次访问前停滞时间，我们例子的脚本中有写，为 1s ，如果我们想要让它在一个范围 0.5 - 1.5s 之间浮动变化，那么可以这样设置…（还有其他的变化）。在“组场景”对指定的负载机右键，选择“运行时设置”，在弹出来的小窗口选择“思考时间”选项。 日志设置在“组场景”对指定的负载机右键，选择“运行时设置”，在弹出来的小窗口选择“日志”选项。选择“仅在错误时发送消息”、“标准日志”。切记，因为进行负载测试时，会产生很多的日志，如果每一条日志都要发送到负载机的话，负载机会被把磁盘写满，如果使用扩展日志，那会在标准的日志上 x 3~4 左右的一个存储量 运行参数设置设置执行计划，如果是多台负载机要一起运行的场景，在“场景组”区域内，选择更多的组–即脚本，选择多台负载机；在“场景计划”中，设置“计划方式”为“组”设置每台负载机的虚拟用户数、虚拟用户执行顺序及负载测试执行时间，可以根据“交互计划图”查看设置的情况 设置好之后，如果运行没问题，记得要将“负载测试”实例保存起来，下次使用直接可以打开使用，设置都不会发生改变。否则每次就只能是“新建”，而且要重新设置执行计划很麻烦的。 负载测试执行执行计划设计好了之后，就要开始运行测试了，选择左下角的“运行”，进入执行界面 假如前面我们都已经按照需求“设计”好了用户并发的情况，那么我们就可以直接执行了。场景组：点击“开始场景”进行脚本执行场景状态：查看事务运行状态可用图：查看事务各指标运行趋势，点击可用图的工作项，可以查看到当前工作项的指标数据 测试结果分析当场景执行结束之后，选择查看“结果分析”，对运行结果数据进行分析，这个数据要保存起来，对性能分析的时候要用到。进入入口结果分析 至此，运行负载测试的一个流程就结束了，应该是很详细了，有一些个性化设置就要看实际需求了，这边不一一叙述，否则该去 LoadRunner HP 公司去当产品经理去了。如遇有疑问或文章有问题，欢迎反馈… 参考文献1.LoadRunner之脚本写作2.LoadRunner添加负载机和安装总结","categories":[{"name":"LoadRunner","slug":"LoadRunner","permalink":"https://maiyikai.github.io/categories/LoadRunner/"}],"tags":[{"name":"LoadRunner","slug":"LoadRunner","permalink":"https://maiyikai.github.io/tags/LoadRunner/"},{"name":"Test","slug":"Test","permalink":"https://maiyikai.github.io/tags/Test/"},{"name":"script","slug":"script","permalink":"https://maiyikai.github.io/tags/script/"}]},{"title":"LoadRunner之脚本写作","slug":"1571380748","date":"2019-10-18T14:45:00.000Z","updated":"2019-11-25T14:16:35.243Z","comments":true,"path":"2019/10/18/1571380748/","link":"","permalink":"https://maiyikai.github.io/2019/10/18/1571380748/","excerpt":"LoadRunner，是一种预测系统行为和性能的负载测试工具。通过模拟上千万用户实施并发负载及实时性能监测的方式来确认和查找问题，LoadRunner能够对整个企业架构进行测试。企业使用LoadRunner能最大限度地缩短测试时间，优化性能和加速应用系统的发布周期。LoadRunner可适用于各种体系架构的自动负载测试，能预测系统行为并评估系统性能。","text":"LoadRunner，是一种预测系统行为和性能的负载测试工具。通过模拟上千万用户实施并发负载及实时性能监测的方式来确认和查找问题，LoadRunner能够对整个企业架构进行测试。企业使用LoadRunner能最大限度地缩短测试时间，优化性能和加速应用系统的发布周期。LoadRunner可适用于各种体系架构的自动负载测试，能预测系统行为并评估系统性能。LoadRunner 更多的了解可以查看百度百科，我觉得上面讲的很全面了。本篇文章是我近段时间使用 LoadRunner 对系统进行性能测试而写，因为时间有限，所能了解的东西也有限，所以能写的也就一点点，不多… 新建脚本新建脚本，一般来说，应该都是使用的 LoadRunner 程序的脚本录制功能，这个功能是可以自动生成脚本文件的，然后我们再改改应该就可以了。但是我这边有一些情况比较特殊，不能使用录制功能，所以只能是纯手写咯。既然是要写脚本，打开程序的操作肯定是必要的吧：LoadRunner应用程序-&gt;创建/编辑脚本-&gt;新建/打开脚本 创建/编辑脚本 新建/打开脚本 脚本类型（如果是新建脚本）–默认就行 选择取消即为不录制 函数接下来我们介绍一下使用了哪一些函数，函数简单，但是还是要记一下，以为要用的东西嘛，不记得就尴尬了… 函数列表这里列出我使用到的所有函数，都是 C 语言的函数哦：123456789101112int web_add_auto_header( const char *Header, const char *Content ); int web_set_max_html_param_len( const char *length );int web_reg_save_param_ex( const char *ParamName, [const char *LB, ][const char *RB,] &lt;List of Attributes&gt;, &lt;SEARCH FILTERS&gt;,LAST ); int web_reg_find( const char *attribute_list, LAST ); int lr_start_transaction( const char *transaction_name ); int web_custom_request( const char *RequestName, &lt;List of Attributes&gt;, [EXTRARES, &lt;List of Resource Attributes&gt;,] LAST ); char *lr_eval_string( const char *instring ); int atoi( const char *string ); int lr_output_message( const char *format, exp1, exp2,...expn.); int lr_end_transaction( const char *transaction_name, int status ) ; void lr_think_time( double thinkTime); int lr_message( const char *format, exp1, exp2,...expn.); 函数介绍上面就是使用到的简单的函数，下边来对他们一一介绍，建议看官方文档咯，在程序里边的帮助就有相应的文档可以查. web_add_auto_header: Adds the specified header to all subsequent HTTP requests参数： Header: 请求头的参数，eg: Accept Content: 就是请求头参数对应的值咯，eg：如果参数是 Accept，那么值我们可以设置为：application/json就是设置 HTTP 的请求头，并将这个请求头应用到后续的请求中去–即设置一次，后续无忧。eg:web_add_auto_header(“Accept”, “application/json”); 2.web_set_max_html_param_len: Sets the maximum length of any HTML string that can be retrieved and saved as a parameter参数： length: 长度为字符形式，默认是 256 个字符就是可以检索和保存为参数的任何 HTML 字符串的最大长度。一般地，如果没用使用 HTML 请求的响应值最为参数传递给下一个 HTML 请求，那么就没必要设置这个值。 3.web_reg_save_param_ex: Registers a request to save dynamic data information to a parameter参数： ParamName: 定义参数名称 LB: 动态数据边界，左边界 RB: 动态数据边界，右边界 Attributes: DFES: 在执行所需的搜索操作之前使用的数据格式扩展的逗号分隔列表。可选的。 NOTFOUND: 在没有找到搜索项并生成空字符串时的处理选项。根据函数的不同，搜索项可以是边界，也可以是XPath。可选的。“Notfound=error”是默认值，当没有找到搜索项时，会引发错误。“Notfound=warning”不发出错误。如果没有找到搜索项，则将参数count设置为0，并继续执行脚本。如果您希望查看是否找到了字符串，但又不希望脚本失败，那么“警告”选项是最理想的。注意:如果脚本启用了Continue on Error，那么即使NOTFOUND被设置为“Error”，当搜索项没有找到时，脚本也会继续执行，但是会向扩展日志文件写入一条错误消息。可选的。 Ordinal: 表示匹配的序号位置或实例。除了传递一个数字外，还可以指定LAST。如果您指定所有参数，则参数值将保存在数组中。可选的。默认实例是1。此属性不适用于web_reg_save_param_xpath。 SaveLen:找到的值的子字符串长度，从指定的偏移量保存到参数。可选的。默认值是-1，表示保存到字符串的末尾。此属性不适用于web_reg_save_param_xpath。 SaveOffset:将找到的值的子字符串的偏移量保存到参数。偏移量必须是非负的。此属性不适用于web_reg_save_param_xpath。可选的。默认值是0。 SelectAll:指定是否保存所有找到的匹配项。如果指定了Yes，它将把匹配的值保存在数组中。可选的。默认值是No。此属性不适用于web_reg_save_param_ex。 SEARCH FILTERS: 指定缓冲区内搜索字符串的部分 使用: SEARCH_FILTERS, “RelFrameID=ALL”, “IgnoreRedirections=off”, “Scope=Body”, “ContentType=text/html”, “RequestUrl=http://mansfied/cgi-bin/echo.asp&quot;, 说明： ContentType:只搜索具有指定ContentType标头的响应。ContentType可以包含*通配符。 HeaderNames: HTTP响应头名的逗号分隔列表。只搜索指定头的值。此参数仅适用于范围为“标头”的情况。 IgnoreRedirections:如果“IgnoreRedirections=Yes”，服务器响应是重定向信息(HTTP状态码300-303,307)，响应不搜索。相反，在接收到重定向响应之后，GET请求被发送到重定向的位置，并在该位置的响应上执行搜索。默认是No。 RelFrameID: HTML页面相对于请求URL的层次结构。可能的值是ALL或一个数字。单击RelFrameID属性查看详细描述。注意:在GUI级脚本中不支持RelFrameID。 RequestURL:只搜索对该请求的响应。URL可以包含*通配符。范围:在何处搜索分隔的数据。可选的。可能的值是全部-搜索整个缓冲区、 只搜索标题、只搜索身体数据、只在Cookies中搜索；如果没有指定DFES参数，则可以使用All。如果使用Scope=Headers和HeaderNames过滤器，则只搜索指定header的值。如果没有使用HeaderNames过滤器，则搜索所有标题文本。 Scope=所有不应用于web_reg_save_param_xpath。默认值是All，除了web_reg_save_param_xpath，它的默认值是Body。就是 2 所讲，所有请求中的响应值缓存区，按照设置，将数据保存在定义的参数中，再将这个参数作为全局参数，供后续请求使用。 web_reg_find: Registers a search for a text string on an HTML page参数： attribute_list：参数列表，有好多的参数，这里先讲两个 Text: 在搜索的文本中搜索指定的内容 SaveCount: 当搜索匹配到 Text 指定的内容是，SaveCount 就会计数就是在 HTML 页面上注册对文本字串的搜索，只对靠近它的一个请求有用（自测发现） lr_start_transaction: Marks the beginning of a transaction参数： transaction_name: 即事务名称就是注册事务开启 web_custom_request: Allows you to create a custom HTTP request with any method supported by HTTP参数： ReuqestName: 注册请求的名称 Attributes: URL: 访问的请求 Method: HTTP 请求的方法 GET、POST等 EncType: 请求头中的 Content-Type Resource: 只是 URL 是否为一个资源，“1” 表示是一个资源，不会影响脚本的运行，遇到错误报“警告”；“0” 表示 URL 是关键的，不受 RTS 的影响。 Referer: 引用/参照页面 Snapshot: 快照文件 Mode: 记录级别为 HTML 或 HTTP Body: 请求使用的参数 LAST: 表示列表字段的结束用于发送 HTTP 请求的函数 lr_eval_string:Returns the string argument after evaluating embedded parameters（将 web_ref_find 计算后的参数转为一个字符串） atoi: Converts a string to an integer value（将字符串转换为整型） lr_output_message: Sends a message to log files, output windows, and other test report summaries(发送信息到日志文件、输出窗口和其他测试报告摘要) lr_end_transaction: 事务结束参数： transactions_name: 事务名称 status: LR_PASS、LR_FAIL、LR_AUTO、LR_STOP lr_think_time: 记录的思考时间，为字符串形式 eg: lr_think_time(“2”);为思考时间2s lr_message: Sends a message to log files and output windows 简单脚本编写此脚本是针对自己写的一个小服务 Demo 经行测试的，所以可能会有一些不合理的地方。 服务 Demo(JAVA)使用的是 SpringBoot 创建的一个小实例12345678910111213141516171819202122232425262728@SpringBootApplication@EnableTransactionManagement@RestController@RequestMapping(value = &quot;/Demo&quot;)public class DemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(DemoApplication.class, args); &#125; @PostMapping(value = &quot;/userInfo&quot;,produces = &quot;application/json;charset=UTF-8&quot;, consumes = &quot;application/json;charset=UTF-8&quot;) public UserInfo test(@RequestHeader(value = &quot;appName&quot;)String appName)&#123; UserInfo userInfo = new UserInfo(); userInfo.setUserName(&quot;feigntest&quot;); userInfo.setPassword(&quot;password&quot;); return userInfo; &#125; @PostMapping(value = &quot;/getUserAge&quot;/*,produces = &quot;application/json;charset=UTF-8&quot;, consumes = &quot;application/json;charset=UTF-8&quot;*/) public UserInfo getUserAge(@RequestParam (name = &quot;userName&quot;)String userName)&#123; UserInfo userInfo = new UserInfo(); userInfo.setUserName(userName); userInfo.setPassword(&quot;password&quot;); userInfo.setAge(22); return userInfo; &#125;&#125; 脚本代码此脚本包含目前在项目压测中使用的函数，每一个函数都有解释响应的理解，当然可能会有一些出入，主要是根据实际情况而定。（应该很详细了吧）脚本里边包含： 设置思考时间 定义全局应用的请求头 取请求返回的数据作为参数进行传递 发送请求的一些设置 如何判断请求是否为正确返回12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970Action()&#123; //Demo lr_think_time(1); web_add_auto_header(&quot;appName&quot;, &quot;abc&quot;);//全局应用请求头--这里的请求头数据不做要求（乱写的），但是头的参数要存在，因为服务定义了 //设置可以检索和保存为参数的任何 HTML 字符串的最大长度 web_set_max_html_param_len(&quot;2048&quot;); //定义赋值参数，只能是全局的，不能定义局部，要不然编译不通过 web_reg_save_param_ex( &quot;ParamName=userName&quot;,//定义参数名称 &quot;LB/IC=\\&quot;userName\\&quot;:\\&quot;&quot;,//LB：定义左边匹配符 IC：忽略大小写 &quot;RB=\\&quot;,&quot;,//定义右边匹配符 &quot;Ordinal=1&quot;,//1:匹配的第一个数据， ALL：将所有匹配值保存为一个数组 &quot;SaveLen=-1&quot;,//不限定参数值的长度 SEARCH_FILTERS, &quot;Scope=Body&quot;,//搜索范围 &quot;RequestURL=*/Demo/userInfo*&quot;,//搜索指定的请求的响应值,如果使用完整的url作为指定请求，值为对应的web_custom_request的url的值，如果有时间戳，记得把时间戳也算上，否则会匹配不上,也可以使用通配符&apos;*&apos; LAST); //事务开启 lr_start_transaction(&quot;userInfo&quot;); //定义可以判断请求成功的验证 //函数注册一个请求，以搜索下一个操作函数(如web_url)检索到的Web页面上的文本字符串。 web_reg_find(&quot;Text=\\&quot;userName\\&quot;:\\&quot;feigntest\\&quot;&quot;, &quot;SaveCount=userInfo_count&quot;,LAST);//计算看这个事务返回的数据，判断时候存在&quot;userName&quot;: &quot;feigntest&quot;这个值，存在则userInfo_count计数+1 //请求 web_custom_request(&quot;userInfo&quot;,//请求名称--自定义即可 &quot;URL=http://10.37.1.185:8991/Demo/userInfo?time=1543200057562&quot;, //访问url &quot;Method=POST&quot;, //HTTP Method &quot;EncType=application/json&quot;,//即 指定处理请求的提交内容类型（Content-Type）,如果这个不一致，请求会报错 415 &quot;Resource=0&quot;, &quot;RecContentType=application/json&quot;, //指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回 &quot;Referer=http://10.37.1.185:8991/&quot;, &quot;Snapshot=t13.inf&quot;, &quot;Mode=HTML&quot;, &quot;Body=&quot;, //不需要参数 LAST); //判断是否正确结束事务 if( atoi(lr_eval_string(&quot;&#123;userInfo_count&#125;&quot;)) &gt; 0) &#123; lr_end_transaction(&quot;userInfo&quot;, LR_PASS); &#125; else &#123; lr_end_transaction(&quot;userInfo&quot;, LR_FAIL); &#125; //事务开启 lr_start_transaction(&quot;getUserAge&quot;); //定义可以判断请求成功的验证 web_reg_find(&quot;Text=\\&quot;age\\&quot;:22&quot;, &quot;SaveCount=getUserAge_count&quot;,LAST);//计算看这个事务返回的数据，判断时候存在&quot;userName&quot;: &quot;feigntest&quot;这个值，存在则userInfo_count计数+1 //请求 web_custom_request(&quot;getUserAge&quot;,//请求名称--自定义即可 &quot;URL=http://10.37.1.185:8991/Demo/getUserAge?time=1543200057562&quot;, //访问url &quot;Method=POST&quot;, //HTTP Method //&quot;EncType=application/json&quot;,//这个请求不能加 RequestHeader--ContentType，不然会让接口报400错误----如果一定要使用这个参数，那么我们的请求参数就不能放在Body定义，直接拼接到url中。。实际要根据接口定义来使用 &quot;Resource=0&quot;, &quot;RecContentType=application/json&quot;, //指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回 &quot;Referer=http://10.37.1.185:8991/&quot;, &quot;Snapshot=t13.inf&quot;, &quot;Mode=HTML&quot;, &quot;Body=userName=&#123;userName&#125;&quot;, //使用上一个请求所得的参数值赋值使用,,也可以直接拼接到url上 LAST); //判断是否正确结束事务 if( atoi(lr_eval_string(&quot;&#123;userInfo_count&#125;&quot;)) &gt; 0) &#123; lr_end_transaction(&quot;getUserAge&quot;, LR_PASS);//正常返回状态为Pass &#125; else &#123; lr_end_transaction(&quot;getUserAge&quot;, LR_FAIL);//错误返回状态为Fail &#125; return 0;&#125; 测试结果的查看和日志选项脚本编写完毕之后，要进行编译测试，确认脚本正常执行才能用于进行性能测试工作。接下来看看日志中如何确认脚本是否正常吧… 测试结果的查看（标准日志） 根据图片上的日志情况就可以反应出当前脚本的运行情况 debug 调式正所谓“理想很丰满，显示很骨感”。并不是所有的脚本编写完成之后都能正常的运行，而根据 1 选项的日志却看不出来脚本的实际情况，那怎么办呢？认命？不存在的…可以先通过 debug 调式看看能不能找到问题…那么如何 debug 呢？这里要使用到两个按键 F5 和 F9，F5 就是运行啦，F9 就是 debug 断点设置和取消70% 的错误都是因为粗心大意而出现的，所以可以通过这种方式查看一下，是不是参数或者是语法导致的错误… 日志查看如果单纯的进行 debug 调式都不能解决问题，那就 只能通过高级日志的查看看看咯…它的位置如下图: 日志打印出来的就比标准日志要多得多，但是在性能测试阶段，建议使用 “仅在出错时返送消息” 或者 “始终发送消息–&gt;标准日志” ，不然日志可能会将你的压力机磁盘写满，导致你后续无法继续工作。也建议偶尔自己去删除打印出来的日志，让压力机减负运行嘛。 参数设置上边的例子没有用到参数列表，所以现在介绍参数列表的使用（例子根据上边的例子进行改造），所以下边开始对如何设置参数进行叙述。这里进行简单的例子：我们将上述例子中的语句稍微修改一下： web_add_auto_header(&quot;appName&quot;, &quot;abc&quot;); 修改为 web_add_auto_header(&quot;appName&quot;, &quot;{appNameArg}&quot;); ，此处的 ‘{appNameArg}’ 为我们定义的参数，中括号不能落下，否则就不是获取参数咯…如果参数列表中没有定义 ‘appNameArg’ 这个参数，那么在脚本中的显示为绿色，如下图： 这里要切记， 使用函数 ‘web_reg_save_param_ex’ 定义的参数，他就是绿色的哦，所以看到绿色参数时要确认是通过 ‘web_reg_save_param_ex’ 函数获取的，还是通过参数列表获取的，不要慌… 接下来看看如果使用参数列表： 打开参数列表定义工具 参数定义和选项介绍新建参数：点击“新建”，输入参数名称，回车即可参数类型：选择对应的参数名称设置参数类型，目前使用到的有 File、Random Number。File 即为文件，以.dat为后缀；Random Number 即为随机数。接下来展示两张图作为参考： 参数值的设置：按编号：即为按列，其实列序号为 1 ，意思时这个参数它对应的时哪个列按名称：即为列名列分割符：Comma(逗号)、Tab(Tab空白)、Space（空格）选择下一行与更新值时间搭配： Sequential(连续的)、Random(随机的)、Unique(唯一的)： Each Iteration：迭代使用，执行一遍脚本用一个值，且当前进程内不会发生改变 Each occurrence：当前当次使用，执行一遍脚本，每次获取到的参数的值都是按顺序往下取值 Once：只使用一次，不重复利用选择下一行（脚本关联–用于 File 参数）：当创建了多个参数时，会发现在选择下一行这个下拉框内会出现一些数据为 Same line as &#39;arg&#39; ，意思就是这个脚本中的同一个参数文件内的参数，行取值由 ‘arg’ 决定为哪一行（即为同一行的意思）。 参数值的设置：从 最小值-最大值 之前取值，即为从 1-100 之间随机取值 参数使用定义成功之后，函数 web_reg_save_param_ex 参数定义部分显示为粉红色，如图： 至此，LoadRunner 简单脚本的编写已经完成了，如遇有疑问或文章有问题，欢迎反馈… 参考文献 百度百科：https://baike.baidu.com/item/loadrunner/1926633?fr=aladdin LoadRunner-常用的函数：https://www.cnblogs.com/zhuzhubaoya/p/9084163.html","categories":[{"name":"LoadRunner","slug":"LoadRunner","permalink":"https://maiyikai.github.io/categories/LoadRunner/"}],"tags":[{"name":"LoadRunner","slug":"LoadRunner","permalink":"https://maiyikai.github.io/tags/LoadRunner/"},{"name":"Test","slug":"Test","permalink":"https://maiyikai.github.io/tags/Test/"},{"name":"script","slug":"script","permalink":"https://maiyikai.github.io/tags/script/"}]},{"title":"错误记录-SpringBoot 之 POI 实现 Excel 操作","slug":"1568191417","date":"2019-09-11T16:30:00.000Z","updated":"2019-10-12T12:21:09.265Z","comments":true,"path":"2019/09/12/1568191417/","link":"","permalink":"https://maiyikai.github.io/2019/09/12/1568191417/","excerpt":"在项目中，对 Excel 的操作，我们一般都会使用 POI 这个工具包。而这个工具包也在不断的优化，所以会存在很多的版本，那么在 MAVEN 项目中，经常会引入不同的依赖 ，所以会在不经意间引入不同版本的依赖，导致正常运行的项目突然之间抛出很多没见过的异常。而这篇文章内容就是根据所遇而写的…","text":"在项目中，对 Excel 的操作，我们一般都会使用 POI 这个工具包。而这个工具包也在不断的优化，所以会存在很多的版本，那么在 MAVEN 项目中，经常会引入不同的依赖 ，所以会在不经意间引入不同版本的依赖，导致正常运行的项目突然之间抛出很多没见过的异常。而这篇文章内容就是根据所遇而写的… POI 依赖引入我们经常会使用 POI 对数据表的导入导出进行操作，而这个工具包无疑是最合适的。每次的更新都能提供更好的性能。所使用的的依赖如下：1234567891011&lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi&lt;/artifactId&gt; &lt;version&gt;3.10-FINAL&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt; &lt;version&gt;3.10-FINAL&lt;/version&gt;&lt;/dependency&gt; 多版本 Excel 工具类实例化当然我使用的并不是最新的内容。很早之前我们使用 POI 工具包实例化针对于不同版本的 Excel 的对象，如：123456789//针对于03版本的Excel，实例化对象POIFSFileSystem pfs = new POIFSFileSystem(new FileInputStream(file)); HSSFWorkbook hwb = new HSSFWorkbook(pfs);//针对于07版本的Excel，实例化对象XSSFWorkbook xw = new XSSFWorkbook(file);//兼容多个Excel版本的实例化对象，最方便，可以完成多个后缀的读写 .xls || .xlsxWorkbook workbook = WorkbookFactory.create(new FileInputStream(file)); 项目中使用：1SXSSFWorkbook wb = new SXSSFWorkbook(100); 无疑，我一般使用的肯定是第三种我们先看看报了什么错… 报错信息测试环境：1234Caused by: java.lang.RuntimeException: java.io.IOException: No such file or directory at org.apache.poi.xssf.streaming.SXSSFWorkbook.createAndRegisterSXSSFSheet(SXSSFWorkbook.java:640) at org.apache.poi.xssf.streaming.SXSSFWorkbook.createSheet(SXSSFWorkbook.java:657) at org.apache.poi.xssf.streaming.SXSSFWorkbook.createSheet(SXSSFWorkbook.java:71) 没有这个文件或目录？不可能，这个目录是存在的… 开发及本地：1234567Caused by: java.io.IOException: Zip bomb detected! The file would exceed the max. ratio of compressed file size to the size of the expanded data. This may indicate that the file is used to inflate memory usage and thus could pose a security risk. You can adjust this limit via ZipSecureFile.setMinInflateRatio() if you need to work with files which exceed this limit. Counter: 172032, cis.counter: 1716, ratio: 0.009974888392857142Limits: MIN_INFLATE_RATIO: 0.01 at org.apache.poi.openxml4j.util.ZipSecureFile$ThresholdInputStream.advance(ZipSecureFile.java:258) at org.apache.poi.openxml4j.util.ZipSecureFile$ThresholdInputStream.read(ZipSecureFile.java:215) at java.io.FilterInputStream.read(FilterInputStream.java:107) at org.apache.poi.xssf.streaming.SXSSFWorkbook.copyStream(SXSSFWorkbook.java:386) at org.apache.poi.xssf.streaming.SXSSFWorkbook.injectData(SXSSFWorkbook.java:368) at org.apache.poi.xssf.streaming.SXSSFWorkbook.write(SXSSFWorkbook.java:947) 压缩比？没用到压缩这个玩意儿啊… 内心独白咦！！！同样的代码，不同的错误信息？怎么搞得？难道是测试环境没给写的权限？不对啊，之前都是正常的啊，这个代码大半年都没动了，难道是有人把权限给改动了？会不会是我？这段时间我一直都是在弄 linux 相关的学习，会不会给误点了？先不管了，先看看本地为什么会报错吧… 错误排查经过一番的心理斗争，还是默默的去找原因，经过我代码排查，找到了是在写流的时候报的错，代码：1234// 输出流 FileOutputStream os = new FileOutputStream(&quot;test.xlsx&quot;);//excel---这个地方报错了workbook.write(os); 奇怪了，怀疑可能是包的问题，先查查用了哪些包吧，经过查找，发现在 pom.xml 中只引用了 3.10-FINAL 版本的 POI 包。奇怪了，找到实例化的工厂对象，看看到哪个地方去了。通过实例化的方法，去查，发现是进入了 3.10-FINAL 版本的。 还是采用查找类路径的方法吧，这么一查，发现还有一个 3.14 版本的 POI。好吧，我在两个版本的构造方法都打上断点，很神奇的发现，它居然跳到了 3.14 版本的类中，实例化了 3.14 版本的 SXSSFWorkbook 实例。 神奇了，编程工具中的 依赖结构查询 没发现有 3.14 版本的，为啥就跑过去了？查找 pom.xml 看是不是我无意中弄进去了，然而通过工程的 pom.xml 并没有发现。所以只能使用最笨的方式了，一个一个依赖的找，最终发现是我在写单元测试的时候引入一个包导致的：123456&lt;dependency&gt; &lt;groupId&gt;org.dbunit&lt;/groupId&gt; &lt;artifactId&gt;dbunit&lt;/artifactId&gt; &lt;version&gt;2.5.4&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 进入这个依赖发现这里边居然有依赖 POI 相关的包，就是 3.14 版本的：123456789101112131415161718192021&lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi&lt;/artifactId&gt; &lt;version&gt;3.14&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt; &lt;version&gt;3.14&lt;/version&gt; &lt;/dependency&gt; 问题解决额好吧，它自己引入的，那我引入 dbunit 这个依赖的时候就去掉就是了：12345678910111213141516&lt;dependency&gt; &lt;groupId&gt;org.dbunit&lt;/groupId&gt; &lt;artifactId&gt;dbunit&lt;/artifactId&gt; &lt;version&gt;2.5.4&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 打包…再测试，正常了…上测试环境，居然也正常了… 总结在开发的时候，总会因为需要而引入不同的依赖，而每次引入依赖的时候，没有仔细的去检查这个依赖中时候存在和当前项目所使用的依赖有冲突的依赖版本，导致了因版本冲突而使代码抛出异常。 参考1.我在CSND写的DEMO：https://blog.csdn.net/maiyikai/article/details/70331798","categories":[{"name":"error","slug":"error","permalink":"https://maiyikai.github.io/categories/error/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://maiyikai.github.io/tags/SpringBoot/"},{"name":"POI","slug":"POI","permalink":"https://maiyikai.github.io/tags/POI/"},{"name":"Excel","slug":"Excel","permalink":"https://maiyikai.github.io/tags/Excel/"}]},{"title":"MyBatis 之 <![CDATA[ ]]>","slug":"1564117346","date":"2019-07-26T10:00:00.000Z","updated":"2019-10-12T12:21:09.265Z","comments":true,"path":"2019/07/26/1564117346/","link":"","permalink":"https://maiyikai.github.io/2019/07/26/1564117346/","excerpt":"在 MyBatis 中，我们都知道 mapper.xml 是使用了 XML 的语法，所以会出现有一些特殊的字符不能直接被转义，在编译解析时，会导致编译出错。例如：’&lt;’ 和 ‘&amp;’ 字符在 XML 元素中都是非法的","text":"在 MyBatis 中，我们都知道 mapper.xml 是使用了 XML 的语法，所以会出现有一些特殊的字符不能直接被转义，在编译解析时，会导致编译出错。例如：’&lt;’ 和 ‘&amp;’ 字符在 XML 元素中都是非法的 疑问？ &lt;![CDATA[ ]]&gt; 是什么东东？ 在 MyBatis 中使用 &lt;![CDATA[ ]]&gt; 不能解决的问题？ 如何解决问题？ &lt;![CDATA[ ]]&gt; 是什么东东？术语 CDATA 是不应该由 XML 解析器解析的文本数据。像 “&lt;” 和 “&amp;” 字符在 XML 元素中都是非法的。“&lt;” 会产生错误，因为解析器会把该字符解释为新元素的开始。“&amp;” 会产生错误，因为解析器会把该字符解释为字符实体的开始。某些文本，MyBatis，判断大小：”SELECT * FROM USER U WHERE U.AGE &lt; 20 “。为了避免错误，可以将脚本代码定义为 CDATA。 CDATA 部分中的所有内容都会被解析器忽略。CDATA 部分由 “&lt;![CDATA[“ 开始，由 “]]&gt;” 结束：12345&lt;SELECT id=&quot;queryUser&quot; resultType=&quot;com.myk.entity.User&quot;&gt;&lt;![CDATA[SELECT * FROM USER U WHERE U.AGE &lt; 20 ]]&gt;&lt;/SELECT&gt; 在上面的实例中，解析器会忽略 CDATA 部分中的所有内容。那么 &lt;![CDATA[ ]]&gt; 部分中的内容将被视为是一个文本数据。 关于 CDATA 部分的注释：CDATA 部分不能包含字符串 “]]&gt;”。也不允许嵌套的 CDATA 部分。标记 CDATA 部分结尾的 “]]&gt;” 不能包含空格或换行。 在 MyBatis 中使用 &lt;![CDATA[ ]]&gt; 不能解决的问题根据上边的解释，应该都知道使用 &lt;![CDATA[ ]]&gt; 会有怎样的效果，那为什么还有不能解决的问题呢？都知道 MyBatis 中有很多的运算标签，如 &lt;if&gt;&lt;/if&gt;、&lt;foreach&gt;&lt;/foreach&gt;、&lt;where&gt;&lt;/where&gt;、&lt;choose&gt;&lt;/choose&gt; 等标签。这里既然提到了这些标签，那么就说明 &lt;![CDATA[]]&gt; 与这些标签一起使用，在执行的时候将会出现问题。，这是为什么呢？因为在 MyBatis 中，解析器解析到这些标签的时候，会单独进行运算封装。而当这些标签被 &lt;![CDATA[ ]]&gt; 标记为文本内容之后，不会被解析器解析，而是将 &lt;![CDATA[ ]]&gt; 标记的内容当成是一条完整的 SQL 语句，进行执行操作，而这条被标记的 SQL 很明显就是有语法问题的，所以执行就是抛异常。如：12345678910&lt;SELECT id=&quot;queryUser&quot; resultType=&quot;com.myk.entity.User&quot;&gt;&lt;![CDATA[SELECT * FROM USER U WHERE U.AGE &amp;lt; 20 ANDU.userId IN&lt;foreach collection=&quot;userIdList&quot; item=&quot;userId&quot; open=&quot;(&quot; close=&quot;)&quot; separator=&quot;,&quot;&gt;#&#123;userId&#125;&lt;/foreach&gt; ]]&gt;&lt;/SELECT&gt; 以上代码会出现两个问题： SQL 中的 &amp;lt; 不会被转义为 ‘&lt;’ 符号 SQl 中的 &lt;foreach&gt;&lt;/foreach&gt; 标签不会被解析执行，而是当成文本内容 SQL 被解析之后是这样的：SELECT * FROM USER U WHERE U.AGE &amp;lt; 20 AND U.userId IN &lt;foreach collection=&quot;userIdList&quot; item=&quot;userId&quot; open=&quot;(&quot; close=&quot;)&quot; separator=&quot;,&quot;&gt; #{userId} &lt;/foreach&gt; 解决 MyBatis 中使用 &lt;![CDATA[ ]]&gt; 的问题目前我有两种想法可以使用 精准定位什么叫精准定位呢？即哪里需要，就标记哪里,最大限度的减少被 &lt;![CDATA[ ]]&gt; 标记的范围，减少出错的可能。如：12345678910&lt;SELECT id=&quot;queryUser&quot; resultType=&quot;com.myk.entity.User&quot;&gt;&lt;![CDATA[SELECT * FROM USER U WHERE U.AGE &lt; 20 ]]&gt;ANDU.userId IN&lt;foreach collection=&quot;userIdList&quot; item=&quot;userId&quot; open=&quot;(&quot; close=&quot;)&quot; separator=&quot;,&quot;&gt;#&#123;userId&#125;&lt;/foreach&gt; &lt;/SELECT&gt; 最后解析出来的 SQL ：SELECT * FROM USER U WHERE U.AGE &lt; 20 AND userId IN （&#39;&#39;） SQL全包裹全包裹，顾名思义就是 &lt;![CDATA[ ]]&gt; 标记整条 SQL ，如果必须使用这种方式，那么 SQL 中就不能出现 MyBatis 的运算标签，如：1234567&lt;SELECT id=&quot;queryUser&quot; resultType=&quot;com.myk.entity.User&quot;&gt;&lt;![CDATA[SELECT * FROM USER U WHERE U.AGE &lt; 20 ANDU.userId = #&#123;userId&#125; ]]&gt;&lt;/SELECT&gt; 最后解析出来的 SQL ：SELECT * FROM USER U WHERE U.AGE &lt; 20 AND U.userId = #{userId}","categories":[{"name":"MyBatis","slug":"MyBatis","permalink":"https://maiyikai.github.io/categories/MyBatis/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"https://maiyikai.github.io/tags/MyBatis/"}]},{"title":"正则表达式的简单使用","slug":"1563873556","date":"2019-07-23T15:00:00.000Z","updated":"2019-10-12T12:21:09.265Z","comments":true,"path":"2019/07/23/1563873556/","link":"","permalink":"https://maiyikai.github.io/2019/07/23/1563873556/","excerpt":"正则表达式，又称规则表达式（Regular Express【代码中常见：regex、regexp、RE】）。 正则表达式在处理文本替换、数据匹配、数据筛选等时候可以提高工作效率；例如给一个100M的文档给你，让查询某种格式的内容时，不需要用“人工智障”的方式死盯着，直接通过正则匹配查询，即可精确的查找想要找到的内容。","text":"正则表达式，又称规则表达式（Regular Express【代码中常见：regex、regexp、RE】）。 正则表达式在处理文本替换、数据匹配、数据筛选等时候可以提高工作效率；例如给一个100M的文档给你，让查询某种格式的内容时，不需要用“人工智障”的方式死盯着，直接通过正则匹配查询，即可精确的查找想要找到的内容。 简介正则表达式是对字符串操作的一种逻辑公式，就是用事先定义好的一些特定的字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。 目的 给定的字符串是否符合正则表达式的过滤逻辑 可以通过正则表达式，从字符串中获取我们想要的特定部分 特点 灵活性、逻辑性和功能性强 可以迅速地用极简单的方式达到字符串的复杂控制 元字符 字符 描述 \\ 将下一个字符标记为一个特殊字符、或一个原义字符、或一个 向后引用、或一个八进制转义符。例如，’n’ 匹配字符 “n”。’\\n’ 匹配一个换行符。序列 ‘\\‘ 匹配 “\\” 而 “(“ 则匹配 “(“。 ^ 匹配输入字符串的开始位置。如果设置了 RegExp 对象的 Multiline 属性，^ 也匹配 ‘\\n’ 或 ‘\\r’ 之后的位置。 $ 匹配输入字符串的结束位置。如果设置了RegExp 对象的 Multiline 属性，$ 也匹配 ‘\\n’ 或 ‘\\r’ 之前的位置。 * 匹配前面的子表达式零次或多次。例如，zo 能匹配 “z” 以及 “zoo”。 等价于{0,}。 + 匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。 ? 匹配前面的子表达式零次或一次。例如，”do(es)?” 可以匹配 “do” 或 “does” 。? 等价于 {0,1}。 {n} n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。 {n,} n 是一个非负整数。至少匹配n 次。例如，’o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。’o{1,}’ 等价于 ‘o+’。’o{0,}’ 则等价于 ‘o*’。 {n,m} m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。例如，”o{1,3}” 将匹配 “fooooood” 中的前三个 o。’o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。 ? 当该字符紧跟在任何一个其他限制符 (*, +, ?, {n}, {n,}, {n,m}) 后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串 “oooo”，’o+?’ 将匹配单个 “o”，而 ‘o+’ 将匹配所有 ‘o’。 . 匹配除换行符（\\n、\\r）之外的任何单个字符。要匹配包括 ‘\\n’ 在内的任何字符，请使用像”(.&#124;\\n)”的模式。 (pattern) 匹配 pattern 并获取这一匹配。所获取的匹配可以从产生的 Matches 集合得到，在VBScript 中使用 SubMatches 集合，在JScript 中则使用 $0…$9 属性。要匹配圆括号字符，请使用 ‘(‘ 或 ‘)‘。 (?:pattern) 匹配 pattern 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用 “或” 字符 (&#124;) 来组合一个模式的各个部分是很有用。例如， ‘industr(?:y&#124;ies) 就是一个比 ‘industry&#124;industries’ 更简略的表达式。 (?=pattern) 正向肯定预查（look ahead positive assert），在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，”Windows(?=95&#124;98&#124;NT&#124;2000)”能匹配”Windows2000”中的”Windows”，但不能匹配”Windows3.1”中的”Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。 (?!pattern) 正向否定预查(negative assert)，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如”Windows(?!95&#124;98&#124;NT&#124;2000)”能匹配”Windows3.1”中的”Windows”，但不能匹配”Windows2000”中的”Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。 (?&lt;=pattern) 反向(look behind)肯定预查，与正向肯定预查类似，只是方向相反。例如，”(?&lt;=95&#124;98&#124;NT&#124;2000)Windows”能匹配”2000Windows”中的”Windows”，但不能匹配”3.1Windows”中的”Windows”。 (?&lt;!pattern) 反向否定预查，与正向否定预查类似，只是方向相反。例如”(?&lt;!95&#124;98&#124;NT&#124;2000)Windows”能匹配”3.1Windows”中的”Windows”，但不能匹配”2000Windows”中的”Windows”。 x&#124;y 匹配 x 或 y。例如，’z&#124;food’ 能匹配 “z” 或 “food”。’(z&#124;f)ood’ 则匹配 “zood” 或 “food”。 [xyz] 字符集合。匹配所包含的任意一个字符。例如， ‘[abc]’ 可以匹配 “plain” 中的 ‘a’。 [^xyz] 负值字符集合。匹配未包含的任意字符。例如， ‘[^abc]’ 可以匹配 “plain” 中的’p’、’l’、’i’、’n’。 [a-z] 字符范围。匹配指定范围内的任意字符。例如，’[a-z]’ 可以匹配 ‘a’ 到 ‘z’ 范围内的任意小写字母字符。 [^a-z] 负值字符范围。匹配任何不在指定范围内的任意字符。例如，’[^a-z]’ 可以匹配任何不在 ‘a’ 到 ‘z’ 范围内的任意字符。 \\b 匹配一个单词边界，也就是指单词和空格间的位置。例如， ‘er\\b’ 可以匹配”never” 中的 ‘er’，但不能匹配 “verb” 中的 ‘er’。 \\B 匹配非单词边界。’er\\B’ 能匹配 “verb” 中的 ‘er’，但不能匹配 “never” 中的 ‘er’。 \\cx 匹配由 x 指明的控制字符。例如， \\cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 ‘c’ 字符。 \\d 匹配一个数字字符。等价于 [0-9]。 \\D 匹配一个非数字字符。等价于 [^0-9]。 \\f 匹配一个换页符。等价于 \\x0c 和 \\cL。 \\n 匹配一个换行符。等价于 \\x0a 和 \\cJ。 \\r 匹配一个回车符。等价于 \\x0d 和 \\cM。 \\s 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \\f\\n\\r\\t\\v]。 \\S 匹配任何非空白字符。等价于 [^ \\f\\n\\r\\t\\v]。 \\t 匹配一个制表符。等价于 \\x09 和 \\cI。 \\v 匹配一个垂直制表符。等价于 \\x0b 和 \\cK。 \\w 匹配字母、数字、下划线。等价于’[A-Za-z0-9_]’。 \\W 匹配非字母、数字、下划线。等价于 ‘[^A-Za-z0-9_]’。 \\xn 匹配 n，其中 n 为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，’\\x41’ 匹配 “A”。’\\x041’ 则等价于 ‘\\x04’ &amp; “1”。正则表达式中可以使用 ASCII 编码。 \\num 匹配 num，其中 num 是一个正整数。对所获取的匹配的引用。例如，’(.)\\1’ 匹配两个连续的相同字符。 \\n 标识一个八进制转义值或一个向后引用。如果 \\n 之前至少 n 个获取的子表达式，则 n 为向后引用。否则，如果 n 为八进制数字 (0-7)，则 n 为一个八进制转义值。 \\nm 标识一个八进制转义值或一个向后引用。如果 \\nm 之前至少有 nm 个获得子表达式，则 nm 为向后引用。如果 \\nm 之前至少有 n 个获取，则 n 为一个后跟文字 m 的向后引用。如果前面的条件都不满足，若 n 和 m 均为八进制数字 (0-7)，则 \\nm 将匹配八进制转义值 nm。 \\nml 如果 n 为八进制数字 (0-3)，且 m 和 l 均为八进制数字 (0-7)，则匹配八进制转义值 nml。 \\un 匹配 n，其中 n 是一个用四个十六进制数字表示的 Unicode 字符。例如， \\u00A9 匹配版权符号 (?)。 运算符优先级 运算符 描述 \\ 转义符 (), (?:), (?=), [] 圆括号和方括号 *, +, ?, {n}, {n,}, {n,m} 限定符 ^, $, \\任何元字符、任何字符 定位点和序列（即：位置和顺序） &#124; 替换，”或”操作字符具有高于替换运算符的优先级，使得”m&#124;food”匹配”m”或”food”。若要匹配”mood”或”food”，请使用括号创建子表达式，从而产生”(m&#124;f)ood”。 规则 数字 数字：^[0-9]*$ n位的数字：^\\d{n}$ 至少n位的数字：^\\d{n,}$ m-n位的数字：^\\d{m,n}$ 零和非零开头的数字：^(0|[1-9][0-9]*)$ 非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(.[0-9]{1,2})?$ 带1-2位小数的正数或负数：^(-)?\\d+(.\\d{1,2})$ 正数、负数、和小数：^(-|+)?\\d+(.\\d+)?$ 有两位小数的正实数：^[0-9]+(.[0-9]{2})?$ 有1~3位小数的正实数：^[0-9]+(.[0-9]{1,3})?$ 非零的正整数：^[1-9]\\d$ 或 ^([1-9][0-9]){1,3}$ 或 ^+?[1-9][0-9]*$ 非零的负整数：^-[1-9][]0-9”$ 或 ^-[1-9]\\d$ 非负整数：^\\d+$ 或 ^[1-9]\\d*|0$ 非正整数：^-[1-9]\\d*|0$ 或 ^((-\\d+)|(0+))$ 非负浮点数：^\\d+(.\\d+)?$ 或 ^[1-9]\\d.\\d|0.\\d[1-9]\\d|0?.0+|0$ 非正浮点数：^((-\\d+(.\\d+)?)|(0+(.0+)?))$ 或 ^(-([1-9]\\d.\\d|0.\\d[1-9]\\d))|0?.0+|0$ 正浮点数：^[1-9]\\d.\\d|0.\\d[1-9]\\d$ 或 ^(([0-9]+.[0-9][1-9][0-9])|([0-9][1-9][0-9].[0-9]+)|([0-9][1-9][0-9]))$ 负浮点数：^-([1-9]\\d.\\d|0.\\d[1-9]\\d)$ 或 ^(-(([0-9]+.[0-9][1-9][0-9])|([0-9][1-9][0-9].[0-9]+)|([0-9][1-9][0-9])))$ 浮点数：^(-?\\d+)(.\\d+)?$ 或 ^-?([1-9]\\d.\\d|0.\\d[1-9]\\d|0?.0+|0)$ 字符 汉字：^[\\u4e00-\\u9fa5]{0,}$ 英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]{4,40}$ 长度为3-20的所有字符：^.{3,20}$ 由26个英文字母组成的字符串：^[A-Za-z]+$ 由26个大写英文字母组成的字符串：^[A-Z]+$ 由26个小写英文字母组成的字符串：^[a-z]+$ 由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$ 由数字、26个英文字母或者下划线组成的字符串：^\\w+$ 或 ^\\w{3,20}$ 中文、英文、数字包括下划线：^[\\u4E00-\\u9FA5A-Za-z0-9_]+$ 中文、英文、数字但不包括下划线等符号：^[\\u4E00-\\u9FA5A-Za-z0-9]+$ 或 ^[\\u4E00-\\u9FA5A-Za-z0-9]{2,20}$ 可以输入含有^%&amp;’,;=?$\\”等字符：[^%&amp;’,;=?$\\x22]+ 禁止输入含有~的字符：[^~\\x22]+ 特殊需求 Email地址：^\\w+([-+.]\\w+)@\\w+([-.]\\w+).\\w+([-.]\\w+)*$ 域名：[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.? InternetURL：[a-zA-z]+://[^\\s] 或 ^http://([\\w-]+.)+[\\w-]+(/[\\w-./?%&amp;=])?$ 手机号码：^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\\d{8}$ 电话号码(“XXX-XXXXXXX”、”XXXX-XXXXXXXX”、”XXX-XXXXXXX”、”XXX-XXXXXXXX”、”XXXXXXX”和”XXXXXXXX)：^((\\d{3,4}-)|\\d{3.4}-)?\\d{7,8}$ 国内电话号码(0511-4405222、021-87888822)：\\d{3}-\\d{8}|\\d{4}-\\d{7} 电话号码正则表达式（支持手机号码，3-4位区号，7-8位直播号码，1－4位分机号）: ((\\d{11})|^((\\d{7,8})|(\\d{4}|\\d{3})-(\\d{7,8})|(\\d{4}|\\d{3})-(\\d{7,8})-(\\d{4}|\\d{3}|\\d{2}|\\d{1})|(\\d{7,8})-(\\d{4}|\\d{3}|\\d{2}|\\d{1}))$) 身份证号(15位、18位数字)，最后一位是校验位，可能为数字或字符X：(^\\d{15}$)|(^\\d{18}$)|(^\\d{17}(\\d|X|x)$) 帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$ 密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\\w{5,17}$ 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在 8-10 之间)：^(?=.\\d)(?=.[a-z])(?=.*[A-Z])[a-zA-Z0-9]{8,10}$ 强密码(必须包含大小写字母和数字的组合，可以使用特殊字符，长度在8-10之间)：^(?=.\\d)(?=.[a-z])(?=.*[A-Z]).{8,10}$ 日期格式：^\\d{4}-\\d{1,2}-\\d{1,2} 一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$ 一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$ 钱的输入格式： 有四种钱的表示形式我们可以接受:”10000.00” 和 “10,000.00”, 和没有 “分” 的 “10000” 和 “10,000”：^[1-9][0-9]*$ 这表示任意一个不以0开头的数字,但是,这也意味着一个字符”0”不通过,所以我们采用下面的形式：^(0|[1-9][0-9]*)$ 一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9]*)$ 这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧。下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$ 必须说明的是,小数点后面至少应该有1位数,所以”10.”是不通过的,但是 “10” 和 “10.2” 是通过的：^[0-9]+(.[0-9]{2})?$ 这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：^[0-9]+(.[0-9]{1,2})?$ 这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：^[0-9]{1,3}(,[0-9]{3})*(.[0-9]{1,2})?$ 1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：^([0-9]+|[0-9]{1,3}(,[0-9]{3})*)(.[0-9]{1,2})?$ 备注：这就是最终结果了,别忘了”+”可以用”*”替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里 xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\.[x|X][m|M][l|L]$ 中文字符的正则表达式：[\\u4e00-\\u9fa5] 双字节字符：[^\\x00-\\xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1)) 空白行的正则表达式：\\n\\s*\\r (可以用来删除空白行) HTML标记的正则表达式：&lt;(\\S?)[^&gt;]&gt;.?|&lt;.? /&gt; ( 首尾空白字符的正则表达式：^\\s|\\s$或(^\\s)|(\\s$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式) 腾讯QQ号：[1-9][0-9]{4,} (腾讯QQ号从10000开始) 中国邮政编码：[1-9]\\d{5}(?!\\d) (中国邮政编码为6位数字) IP地址：((?:(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)) 查询替换（例子仅限于此处测试使用） eg1: 去除字符串中的某些内容，其余项保留 字符串：abc123ijn@qq.com 要求： 去除邮箱中的“123”内容 查询正则： ([a-z|A-Z]{3})(\\d{3})([a-z|A-Z]{3})(@qq.com) 替换正则： $1$3$4 结果： abcijn@qq.com 解析：使用”()”将字符串“abc123ijn@qq.com”分为4个部分，“$1”表示取的是被分割的字符串的第1部分；类似于一个将字符串分割成一个数组，“1 | 2 | 3 | …”分别代表的是数组的下标，“$1”即为取第一个下标的数据。 eg2: 在字符串前添加指定字符，其他的内容不变 字符串：abc123ijn@qq.com 要求：在字符串“abc”和“123”之间添加符号“#￥%” 查询正则： ([a-z|A-Z]{3})(\\d{3})([a-z|A-Z]{3})(@qq.com) 替换正则： $1#￥%$2$3$4 结果：abc#￥%123ijn@qq.com 解析：同上 eg3: 替换字符串中的某些内容 字符串：abc123ijn@qq.com 要求：将字符串“123”，替换为“iloveu” 查询正则： ([a-z|A-Z]{3})(\\d{3})([a-z|A-Z]{3})(@qq.com) 替换正则： $1iloveu$3$4 结果：abciloveuijn@qq.com 解析：同上 参考内容 摘抄自：https://www.runoob.com/regexp/regexp-tutorial.html","categories":[{"name":"regex","slug":"regex","permalink":"https://maiyikai.github.io/categories/regex/"}],"tags":[{"name":"regex","slug":"regex","permalink":"https://maiyikai.github.io/tags/regex/"},{"name":"正则表达式","slug":"正则表达式","permalink":"https://maiyikai.github.io/tags/正则表达式/"}]},{"title":"LoadRunner使用google浏览器脚本录制","slug":"1558665386","date":"2019-05-24T10:00:00.000Z","updated":"2019-10-12T12:21:09.265Z","comments":true,"path":"2019/05/24/1558665386/","link":"","permalink":"https://maiyikai.github.io/2019/05/24/1558665386/","excerpt":"莫名其妙的接到压力测试的任务 工具：LoadRunner v.11、Google Chrome","text":"莫名其妙的接到压力测试的任务 工具：LoadRunner v.11、Google Chrome其实LoadRunner支持多个浏览器的，ie浏览器是最好的选择，奈何项目不支持ie，而使用Google Chrome，LoadRunner又不能将它直接打开录制，所以只能是找找找资料了，功夫不负有心人，网上很多都是“渣”，不可用。 浏览器LoadRunner支持的浏览器： 8.0 最高ie6 8.1 最高ie6 9.0 最高ie7 9.5 最高ie8 11.0 最高ie9( win7 32位+LR11+IE10可用，但win7 64位+LR11+IE10不可用，降至IE9可用)，支持firefox3.6、24.0 12.0 支持IE11 LoadRunner 打开LoadRunner 创建脚本，点击上图“创建/编辑脚本” 进入到开始录制界面 设置 选择要录制的程序–&gt;到LoadRunner的安装路径下查找：C:\\Program Files (x86)\\HP\\LoadRunner\\bin文件名为“wplus_init_wsock”的程序 2. 输入要录制的URL(隐私保护，这是假的): http://www.baidu.com 3. 点击下方选项按钮 4. 创建条目 5. 更新之后确认即可 6. 返回到第一步，先不要录制，需要等到浏览器设置好之后才能录制 Google Chrome设置 打开浏览器，进入设置，选择系统设置，再选择打开代理设置 设置代理 开始录制 进入LoadRunner,开始录制 打开浏览器，在地址栏输入你要录制的服务器地址 录制完成 到这里，就基本结束了 参考资料 Loadrunner如何使用谷歌浏览器录制脚本https://blog.csdn.net/qq_43485197/article/details/83652797","categories":[{"name":"LoadRunner","slug":"LoadRunner","permalink":"https://maiyikai.github.io/categories/LoadRunner/"}],"tags":[{"name":"LoadRunner","slug":"LoadRunner","permalink":"https://maiyikai.github.io/tags/LoadRunner/"},{"name":"Test","slug":"Test","permalink":"https://maiyikai.github.io/tags/Test/"}]},{"title":"CenterOS服务器搭建--网络配置","slug":"1558423260","date":"2019-05-21T15:00:00.000Z","updated":"2019-10-12T12:21:09.264Z","comments":true,"path":"2019/05/21/1558423260/","link":"","permalink":"https://maiyikai.github.io/2019/05/21/1558423260/","excerpt":"在虚拟机中安装了LINUX系统，在例子中全部使用的是CenterOS，版本是8.3。 系统版本不一样，会导致有部分命令是改变的，例如这个版本查看ip地址的命令是：ip add/addr","text":"在虚拟机中安装了LINUX系统，在例子中全部使用的是CenterOS，版本是8.3。 系统版本不一样，会导致有部分命令是改变的，例如这个版本查看ip地址的命令是：ip add/addr 查看本机ip地址输入命令： ip addr下图教你如何查看服务器的ip,如果一开始没有配置，或者没有使用桥接联网的话，一般都是“127.0.0.1” 网络配置文件网卡文件地址路径：/etc/sysconfig/network-scripts/ 查看一下目录下的文件/目录：ls -al 名称：通过上图可以看到配置文件名称名称，一般都是前缀为“ifcfg-”,后缀为网卡名称”eth0” 使用vi文本编辑器编辑文件输入命令vi ifcfg-eth0，查看文件默认的内容： 123456789101112131415TYPE=Ethernet # 网卡类型：为以太网PROXY_METHOD=none # 代理方式：关闭状态BROWSER_ONLY=no # 只是浏览器：否BOOTPROTO=dhcp # 网卡的引导协议：DHCP[中文名称: 动态主机配置协议], static :静态 none:不指定DEFROUTE=yes # 默认路由：是, 不明白的可以百度关键词 `默认路由` IPV4_FAILURE_FATAL=no # 是不开启IPV4致命错误检测：否IPV6INIT=yes # IPV6是否自动初始化: 是[不会有任何影响, 现在还没用到IPV6]IPV6_AUTOCONF=yes # IPV6是否自动配置：是[不会有任何影响, 现在还没用到IPV6]IPV6_DEFROUTE=yes # IPV6是否可以为默认路由：是[不会有任何影响, 现在还没用到IPV6]IPV6_FAILURE_FATAL=no # 是不开启IPV6致命错误检测：否IPV6_ADDR_GEN_MODE=stable-privacy # IPV6地址生成模型：stable-privacy [这只一种生成IPV6的策略]NAME=eth0 # 网卡物理设备名称UUID=f47bde51-fa78-4f79-b68f-d5dd90cfc698 # 通用唯一识别码, 每一个网卡都会有, 不能重复, 否两台linux只有一台网卡可用DEVICE=eth0 # 网卡设备名称, 必须和 `NAME` 值一样ONBOOT=no # 是否开机启动， 要想网卡开机就启动或通过 `systemctl restart network`控制网卡,必须设置为 `yes` 静态网络要配置 规划服务器ip，配置自己的局域网，需要改动几个属性的值： 敲键盘按键”Insert”，进入编辑状态 找到合适的位置进行编辑 退出：先按“Esc”键，然后输入:wq，保存并退出， 或:q!，强制退出并不保存。 1234567BOOTPROTO=staticONBOOT=yesIPADDR=192.168.3.190NETMASK=255.255.255.0GATEWAY=192.168.3.1DNS1=114.114.114.114DNS2=8.8.8.8 注意： 其他不明白的不要动它 网管和ip段要与宿主机一致，否则不能通过宿主机访问服务器 重新启动网络重新启动网络，使其生效：service network restart 验证网络： 参考资料 Linux IP和网关配置 https://www.cnblogs.com/linyfeng/p/7534677.html linux_下IP、网关、DNS地址配置 https://www.cnblogs.com/xuzhiwei/p/3560553.html","categories":[{"name":"CenterOS","slug":"CenterOS","permalink":"https://maiyikai.github.io/categories/CenterOS/"}],"tags":[{"name":"LINUX","slug":"LINUX","permalink":"https://maiyikai.github.io/tags/LINUX/"},{"name":"Network","slug":"Network","permalink":"https://maiyikai.github.io/tags/Network/"},{"name":"CenterOS","slug":"CenterOS","permalink":"https://maiyikai.github.io/tags/CenterOS/"}]},{"title":"Spring Boot配备多数据源","slug":"1554706715","date":"2019-04-08T15:00:00.000Z","updated":"2019-10-12T12:21:09.264Z","comments":true,"path":"2019/04/08/1554706715/","link":"","permalink":"https://maiyikai.github.io/2019/04/08/1554706715/","excerpt":"一般情况下，我们一个服务最多使用一个数据源，并且拥有一个连接池； 但是不能避免的特殊情况，会使用多个库（不包括分库操作），所以就要配备多个指定的数据源，分别对不同的库进行操作","text":"一般情况下，我们一个服务最多使用一个数据源，并且拥有一个连接池； 但是不能避免的特殊情况，会使用多个库（不包括分库操作），所以就要配备多个指定的数据源，分别对不同的库进行操作 接下来就开始写代码吧！ 数据库准备分别建立两个不同的库(名字任意，本例子使用：dynamic1和dynamic2)，在其中建立不同的表，当然如果你懒得话，可以和我一样，复制粘贴，改个名字就行（针对库），你会发现省了很多事… O(∩_∩)O哈哈~ 以下为脚本（我用的是同一个表结构，但是数据要改一下，不然分不清使用结果）： 1234567891011121314151617181920-- dynamic1 ----------------------------SET NAMES utf8mb4;SET FOREIGN_KEY_CHECKS = 0;-- ------------------------------ Table structure for databaseinfo-- ----------------------------DROP TABLE IF EXISTS `databaseinfo`;CREATE TABLE `databaseinfo` () ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;-- ------------------------------ Records of databaseinfo-- ----------------------------INSERT INTO `databaseinfo` VALUES (&apos;1&apos;, &apos;NO.1&apos;);SET FOREIGN_KEY_CHECKS = 1;-- dynamic2 ----------------------------INSERT INTO `databaseinfo` VALUES (&apos;1&apos;, &apos;NO.2&apos;); 简易目录结构为了不浪费时间，我直接简化目录结构了 123456789101112131415161718192021222324252627java:com.maiyikai.dynamic|--- config|--- |--- DataSourceOne.java|--- |--- DataSourceTwo.java|--- controller|--- |--- DynamicDataSourceTestController.java|--- service|--- |--- DynamicDataSourceOneService.java|--- |--- DynamicDataSourceTwoService.java|--- |--- impl|--- |--- |--- DynamicDataSourceOneServiceImpl.java|--- |--- |--- DynamicDataSourceTwoServiceImpl.java|--- mapper|--- |--- DynamicTestOne.java|--- mappers|--- |--- DynamicTestTwo.java|--- entity|--- |--- DatabaseInfo.java|--- DynamicApplication.javaresources|--- mapper|--- |--- dynamicOne.xml|--- mappers|--- |--- dynamicTwo.xml|--- application.yml 需要引入的包 pom.xml引入的包就是正常连接数据库需要的包，为了使对象更高的输出在控制台，我引入了fastjson 这里使用的Spring Boot2以上版本，在配置的地方会有一些不一样 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.3.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.maiyikai&lt;/groupId&gt; &lt;artifactId&gt;dynamic&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;dynamic&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web-services&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.10&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;6.0.6&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/com.alibaba/fastjson --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.54&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; application.yml配置因为连接mysql的包的版本比较高，所以有一些多余的配置要加载数据库连接的URL上 因为使用了Spring Boot2以上版本，所以对url和driver-class更改为： jdbc-url和driver-class-name；否则获取不到对应的连接和驱动名称 因未使用了Druid，所以有一个特性是可以根据jdbc-url自动配置相关的驱动类，所以配置地方我删掉了 1234567891011121314151617181920212223242526272829server: port: 8082# druid：根据jdbc-url自动配置驱动# 不使用serverTimezone=UTC：java.sql.SQLException: The server time zone value &apos;�й���׼ʱ��&apos; is unrecognized or represents more than one time zone. You must configure either the server or JDBC driver (via the serverTimezone configuration property) to use a more specifc time zone value if you want to utilize time zone support.# 不使用useSSL=true：Establishing SSL connection without server&apos;s identity verification is not recommended. According to MySQL 5.5.45+, 5.6.26+ and 5.7.6+ requirements SSL connection must be established by default if explicit option isn&apos;t set. For compliance with existing applications not using SSL the verifyServerCertificate property is set to &apos;false&apos;. You need either to explicitly disable SSL by setting useSSL=false, or set useSSL=true and provide truststore for server certificate verification.spring: datasource: druid: test1: jdbc-url: jdbc:mysql://localhost:3306/dynamic1?useUnicode=true&amp;characterEncoding=utf8&amp;serverTimezone=UTC&amp;useSSL=true username: root password: ******** validationQuery: SELECT 1 timeBetweenEvictionRunsMillis: 60000 minEvictableIdleTimeMillis: 28800 testOnBorrow: false testWhileIdle: true testOnReturn: false test2: jdbc-url: jdbc:mysql://localhost:3306/dynamic2?useUnicode=true&amp;characterEncoding=utf8&amp;serverTimezone=UTC&amp;useSSL=true username: root password: ******** validationQuery: SELECT 1 timeBetweenEvictionRunsMillis: 60000 minEvictableIdleTimeMillis: 28800 testOnBorrow: false testWhileIdle: true testOnReturn: false 数据源配置分别配置两个不同的数据源，并设置其中一个为主数据源，否则会报错 需要对DataSource、SqlSessionFactory、SqlSessionTemplate进行配置，所以 第一个数据源（DataSourceOne.java） 1234567891011121314151617181920212223242526272829/** * 必须要有一个主数据源 */@Configuration@AutoConfigureBefore(DataSourceAutoConfiguration.class)@MapperScan(value = &quot;com.maiyikai.dynamic.mapper&quot;, sqlSessionTemplateRef = &quot;sqlSessionTemplate1&quot;)public class DataSourceOne &#123; @Bean(&quot;dynamic1DataSource&quot;) @Primary @ConfigurationProperties(prefix = &quot;spring.datasource.druid.test1&quot;) public DataSource dynamic1DataSource()&#123; return DataSourceBuilder.create().build(); &#125; @Bean(&quot;sqlSession1Factory&quot;) @Primary public SqlSessionFactory sqlSession1Factory(@Qualifier(&quot;dynamic1DataSource&quot;) DataSource dataSource) throws Exception &#123; SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean(); sqlSessionFactoryBean.setDataSource(dataSource); sqlSessionFactoryBean.setMapperLocations(new PathMatchingResourcePatternResolver().getResources(&quot;classpath:mapper/*.xml&quot;)); return sqlSessionFactoryBean.getObject(); &#125; @Bean(&quot;sqlSessionTemplate1&quot;) @Primary public SqlSessionTemplate sqlSessionTemplate1(@Qualifier(&quot;sqlSession1Factory&quot;)SqlSessionFactory sqlSessionFactory)&#123; return new SqlSessionTemplate(sqlSessionFactory); &#125; 第二个数据源（DataSourceTwo.java） 123456789101112131415161718192021222324252627/** * 不能与主数据源指定同一个mapper，否则不生效 */@Configuration@AutoConfigureBefore(DataSourceAutoConfiguration.class)@MapperScan(value = &quot;com.maiyikai.dynamic.mappers&quot;, sqlSessionTemplateRef = &quot;sqlSessionTemplate2&quot;)public class DataSourceTwo &#123; @Bean(&quot;dynamic1DataSource2&quot;) @ConfigurationProperties(prefix = &quot;spring.datasource.druid.test2&quot;) public DataSource dataSource()&#123; return DataSourceBuilder.create().build(); &#125; @Bean(&quot;sqlSessionFactory2&quot;) public SqlSessionFactory sqlSessionFactory(@Qualifier(&quot;dynamic1DataSource2&quot;)DataSource dataSource) throws Exception &#123; SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean(); sqlSessionFactoryBean.setDataSource(dataSource); sqlSessionFactoryBean.setMapperLocations(new PathMatchingResourcePatternResolver().getResources(&quot;classpath:mappers/*.xml&quot;)); return sqlSessionFactoryBean.getObject(); &#125; @Bean(&quot;sqlSessionTemplate2&quot;) public SqlSessionTemplate sqlSessionTemplate(@Qualifier(&quot;sqlSessionFactory2&quot;) SqlSessionFactory sqlSessionFactory)&#123; return new SqlSessionTemplate(sqlSessionFactory); &#125;&#125; 服务类方法声明为一样的，方便（懒）…O(∩_∩)O哈哈~ 接口只拿一个做演示(DynamicDataSourceOneService.java) 123public interface DynamicDataSourceOneService &#123; DatabaseInfo getDatabaseInfo(String id);&#125; 实现类 DynamicDataSourceOneServiceImpl.java 1234567891011@Servicepublic class DynamicDataSourceOneServiceImpl implements DynamicDataSourceOneService &#123; @Autowired private DynamicTestOne dynamicTestOne; @Override public DatabaseInfo getDatabaseInfo(String id) &#123; return dynamicTestOne.getDatabaseInfoOne(id); &#125;&#125; DynamicDataSourceTwoServiceImpl.java 1234567891011@Servicepublic class DynamicDataSourceTwoServiceImpl implements DynamicDataSourceTwoService &#123; @Autowired private DynamicTestTwo dynamicTestTwo; @Override public DatabaseInfo getDatabaseInfo(String id) &#123; return dynamicTestTwo.getDatabaseInfoTwo(id); &#125;&#125; mapper及xml因为本人比较勤（hen）奋(lan),所以这里只提供一个 mapper（DynamicTestOne.java） 1234public interface DynamicTestOne &#123; DatabaseInfo getDatabaseInfoOne(@Param(&quot;id&quot;)String id);&#125; xml（dynamicOne.xml） 123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.maiyikai.dynamic.mapper.DynamicTestOne&quot;&gt; &lt;select id=&quot;getDatabaseInfoOne&quot; parameterType=&quot;java.lang.String&quot; resultType=&quot;com.maiyikai.dynamic.entity.DatabaseInfo&quot;&gt; select * from databaseinfo where id=#&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 定义测试接口准备好了，就要定义接口进行测试了，当然我肯定是选择最简单，最容易访问的方式写访问啦（除了这种方法还可以使用单元测试的方式） 1234567891011121314151617181920@Controller@RequestMapping(value = &quot;/DynamicDataSource&quot;)@ResponseBodypublic class DynamicDataSourceTestController &#123; @Autowired private DynamicDataSourceOneService dynamicDataSourceOneService; @Autowired private DynamicDataSourceTwoService dynamicDataSourceTwoService; @GetMapping(&quot;/getDatabaseInfo/&#123;id&#125;&quot;) public String getDatabaseInfo(@PathVariable(&quot;id&quot;)String id)&#123; DatabaseInfo databaseInfo1 = dynamicDataSourceOneService.getDatabaseInfo(id); DatabaseInfo databaseInfo2 = dynamicDataSourceTwoService.getDatabaseInfo(id); System.err.println(&quot;databaseInfo1:===&quot;+JSON.toJSONString(databaseInfo1)); System.err.println(&quot;databaseInfo2:===&quot;+JSON.toJSONString(databaseInfo2)); return &quot;true&quot;; &#125;&#125; 启动类中没有做任何的更改，所以就不展示了 访问接口为：http://localhost:8082/DynamicDataSource/getDatabaseInfo/1（因为数据库准备的时候只准备id为1的数据，所以…）浏览器正常返回： true控制台返回：12databaseInfo1:===&#123;&quot;id&quot;:&quot;1&quot;,&quot;info&quot;:&quot;NO.1&quot;&#125;databaseInfo2:===&#123;&quot;id&quot;:&quot;1&quot;,&quot;info&quot;:&quot;NO.2&quot;&#125; 由显示结果可以看出，我们多数据源已经可以正常使用啦","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://maiyikai.github.io/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://maiyikai.github.io/tags/SpringBoot/"},{"name":"DataSource","slug":"DataSource","permalink":"https://maiyikai.github.io/tags/DataSource/"},{"name":"Mybatis","slug":"Mybatis","permalink":"https://maiyikai.github.io/tags/Mybatis/"}]},{"title":"Spring Boot分表之Shardbatis插件","slug":"1554363529","date":"2019-04-04T15:40:00.000Z","updated":"2019-10-12T12:21:09.264Z","comments":true,"path":"2019/04/04/1554363529/","link":"","permalink":"https://maiyikai.github.io/2019/04/04/1554363529/","excerpt":"随着业务的发展，数据库占用的资源会越来越大；业务对数据库的增删改查操作对数据库来说都是一笔大的开销；另外，由于无法进行分布式式部署，而一台服务器的资源（CPU、磁盘、内存、IO等）是有限的，最终数据库所能承载的数据量、数据处理能力都将遭遇瓶颈。分库分表有两种方式：垂直切分和水平切分","text":"随着业务的发展，数据库占用的资源会越来越大；业务对数据库的增删改查操作对数据库来说都是一笔大的开销；另外，由于无法进行分布式式部署，而一台服务器的资源（CPU、磁盘、内存、IO等）是有限的，最终数据库所能承载的数据量、数据处理能力都将遭遇瓶颈。分库分表有两种方式：垂直切分和水平切分 垂直切分：即将表按照功能模块、关系密切程度划分出来，部署到不同的库上 水平切分：当一个表中的数据量过大时，我们可以把该表的数据按照某种规则进行划分，然后存储到多个结构相同的表，和不同的库上。 ————————–本文讲述分表—————————– 用代码实现分库:使用技术：Spring Boot、Mybatis、Shardbatis使用工具：Idea、MySQL建立在一个Spring Boot项目———-&gt; 创建数据库和表以下为创建的数据库和表,以及添加数据的脚本 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647SET FOREIGN_KEY_CHECKS=0;-- ------------------------------ Table structure for shard_1-- ----------------------------DROP TABLE IF EXISTS `shard_1`;CREATE TABLE `shard_1` ( `id` varchar(11) NOT NULL, `name` varchar(20) NOT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;-- ------------------------------ Records of shard_1-- ----------------------------INSERT INTO `shard_1` VALUES (&apos;1-1&apos;, &apos;shard_1&apos;);-- ------------------------------ Table structure for shard_2-- ----------------------------DROP TABLE IF EXISTS `shard_2`;CREATE TABLE `shard_2` ( `id` varchar(11) NOT NULL, `name` varchar(20) NOT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;-- ------------------------------ Records of shard_2-- ----------------------------INSERT INTO `shard_2` VALUES (&apos;2-1&apos;, &apos;shard_2&apos;);-- ------------------------------ Table structure for tables-- ----------------------------DROP TABLE IF EXISTS `tables`;CREATE TABLE `tables` ( `id` varchar(11) NOT NULL, `tableName` varchar(100) NOT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;-- ------------------------------ Records of tables-- ----------------------------INSERT INTO `tables` VALUES (&apos;1-1&apos;, &apos;shard_1&apos;);INSERT INTO `tables` VALUES (&apos;2-1&apos;, &apos;shard_2&apos;); 引入依赖项目的开始，依赖是不可少的 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.3.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.maiyikai&lt;/groupId&gt; &lt;artifactId&gt;shardbatis&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;shardbatis&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web-services&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.10&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--在idea中不能使用devtools包，因为会导致shardbatis里使用ApplicationContext上下文获取null--&gt; &lt;!--&lt;dependency&gt;--&gt; &lt;!--&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;--&gt; &lt;!--&lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;--&gt; &lt;!--&lt;optional&gt;true&lt;/optional&gt;--&gt; &lt;!--&lt;/dependency&gt;--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;6.0.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.shardbatis&lt;/groupId&gt; &lt;artifactId&gt;shardbatis&lt;/artifactId&gt; &lt;version&gt;2.0.0C&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 建立目录结构目录结构随意 12345678910111213141516171819202122232425262728293031323334353637Shardbatis|--- pom.xml|--- src| |--- main| | |--- java| | | |--- controller| | | | |--- com| | | | | |--- maiyikai| | | | | | |--- shardbatis| | | | | | | |--- controller| | | | | | | | |--- ShardbatisController.java| | | | | | | |--- service| | | | | | | | |--- ShardService.java| | | | | | | | |------ TablesService.java| | | | | | | | |--- impl| | | | | | | | | |--- ShardServiceImpl.java| | | | | | | | | |--- TablesServiceImpl.java| | | | | | | |--- mapper| | | | | | | | |--- ShardMapper.java| | | | | | | | |--- TablesMapper.java| | | | | | | |--- config| | | | | | | | |--- ShardConfiguration.java| | | | | | | |---- entity| | | | | | | | |------ Shard.java| | | | | | | | |--- Tables.java| | | | | | | |-- strategy| | | | | | | | |--- MyShardStrategy.java| | | | | | | |--- tools| | | | | | | | |--- SpringContextAware.java | | | | | | | |--- ShardbatisApplication.java | | |--- resources| | | |--- mapper| | | | |--- shard.xml| | | | |--- tables.xml| | | |--- shard| | | | |--- shard_config.xml| | | |--- application.yml 编写配置文件12345678910111213141516171819202122232425server: port: 8181spring: datasource: druid: url: jdbc:mysql://localhost:3306/shardbatis?useUnicode=true&amp;characterEncoding=UTF8&amp;&amp;serverTimezone=UTC&amp;useSSL=false username: root password: maiyikai min-idle: 5 max-active: 150 max-wait: 60000 pool-prepared-statements: false max-open-prepared-statements: 0 validation-query: select &apos;x&apos; test-while-idle: true test-on-borrow: true test-on-return: false time-between-eviction-runs-millis: 60000 min-evictable-idle-time-millis: 300000 mybatis: mapper-locations: classpath:mapper/*.xmllogging: level: com.maiyikai.shardbatis.mapper: debug # 调试打印sql 开始写代码了直接就是代码 ShardbatisController.java启动代码没什么不需要更改其他的东西 123456789@SpringBootApplication@MapperScan(value = &quot;com.maiyikai.shardbatis.mapper&quot;)//扫描mapper类public class ShardbatisApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ShardbatisApplication.class, args); &#125;&#125; 配置ShardConfiguration.java通过 ShardPlugin.java 源码，ShardPlugin 通过读取属性值 shardingConfig 获取配置文件，所以这个值不能改 12345678910111213@Configurationpublic class ShardConfiguration &#123; @Bean(name = &quot;shardPlugin&quot;) public ShardPlugin shardPlugin()&#123; ShardPlugin shardPlugin = new ShardPlugin(); Properties properties = new Properties(); properties.put(&quot;shardingConfig&quot;, &quot;shard/shard_config.xml&quot;);//文件加载--键值必须为shardingConfig，这是类的内部要求，否则加载失败 shardPlugin.setProperties(properties); return shardPlugin; &#125;&#125; ShardbatisController.java定义接口，使用GetMapping是为了方便使用浏览器访问 1234567891011121314@Controller@RequestMapping(value = &quot;/Shardbatis&quot;)public class ShardbatisController &#123; @Autowired private ShardService shardService; @ResponseBody @GetMapping (value = &quot;/startShard&quot;) public String test(@RequestParam(value = &quot;id&quot;) String id)&#123; return shardService.getName(id); &#125;&#125; ShardServiceImpl.java略过服务类中的代码 123456789101112@Servicepublic class ShardServiceImpl implements ShardService &#123; @Autowired private ShardMapper shardMapper; @Override public String getName(String id) &#123; Shard shard = shardMapper.getShardResult(id);//执行到这条语句时，会被拦截进入到分表策略MyShardStrategy.java中，获取对应的表名称，并且更改sql中的表名 return StringUtils.isEmpty(shard.getName())?null:shard.getName(); &#125;&#125; TablesService.java用于获取对应的表名 1234567891011121314151617@Service(&quot;tablesService&quot;)public class TableServiceImpl implements TablesService &#123; @Autowired private TablesMapper tablesMapper; /** * 因为分表的表名对应的信息存放在tables表中，所以通过这个方法访问，通过对饮的id获取对饮的表名 * @param id * @return */ @Override public String getTableName(String id) &#123; Tables tables = tablesMapper.getTables(id); return StringUtils.isEmpty(tables.getTableName())?null:tables.getTableName(); &#125;&#125; SpringContextAware.java用于普通类可获取ApplicationContext使用，可以通过该applicationContext获取对应的Spring Boot应用中的Bean 1234567891011121314151617@Componentpublic class SpringContextAware implements ApplicationContextAware &#123; private static ApplicationContext applicationContexts;//使用静态，让它存储下来,通过类型即可获取 @Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123; applicationContexts = applicationContext; &#125; public static ApplicationContext getApplicationContexts() &#123; return applicationContexts; &#125; public static &lt;T&gt; T getBean(String name)&#123; return (T) getApplicationContexts().getBean(name); &#125;&#125; MyShardStrategy.java策略类 123456789101112/** * 继承ShardStrategy类 */public class MyShardStrategy implements ShardStrategy &#123; @Override public String getTargetTableName(String baseTableName, Object params, String mapperId) &#123; String id = ((Map&lt;String, String&gt;)params).get(&quot;id&quot;);//解析参数，获取需要的参数 TablesService tablesService = SpringContextAware.getBean(&quot;tablesService&quot;);//获取对应的Bean return tablesService.getTableName(id); &#125;&#125; shard.xml省略mapper类表名一定要和shard_config.xml中配置的表名一致，否则将报错 12345&lt;mapper namespace=&quot;com.maiyikai.shardbatis.mapper.ShardMapper&quot;&gt; &lt;select id=&quot;getShardResult&quot; parameterType=&quot;java.lang.String&quot; resultType=&quot;com.maiyikai.shardbatis.entity.Shard&quot;&gt; SELECT name FROM shard WHERE id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; tables.xml省略mapper类 12345&lt;mapper namespace=&quot;com.maiyikai.shardbatis.mapper.TablesMapper&quot;&gt; &lt;select id=&quot;getTables&quot; parameterType=&quot;java.lang.String&quot; resultType=&quot;com.maiyikai.shardbatis.entity.Tables&quot;&gt; SELECT * FROM tables WHERE id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; shard_config.xml分表策略配置文件ignoreList：忽略集合parseList：解释集合–需要操作的集合strategy：指定tableName对应的strategy 12345678910111213141516171819&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE shardingConfig PUBLIC &quot;-//shardbatis.googlecode.com//DTD Shardbatis 2.0//EN&quot; &quot;http://shardbatis.googlecode.com/dtd/shardbatis-config.dtd&quot;&gt;&lt;shardingConfig&gt; &lt;!-- 忽略不进行分表策略的mapperid-即对应的方法 --&gt; &lt;ignoreList&gt; &lt;value&gt;&lt;/value&gt; &lt;/ignoreList&gt; &lt;!-- 进行分表策略的mapperid-即对应的方法;一定要精确到方法，否则不会被拦截 --&gt; &lt;parseList&gt; &lt;value&gt;com.maiyikai.shardbatis.mapper.ShardMapper.getShardResult&lt;/value&gt; &lt;/parseList&gt; &lt;!-- 指定表使用对应的策略 --&gt; &lt;strategy tableName=&quot;shard&quot; strategyClass=&quot;com.maiyikai.shardbatis.strategy.MyShardStrategy&quot;/&gt;&lt;/shardingConfig&gt; 至此，代码编写完成，执行接口即可进行分表，分表的策略根据业务进行调整 访问路劲:http://localhost:8181/Shardbatis/startShard?id=2-1当id为2-1时 : 返回结果为:shard_2（代表访问的表）当id为1-1时 : 返回结果为shard_1（代表访问的表）","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://maiyikai.github.io/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://maiyikai.github.io/tags/SpringBoot/"},{"name":"Shardbatis","slug":"Shardbatis","permalink":"https://maiyikai.github.io/tags/Shardbatis/"},{"name":"Mybatis","slug":"Mybatis","permalink":"https://maiyikai.github.io/tags/Mybatis/"}]},{"title":"Spring Boot启动原理","slug":"1553480412","date":"2019-03-22T10:20:00.000Z","updated":"2019-10-12T12:21:09.264Z","comments":true,"path":"2019/03/22/1553480412/","link":"","permalink":"https://maiyikai.github.io/2019/03/22/1553480412/","excerpt":"SpringBoot启动原理参考1：Spring Boot的启动过程三：SpringApplication.run()参考2：面试官问我，SpringApplication.run做了哪些事？","text":"SpringBoot启动原理参考1：Spring Boot的启动过程三：SpringApplication.run()参考2：面试官问我，SpringApplication.run做了哪些事？ 如何启动一个SpringBoot应用？123456public class Test&#123; public static void main(String[] args)&#123; SpringApplication springApplication = new SpringApplication(Test.class); springApplication.run(args); &#125;&#125; 解析创建SpringApplication对象源码1SpringApplication构造方法： 123public SpringApplication(Object... sources) &#123; initialize(sources);&#125; 源码2（initialize(…)）初始化SpringAppcation 123456789101112131415private void initialize(Object[] sources) &#123; //保存主配置类 if (sources != null &amp;&amp; sources.length &gt; 0) &#123; this.sources.addAll(Arrays.asList(sources)); &#125; //判断当前应用是否为WEB应用 this.webEnvironment = deduceWebEnvironment(); //通过类路径META-INF/spring.factories文件获取ApplicationContextInitializer类型的实例，并保存 setInitializers((Collection) getSpringFactoriesInstances( ApplicationContextInitializer.class)); //通过类路径META-INF/spring.factories文件获取ApplicationListener类型的实例，并保存 setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class)); //从多个配置类中找到有main方法的主配置类 this.mainApplicationClass = deduceMainApplicationClass();&#125; 源码3 getSpringFactoriesInstances（…）获取通过META-INF/spring.factories文件获取到的对应的类路径下的实例 123456789101112131415161718//通过类路径META-INF/spring.factories文件获取ApplicationContextInitializer类型的实例private &lt;T&gt; Collection&lt;? extends T&gt; getSpringFactoriesInstances(Class&lt;T&gt; type) &#123; return getSpringFactoriesInstances(type, new Class&lt;?&gt;[] &#123;&#125;);&#125; private &lt;T&gt; Collection&lt;? extends T&gt; getSpringFactoriesInstances(Class&lt;T&gt; type, Class&lt;?&gt;[] parameterTypes, Object... args) &#123; ClassLoader classLoader = Thread.currentThread().getContextClassLoader(); // Use names and ensure unique to protect against duplicates //通过类路径META-INF/spring.factories文件获取ApplicationContextInitializer.class类型的类名 Set&lt;String&gt; names = new LinkedHashSet&lt;String&gt;( SpringFactoriesLoader.loadFactoryNames(type, classLoader)); //获取实例 List&lt;T&gt; instances = createSpringFactoriesInstances(type, parameterTypes, classLoader, args, names); AnnotationAwareOrderComparator.sort(instances); return instances;&#125; 源码4(deduceMainApplicationClass())从运行类的堆栈中获取含有main方法的类 123456789101112131415//从运行类的堆栈中获取含有main方法的类private Class&lt;?&gt; deduceMainApplicationClass() &#123; try &#123; StackTraceElement[] stackTrace = new RuntimeException().getStackTrace(); for (StackTraceElement stackTraceElement : stackTrace) &#123; if (&quot;main&quot;.equals(stackTraceElement.getMethodName())) &#123; return Class.forName(stackTraceElement.getClassName()); &#125; &#125; &#125; catch (ClassNotFoundException ex) &#123; // Swallow and continue &#125; return null;&#125; 解析springApplication.run(args)源码1(run(…))run方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public ConfigurableApplicationContext run(String... args) &#123; //跑马灯对象--用于记录运行时间 StopWatch stopWatch = new StopWatch(); stopWatch.start(); ConfigurableApplicationContext context = null; FailureAnalyzers analyzers = null; configureHeadlessProperty(); //通过META-INF/spring.factories获取SpringApplicationRunListener类型的实例 SpringApplicationRunListeners listeners = getRunListeners(args); //遍历回调SpringApplicationRunListener的starting方法--既启动监听器 listeners.starting(); try &#123; //封装命令行参数 ApplicationArguments applicationArguments = new DefaultApplicationArguments( args); //环境准备，完成后遍历回调SpringApplicationRunListener的environmentPrepared方法对监听器配置环境 ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments); //打印Banner-既控制台显示的Spring.... Banner printedBanner = printBanner(environment); //根据创建的环境判断，是创建web容器，还是普通的IOC容器 context = createApplicationContext(); //注册异常分析器 analyzers = new FailureAnalyzers(context); //准备上下文 //遍历回调ApplicationContextInitializer的initialize事件 //遍历回调SpringApplicationRunListeners中的contextPrepared事件 //环境准备完成之后，遍历回调SpringApplicationRunListeners中的contextLoaded事件 prepareContext(context, environment, listeners, applicationArguments, printedBanner); //刷新上下文，初始化所有自动配置类 refreshContext(context); //遍历所有注册的ApplicationRunner和CommandLineRunner，并执行其run()方法 afterRefresh(context, applicationArguments); //调用所有的SpringApplicationRunListener的finished()方法，广播SpringBoot已经完成了ApplicationContext初始化的全部过程 listeners.finished(context, null); stopWatch.stop(); if (this.logStartupInfo) &#123; new StartupInfoLogger(this.mainApplicationClass) .logStarted(getApplicationLog(), stopWatch); &#125; return context; &#125; catch (Throwable ex) &#123; handleRunFailure(context, listeners, analyzers, ex); throw new IllegalStateException(ex); &#125;&#125; 源码2(getRunListeners(…))通过类路径META-INF/spring.factories文件获取ApplicationContextInitializer类型的实例，并将其封装到SpringApplicationRunListeners实例 1234567//创建实例 SpringApplicationRunListenersprivate SpringApplicationRunListeners getRunListeners(String[] args) &#123; Class&lt;?&gt;[] types = new Class&lt;?&gt;[] &#123; SpringApplication.class, String[].class &#125;; //通过META-INF/spring.factories获取SpringApplicationRunListener类型的实例 return new SpringApplicationRunListeners(logger, getSpringFactoriesInstances( SpringApplicationRunListener.class, types, this, args));&#125; 源码3(prepareEnvironment(…))准备环境 1234567891011121314151617//准备环境private ConfigurableEnvironment prepareEnvironment( SpringApplicationRunListeners listeners, ApplicationArguments applicationArguments) &#123; // Create and configure the environment //创建环境 ConfigurableEnvironment environment = getOrCreateEnvironment(); //配置环境 configureEnvironment(environment, applicationArguments.getSourceArgs()); //遍历回调SpringApplicationRunListener的environmentPrepared方法 listeners.environmentPrepared(environment); if (!this.webEnvironment) &#123; environment = new EnvironmentConverter(getClassLoader()) .convertToStandardEnvironmentIfNecessary(environment); &#125; return environment;&#125; 源码4(createApplicationContext())根据创建的环境判断，是创建web容器，还是普通的IOC容器 1234567891011121314151617//根据创建的环境判断，是创建web容器，还是普通的IOC容器protected ConfigurableApplicationContext createApplicationContext() &#123; Class&lt;?&gt; contextClass = this.applicationContextClass; if (contextClass == null) &#123; try &#123; contextClass = Class.forName(this.webEnvironment ? DEFAULT_WEB_CONTEXT_CLASS : DEFAULT_CONTEXT_CLASS); &#125; catch (ClassNotFoundException ex) &#123; throw new IllegalStateException( &quot;Unable create a default ApplicationContext, &quot; + &quot;please specify an ApplicationContextClass&quot;, ex); &#125; &#125; return (ConfigurableApplicationContext) BeanUtils.instantiate(contextClass);&#125; 源码5(prepareContext(…))准备上下文 123456789101112131415161718192021222324252627282930//准备上下文private void prepareContext(ConfigurableApplicationContext context, ConfigurableEnvironment environment, SpringApplicationRunListeners listeners, ApplicationArguments applicationArguments, Banner printedBanner) &#123; //设置环境 context.setEnvironment(environment); postProcessApplicationContext(context); //遍历回调ApplicationContextInitializer的initialize事件--即上下文注入并初始化 applyInitializers(context); //遍历回调SpringApplicationRunListeners中的contextPrepared事件--即上下注入 listeners.contextPrepared(context); if (this.logStartupInfo) &#123; logStartupInfo(context.getParent() == null); logStartupProfileInfo(context); &#125; // Add boot specific singleton beans context.getBeanFactory().registerSingleton(&quot;springApplicationArguments&quot;, applicationArguments); if (printedBanner != null) &#123; context.getBeanFactory().registerSingleton(&quot;springBootBanner&quot;, printedBanner); &#125; // Load the sources Set&lt;Object&gt; sources = getSources(); Assert.notEmpty(sources, &quot;Sources must not be empty&quot;); load(context, sources.toArray(new Object[sources.size()])); //遍历回调SpringApplicationRunListeners中的contextLoaded事件--即加载上下文 listeners.contextLoaded(context);&#125; 综上，SpringApplication.run()总共做了两件是： 创建了SpringApplication对象，初始化的时候，判断是否为WEB应用，并将通过配置文件META-INF/spring.factories找到对应的上下文类路径和监听器路径，将其实例化并且保存起来。 运行run方法，通过配置文件META-INF/spring.factories找到对应的监听器路径，将其实例化并启动。创建环境和创建上下文，并为监听器配置。刷新上下文，然后调用所有的监听器的finished()方法，广播SpringBoot已经完成了。","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://maiyikai.github.io/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://maiyikai.github.io/tags/SpringBoot/"}]},{"title":"怒怼HashMap","slug":"1552012657","date":"2019-03-08T10:00:00.000Z","updated":"2019-10-12T12:21:09.263Z","comments":true,"path":"2019/03/08/1552012657/","link":"","permalink":"https://maiyikai.github.io/2019/03/08/1552012657/","excerpt":"本文呈现HashMap工作原理，和关于HashTable、ConcurrentHashMap的区别一起来揭晓吧… …","text":"本文呈现HashMap工作原理，和关于HashTable、ConcurrentHashMap的区别一起来揭晓吧… … 什么是HashMap? HashMap采用了“数组+链表+红黑树”的数据结构，能在查询和修改的时候继承了数组的线性查找和链表的寻址修改。 存储方式是以键值对的方式进行存储(即:key-value)，HashMap可以存储为Null的键于值，而HashTable不支持（通过查看源码可知，HashTable获取的键值对分别是两个对象，判断对象为Null就抛异常；而HashMap则是通过处理，所以支持） HashMap是非线程安全的，HashTable是线程安全的，所以HashMap效率比较快 HashMap的工作原理？ HashMap基于hashing的原理，我们使用put(key, value)存储对象到HashMap，使用get(key)从HashMap对象中获取对象。当我们调用put()方法时，会先对key调用hashCode()，计算并返回hashCode用于在Map中找到对应的bucket位置存储Node对象。 HashMap的初始长度为16 HashMap负载因子为0.75 当HashMap的容量达到16*0.75=12时，就需要HashMap扩容，即扩容为原来的2倍,来重新调整map的大小，并将原来的对象放入新的bucket数组中。这个过程叫作rehashing，因为它调用hash方法找到新的bucket位置。 如果链表长度超过阀值( TREEIFY THRESHOLD==8)，就把链表转成红黑树，链表长度低于6，就把红黑树转回链表 如果两个对象的hashCode一致，会有什么后果？因为HashMap的存储器的对象是通过key的hashCode来确认应该存放在哪一个bucket的位置，由于hashCode一致，所以会找到同一个bucket的位置，并将对象以链表的形势存放在这个bucket位置下 如果发生了碰撞，应该如何通过key取到值对象？当我们调用get(key)方法时，会通过key计算其hahshCode，找到对应的bucket位置，再通过调用key.equals()方法在链表中找到正确的节点，最终找到值对象。 减少碰撞的方法？ 扰动函数可以减少碰撞，原理是如果两个不相等的对象返回不同的hashcode的话，那么碰撞的几率就会小些，这就意味着存链表结构减小，这样取值的话就不会频繁调用equal方法，这样就能提高HashMap的性能。（扰动即Hash方法内部的算法实现，目的是让不同对象返回不同hashcode。） 使用不可变的、声明作final的对象，并且采用合适的equals()和hashCode()方法的话，将会减少碰撞的发生。不可变性使得能够缓存不同键的hashcode，这将提高整个获取对象的速度，使用String，Interger这样的wrapper类作为键是非常好的选择。为什么String, Interger这样的wrapper类适合作为键？因为String是final的，而且已经重写了equals()和hashCode()方法了。不可变性是必要的，因为为了要计算hashCode()，就要防止键值改变，如果键值在放入时和获取时返回不同的hashcode的话，那么就不能从HashMap中找到你想要的对象。 HashMap中hash函数怎么实现？ key hash null 0 not null h = key.hashCode(); hash = h ^ (h &gt;&gt;&gt; 16); 因为HashMap支持键为null，所以有两组算法 如何计算HashMap的下标？ 假设HashMap的数组长度为len 假设键的hashCode为 hash = key.hashCode() 下标: (len - 1) &amp; (hash ^ (hash &gt;&gt;&gt; 16)) 重新调整HashMap大小存在什么问题吗？当多线程的情况下，可能产生条件竞争。当重新调整HashMap大小的时候，确实存在条件竞争，如果两个线程都发现HashMap需要重新调整大小了，它们会同时试着调整大小。在调整大小的过程中，存储在链表中的元素的次序会反过来，因为移动到新的数组位置的时候，HashMap并不会将元素放在LinkedList的尾部，而是放在头部，这是为了避免尾部遍历(tail traversing)。如果条件竞争发生了，那么就死循环了 为什么选用红黑树，而不选用二叉查找树？之所以选择红黑树是为了解决二叉查找树的缺陷，二叉查找树在特殊情况下会变成一条线性结构（这就跟原来使用链表结构一样了，造成很深的问题），遍历查找会非常慢。而红黑树在插入新数据后可能需要通过左旋，右旋、变色这些操作来保持平衡，引入红黑树就是为了查找数据快，解决链表查询深度的问题，我们知道红黑树属于平衡二叉树，但是为了保持“平衡”是需要付出代价的，但是该代价所损耗的资源要比遍历线性链表要少，所以当长度大于8的时候，会使用红黑树，如果链表长度很短的话，根本不需要引入红黑树，引入反而会慢。 红黑树的特性（摘抄维基百科） 节点是红色或黑色。 根是黑色。 所有叶子都是黑色（叶子是NIL节点）。 每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。） 从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。 HashMap和HashTable的区别？ hash值得计算不一样 HashMap： (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16) HashTable: h = key.hashCode() 下标计算不一样 HashMap: (tableLength -1) &amp; (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16) HashTable: ((h = key.hashCode()) &amp; 0x7FFFFFFF) % tableLength HashMap是非线程安全，HashTable是线程安全的。 单线程使用情况下，HashMap的效率会更快 负载因子是相同的：0.75 默认大小和扩容方案不一样： HashMap: 默认大小为16， 扩容：tableLength * 2 HashTable: 默认大小为11， 扩容： tableLength * 2 + 1 HashTable对每个方法都添加了synchronized关键字 ConcurrentHashMap hash计算: h = key.hashCode(); (h ^ (h &gt;&gt;&gt; 16) &amp; 0x7fffffff) 下标计算: i = (tableLength - 1) &amp; hash 初始值16 负载因子：0.75 当ConcurrentHashMap的容量达到16*0.75=12时，就需要ConcurrentHashMap扩容 ConcurrentHashMap采用了分段锁技术，线程安全","categories":[{"name":"Java","slug":"Java","permalink":"https://maiyikai.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://maiyikai.github.io/tags/Java/"},{"name":"HashMap","slug":"HashMap","permalink":"https://maiyikai.github.io/tags/HashMap/"}]},{"title":"技术区别汇总整理","slug":"1548754788","date":"2019-02-19T10:00:00.000Z","updated":"2019-10-12T12:21:09.263Z","comments":true,"path":"2019/02/19/1548754788/","link":"","permalink":"https://maiyikai.github.io/2019/02/19/1548754788/","excerpt":"为了新工作面试，进行技术对比整理包含内容： Spring、Spring Boot、Mybatis、Ibatis、Hibernate、Mysql、Oracle、Redis、MongoDB、FastJson、Gson（后续会增加）","text":"为了新工作面试，进行技术对比整理包含内容： Spring、Spring Boot、Mybatis、Ibatis、Hibernate、Mysql、Oracle、Redis、MongoDB、FastJson、Gson（后续会增加） Spring Boot和Spring的区别 Spring Boot是Spring开源组织下的子项目，是Spring组件一站式解决方案，主要简化了Spring的难度，简省了繁重的配置，提供了各种start(启动器)。 SpringBoot内置了内置了Tomcat/Jetty等容器，而且内嵌了各种servlet容器，Spring Boot只要打成一个可执行的jar包就能独立运行，而Spring只能包为war包，然后将其放置在可执行的服务器容器中执行。 Spring Boot提供一系列端点可以监控服务及应用，做健康检测。 Spring 最初利用“工厂模式”（ DI ）和“代理模式”（ AOP ）解耦应用组件。大家觉得挺好用，于是按照这种模式搞了一个 MVC 框架（一些用 Spring 解耦的组件），用开发 web 应用（ SpringMVC ）。然后有发现每次开发都要搞很多依赖，写很多样板代码很麻烦，于是搞了一些懒人整合包（ starter ），这套就是 Spring Boot 。 Mybatis和Ibatis区别 相同点： 都是dao层框架 都有SqlMapConfig.xml文件和dao层编写sql语句的xml文件 都需要配置数据源 都使用了jdbc事务 都可以为实体类起别名 映射文件中都可以写sql语句，都有namespace命名空间 不同点： Ibatis中 在标签中编写sql语句，并且可以给实体类起别名 接受参数方式是使用#参数#或者$参数$ 参数类型是用parameterClass，返回值类型是用resultClass Mybatis中 在中编写sql语句，并且不能在mapper中给实体类起别名 接收参数的方式是使用#{参数}或者${参数}（ONGL表达式） 参数类型用的是parameterType，返回值类型用的是resultType 支持使用注解方式直接在Mapper接口上编写sql dao层中 ibatis中如果定义接口需要实现接口，并且在实现类中需要读取配置文件，得到sqlMapClient对象才能使用对应的方法 Mybaits中只需要定义接口，然后在命名空间中连接上接口路径就可以使用 Mybatis和Hibernate的区别（网摘）第一方面：开发速度的对比就开发速度而言，Hibernate的真正掌握要比Mybatis来得难些。Mybatis框架相对简单很容易上手，但也相对简陋些。个人觉得要用好Mybatis还是首先要先理解好Hibernate。 比起两者的开发速度，不仅仅要考虑到两者的特性及性能，更要根据项目需求去考虑究竟哪一个更适合项目开发，比如：一个项目中用到的复杂查询基本没有，就是简单的增删改查，这样选择hibernate效率就很快了，因为基本的sql语句已经被封装好了，根本不需要你去写sql语句，这就节省了大量的时间，但是对于一个大型项目，复杂语句较多，这样再去选择hibernate就不是一个太好的选择，选择mybatis就会加快许多，而且语句的管理也比较方便。 数据库切换：当从MySQL迁移到Oracle时，SQL也会相应的进行更改。因为Mybatis的SQL是开发人员自己编写的，所以在迁移数据库时，要对SQL进行对应的更改。而Hibernate在配置的时候指定了数据库，如果要切换数据库时，只需更改配置即可，也就是说Hibernate支持多种数据的语言，不需要对其进行大的更改。 第二方面：开发工作量的对比Hibernate和MyBatis都有相应的代码生成工具。可以生成简单基本的DAO层方法。针对高级查询，Mybatis需要手动编写SQL语句，以及ResultMap。而Hibernate有良好的映射机制，开发者无需关心SQL的生成与结果映射，可以更专注于业务流程。 第三方面：sql优化方面Hibernate的查询会将表中的所有字段查询出来，这一点会有性能消耗。Hibernate也可以自己写SQL来指定需要查询的字段，但这样就破坏了Hibernate开发的简洁性。而Mybatis的SQL是手动编写的，所以可以按需求指定查询的字段。 Hibernate HQL语句的调优需要将SQL打印出来，而Hibernate的SQL被很多人嫌弃因为太丑了。MyBatis的SQL是自己手动写的所以调整方便。但Hibernate具有自己的日志统计。Mybatis本身不带日志统计，使用Log4j进行日志记录。 第四方面：对象管理的对比Hibernate 是完整的对象/关系映射解决方案，它提供了对象状态管理（state management）的功能，使开发者不再需要理会底层数据库系统的细节。也就是说，相对于常见的 JDBC/SQL 持久层方案中需要管理 SQL 语句，Hibernate采用了更自然的面向对象的视角来持久化 Java 应用中的数据。 换句话说，使用 Hibernate 的开发者应该总是关注对象的状态（state），不必考虑 SQL 语句的执行。这部分细节已经由 Hibernate 掌管妥当，只有开发者在进行系统性能调优的时候才需要进行了解。而MyBatis在这一块没有文档说明，用户需要对对象自己进行详细的管理。 第五方面：缓存机制 Hibernate缓存 Hibernate一级缓存是Session缓存，利用好一级缓存就需要对Session的生命周期进行管理好。建议在一个Action操作中使用一个Session。一级缓存需要对Session进行严格管理。 Hibernate二级缓存是SessionFactory级的缓存。 SessionFactory的缓存分为内置缓存和外置缓存。内置缓存中存放的是SessionFactory对象的一些集合属性包含的数据(映射元素据及预定SQL语句等),对于应用程序来说,它是只读的。外置缓存中存放的是数据库数据的副本,其作用和一级缓存类似.二级缓存除了以内存作为存储介质外,还可以选用硬盘等外部存储设备。二级缓存称为进程级缓存或SessionFactory级缓存，它可以被所有session共享，它的生命周期伴随着SessionFactory的生命周期存在和消亡。 MyBatis缓存 MyBatis 包含一个非常强大的查询缓存特性,它可以非常方便地配置和定制。MyBatis 3 中的缓存实现的很多改进都已经实现了,使得它更加强大而且易于配置。 默认情况下是没有开启缓存的,除了局部的 session 缓存,可以增强变现而且处理循环 依赖也是必须的。要开启二级缓存,你需要在你的 SQL 映射文件中添加一行: 字面上看就是这样。这个简单语句的效果如下: 映射语句文件中的所有 select 语句将会被缓存。 映射语句文件中的所有 insert,update 和 delete 语句会刷新缓存。 缓存会使用 Least Recently Used(LRU,最近最少使用的)算法来收回。 根据时间表(比如 no Flush Interval,没有刷新间隔), 缓存不会以任何时间顺序 来刷新。 缓存会存储列表集合或对象(无论查询方法返回什么)的 1024 个引用。 缓存会被视为是 read/write(可读/可写)的缓存,意味着对象检索不是共享的,而 且可以安全地被调用者修改,而不干扰其他调用者或线程所做的潜在修改。 所有的这些属性都可以通过缓存元素的属性来修改。 比如: 这个更高级的配置创建了一个 FIFO 缓存,并每隔 60 秒刷新,存数结果对象或列表的 512 个引用,而且返回的对象被认为是只读的,因此在不同线程中的调用者之间修改它们会导致冲突。可用的收回策略有, 默认的是 LRU: LRU – 最近最少使用的:移除最长时间不被使用的对象。 FIFO – 先进先出:按对象进入缓存的顺序来移除它们。 SOFT – 软引用:移除基于垃圾回收器状态和软引用规则的对象。 WEAK – 弱引用:更积极地移除基于垃圾收集器状态和弱引用规则的对象。 flushInterval(刷新间隔)可以被设置为任意的正整数,而且它们代表一个合理的毫秒 形式的时间段。默认情况是不设置,也就是没有刷新间隔,缓存仅仅调用语句时刷新。 size(引用数目)可以被设置为任意正整数,要记住你缓存的对象数目和你运行环境的 可用内存资源数目。默认值是1024。 readOnly(只读)属性可以被设置为 true 或 false。只读的缓存会给所有调用者返回缓 存对象的相同实例。因此这些对象不能被修改。这提供了很重要的性能优势。可读写的缓存 会返回缓存对象的拷贝(通过序列化) 。这会慢一些,但是安全,因此默认是 false。 相同点：Hibernate和Mybatis的二级缓存除了采用系统默认的缓存机制外，都可以通过实现你自己的缓存或为其他第三方缓存方案，创建适配器来完全覆盖缓存行为。 不同点 Hibernate的二级缓存配置在SessionFactory生成的配置文件中进行详细配置，然后再在具体的表-对象映射中配置是那种缓存。 MyBatis的二级缓存配置都是在每个具体的表-对象映射中进行详细配置，这样针对不同的表可以自定义不同的缓存机制。并且Mybatis可以在命名空间中共享相同的缓存配置和实例，通过Cache-ref来实现。 两者比较 Hibernate: Hibernate对查询对象有着良好的管理机制，用户无需关心SQL。所以在使用二级缓存时如果出现脏数据，系统会报出错误并提示。 MyBatis: MyBatis在这一方面，使用二级缓存时需要特别小心。如果不能完全确定数据更新操作的波及范围，避免Cache的盲目使用。否则，脏数据的出现会给系统的正常运行带来很大的隐患。 第六方面：总结*相同点：Hibernate与MyBatis都可以是通过SessionFactoryBuider由XML配置文件生成SessionFactory，然后由SessionFactory 生成Session，最后由Session来开启执行事务和SQL语句。其中SessionFactoryBuider，SessionFactory，Session的生命周期都是差不多的。 Hibernate和MyBatis都支持JDBC和JTA事务处理。 Mybatis优势 MyBatis可以进行更为细致的SQL优化，可以减少查询字段。 MyBatis容易掌握，而Hibernate门槛较高。 Hibernate优势 Hibernate的DAO层开发比MyBatis简单，Mybatis需要维护SQL和结果映射。 Hibernate对对象的维护和缓存要比MyBatis好，对增删改查的对象的维护要方便。 Hibernate数据库移植性很好，MyBatis的数据库移植性不好，不同的数据库需要写不同SQL。 Hibernate有更好的二级缓存机制，可以使用第三方缓存。MyBatis本身提供的缓存机制不佳。 Mysql和oracle区别 Oracle是大型数据库，MySQL是中小型数据库 Oracle是收费的，MySQL是开源的 Oracle支持大并发、大访问量，是OLTP最好的工具（On-Line Transaction Processing联机事务处理过程） Oracle所需空间比较大，MySQL比较小 使用的时候Oracle占用特别大的内存空间和其他机器性能 Oracle也Mysql操作上的区别 主键 MYSQL有自动增长的数据类型，在创建表时只要指定表的主键为auto increment,插入记录时，不需要再指定该记录的主键值，Mysql将自动增长。ORACLE没有自动增长的数据类型，需要建立一个自动增长的序列号，插入记录时要把序列号的下一个值赋于此字段。 单引号的处理 MYSQL里可以用双引号包起字符串，ORACLE里只可以用单引号包起字符串。在插入和修改字符串前必须做单引号的替换：把所有出现的一个单引号替换成两个单引号。 翻页的SQL语句的处理 MYSQL处理翻页的SQL语句比较简单，用LIMIT 开始位置, 记录个数；ORACLE处理翻页的SQL语句就比较繁琐了。每个结果集只有一个ROWNUM字段标明它的位置, 并且只能用 ROWNUM&lt;100, 不能用ROWNUM&gt;80 长字符串的处理 长字符串的处理ORACLE也有它特殊的地方。INSERT和UPDATE时最大可操作的字符串长度小于等于4000个单字节, 如果要插入更长的字符串, 请考虑字段用CLOB类型，方法借用 ORACLE里自带的DBMS_LOB程序包。插入修改记录前一定要做进行非空和长度判断，不能为空的字段值和超出长度字段值都应该提出警告,返回上次操作。 空字符的处理 MYSQL的非空字段也有空的内容，ORACLE里定义了非空字段就不容许有空的内容。按MYSQL的NOT NULL来定义ORACLE表结构, 导数据的时候会产生错误。因此导数据时要对空字符进行判断，如果为NULL或空字符，需要把它改成一个空格的字符串。 字符串的模糊比较 MYSQL里用 字段名 like ‘%字符串%’,ORACLE里也可以用 字段名 like ‘%字符串%’ 但这种方法不能使用索引, 速度不快。用字符串比较函数 instr(字段名,’字符串’)&gt;0 会得到更精确的查找结果。 日期字段的处理 MYSQL日期字段分DATE和TIME两种，ORACLE日期字段只有DATE，包含年月日时分秒信息，用当前数据库的系统时间为SYSDATE, 精确到秒，或者用字符串转换成日期型函数TO_DATE(‘&lt;st1:chsdate isrocdate=”False” islunardate=”False” day=”1” month=”8” year=”2001”&gt;2001-08-01&lt;/st1:chsdate&gt;’,’YYYY-MM-DD’)年-月-日 24小时:分钟:秒 的格式YYYY-MM-DD HH24:MI:SS TO_DATE()还有很多种日期格式, 可以参看ORACLE DOC.日期型字段转换成字符串函数TO_CHAR(‘&lt;st1:chsdate isrocdate=”False” islunardate=”False” day=”1” month=”8” year=”2001”&gt;2001-08-01&lt;/st1:chsdate&gt;’,’YYYY-MM-DD HH24:MI:SS’) 日期字段的数学运算公式有很大的不同。MYSQL找到离当前时间7天用 DATE_FIELD_NAME &gt; SUBDATE（NOW（），INTERVAL 7 DAY）ORACLE找到离当前时间7天用 DATE_FIELD_NAME &gt;SYSDATE - 7; 对于事务的支持 这一点也是大家经常说到的，MySQL对于事务默认是不支持的，只有某些存储引擎中如：innodb可以支持。而Oracle对于事务是完全支持，不管是OLTP还是OLAT都是支持的 MySQL是单进程多线程，Oracle是多进程（在Windows下也是单进程） 数据库和实例以及用户之间的关系。我们知道用户操作数据库不管MySQL还是Oracle都是通过实例来的，那么实例和数据库、数据库软件以及用户之间是什么关系呢?在MySQL和Oracle的情况下我们来分别讲解下： 首先MySQL的实例是用户登录是系统分配给用户的，而用户必须是先在MySQL中创建好，然后登陆用户mysql -u user_name -p然后使用show databases; 命令查看数据库，在使用 use database_name database; 选择数据库,这样才可以对数据库进行操作。简单的关系就是：instance &gt; database 其次是Oracle，Oracle的实例是在创建数据库时就默认创建好的，而用户基于数据库实例，实例之间可以没有关系所以其中的用户也不尽相同，你登录不同的实例就相当于登录了不同的数据库，登陆的命令也能简单sqlplus user_name/password@IP:port/instance_name 其中可以把IP地址，端口号，实例名写在一个TNS文件中取一个别名，登陆的时候输入这个别名就行了。简单的关系就是：instance = database MySQL、Redis和MongoDB的区别 数据库类型 关系型数据库 MySQL 非关系型数据库 Redis MongoDB 储存位置 MySQL 数据和索引都存放在硬盘中，只有要使用的时候才会存放到内存，所以MySQL可以存放源大于内存容量的数据 Redis Redis所有数据都存放在内存中，是一个不折不扣的内存数据库 MongoDB 内存数据库，数据都是存放在内存里面。对数据的操作大部分都在内存中，但mongodb并不是单纯的内存数据库。 事务 MySQL 部分引擎的存储方式支持事务 如：Innodb存储引擎 Redis、MongoDB 不支持事务 持久化 持久化（Persistence），即把数据（如内存中的对象）保存到可永久保存的存储设备中（如磁盘）。持久化的主要应用是将内存中的对象存储在数据库中，或者存储在磁盘文件中、XML数据文件中等等。 Redis 使用RDB方式和AOF方式 RDB持久化也分两种：SAVE和BGSAVE SAVE是阻塞式的RDB持久化，当执行这个命令时redis的主进程把内存里的数据库状态写入到RDB文件中，直到该文件创建完毕的这段时间内redis将不能处理任何命令请求。 BGSAVE属于非阻塞式的持久化，它会创建一个子进程专门去把内存中的数据库状态写入RDB文件里，同时主进程还可以处理来自客户端的命令请求。但子进程基本是复制的父进程，这等于两个相同大小的redis进程在系统上运行，会造成内存使用率的大幅增加。 AOF 与RDB的保存整个redis数据库状态不同，AOF是通过保存对redis服务端的写命令（如set、sadd、rpush）来记录数据库状态的，即保存你对redis数据库的写操作 MongoDB MongoDB的所有数据实际上是存放在硬盘的，所有要操作的数据通过mmap的方式映射到内存某个区域内。然后，MongoDB就在这块区域里面进行数据修改，避免了零碎的硬盘操作。至于mmap上的内容flush到硬盘就是操作系统的事情了，所以，如果，MongoDB在内存中修改了数据后，mmap数据flush到硬盘之前，系统宕机了，数据就会丢失。 MongoDB持久化原理：MongoDB在启动时，专门初始化一个线程不断循环（除非应用crash掉），用于在一定时间周期内来从defer队列中获取要持久化的数据并写入到磁盘的journal(日志)和mongofile(数据)处，当然因为它不是在用户添加记录时就写到磁盘上，所以按MongoDB开发者说，它不会造成性能上的损耗，因为看过代码发现，当进行CUD操作时，记录(Record类型)都被放入到defer队列中以供延时批量（groupcommit）提交写入，但相信其中时间周期参数是个要认真考量的参数，系统为90毫秒，如果该值更低的话，可能会造成频繁磁盘操作，过高又会造成系统宕机时数据丢失过。 集群 全部支持 数据量和性能的比较 当物理内存够用的时候，Redis &gt; MongoDB &gt; MySQL 当物理内存不够用的时候，Redis 和 MongoDB 都会使用虚拟内存。 实际上如果Redis要开始虚拟内存，那很明显要么加内存条，要么你就该换个数据库了。 但是，MongoDB 不一样，只要，业务上能保证，冷热数据的读写比，使得热数据在物理内存中，mmap 的交换较少。 MongoDB 还是能够保证性能。有人使用 MongoDB 存储了上T的数据。 MySQL，MySQL根本就不需要担心数据量跟内存下的关系。不过，内存的量跟热数据的关系会极大地影响性能表现。 当物理内存和虚拟内存都不够用的时候，估计除了 MySQL 你没什么好选择了。 其实，从数据存储原理来看，我更倾向于将 MongoDB 归类为硬盘数据库，但是使用了 mmap 作为加速的手段而已。 简说mmap mmap系统调用并不是完全为了用于共享内存而设计的。它本身提供了不同于一般对普通文件的访问方式，进程可以像读写内存一样对普通文件进行操作。 mmap 系统调用使得进程之间通过映射同一个普通文件实现共享内存。普通文件被映射到进程地址空间后，进程可以像访问普通内存一样对文件进行访问，不必再调用。 read()，write（）等操作。mmap并不分配空间, 只是将文件映射到调用进程的地址空间里, 然后你就可以用memcpy等操作写文件, 而不用write()了.写完后用msync()同步一下, 你所写的内容就保存到文件里了. 不过这种方式没办法增加文件的长度, 因为要映射的长度在调用mmap()的时候就决定了。 优缺点 MySQL 优点 体积小、速度快、总体拥有成本低，开源，提供的接口支持多种语言连接操作。 支持多种操作系统。 MySQL 的核心程序采用完全的多线程编程。线程是轻量级的进程，它可以灵活地为用户提供服务，而不过多的系统资源。用多线程和C语言实现的MySQL 能很容易充分利用CPU。 MySQL 有一个非常灵活而且安全的权限和口令系统。当客户与MySQL 服务器连接时，他们之间所有的口令传送被加密，而且MySQL 支持主机认证。 MySQL 能够提供很多不同的使用者界面，包括命令行客户端操作，网页浏览器，以及各式各样的程序语言界面，例如 C++，Perl，Java，PHP，以及Python。你可以使用事先包装好的客户端，或者干脆自己写一个合适的应用程序。MySQL可用于 Unix，Windows，以及OS/2等平台，因此它可以用在个人电脑或者是服务器上。 缺点 不支持热备份。 MySQL不支持自定义数据类型。 MySQL最大的缺点是其安全系统，主要是复杂而非标准，另外只有到调用mysqladmin来重读用户权限时才发生改变。 MySQL对存储过程和触发器支持不够良好。 尽管 MySQL 理论上仍是开源产品，也有人抱怨它诞生之后更新缓慢。然而，应该注意到有一些基于 MySQL 并完整集成的数据库（如 MariaDB），在标准的 MySQL 基础上带来了额外价值。 MySQL对XML支持不够良好。 Redis 优点 读写性能优异。 支持数据持久化，支持 AOF 和 RDB 两种持久化方式。 支持主从复制，主机会自动将数据同步到从机，可以进行读写分离。 数据结构丰富:数据结构丰富:支持 string、hash、set、sortedset、list 等数据结构。 缺点 Redis 不具备自动容错和恢复功能，主机从机的宕机都会导致前端部分读写请求失败，需要等待机器重启或者手动切换前端的 IP 才能恢复。 主机宕机，宕机前有部分数据未能及时同步到从机，切换 IP 后还会引入数据不一致的问题，降低了系统的可用性。 Redis 的主从复制采用全量复制，复制过程中主机会 fork 出一个子进程对内存做一份快照， 并将子进程的内存快照保存为文件发送给从机，这一过程需要确保主机有足够多的空余内存。若快照文件较大，对集群的服务能力会产生较大的影响，而且复制过程是在从机新加入 集群或者从机和主机网络断开重连时都会进行，也就是网络波动都会造成主机和从机间的一 次全量的数据复制，这对实际的系统运营造成了不小的麻烦。 Redis 较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。为避免这一问题，运维人员在系统上线时必须确保有足够的空间，这对资源造成了很大的浪费。 MongoDB 优点 弱一致性(最终一致)，更能保证用户的访问速度。 文档结构的存储方式，能够更便捷的获取数。 内置 GridFS，高效存储二进制大对象 (比如照片和视频)。 内置Sharding。提供基于Range的Auto Sharding机制：一个collection可按照记录的范围，分成若干个段，切分到不同的Shard上。 第三方支持丰富。(这是与其他的NoSQL相比，MongoDB也具有的优势)。 性能优越：在使用场合下，千万级别的文档对象，近10G的数据，对有索引的ID的查询不会比mysql慢，而对非索引字段的查询，则是全面胜出。 缺点 mongodb不支持事务操作。所以事务要求严格的系统（如果银行系统）肯定不能用它。 mongodb占用空间过大。 MongoDB没有如MySQL那样成熟的维护工具，这对于开发和IT运营都是个值得注意的地方。 MySQL和Redis对比MySQL 是持久化存储，存放在磁盘里面，检索的话，会涉及到一定的 IO，为了解决这个瓶颈，于是出现了缓存，比如现在用的最多的 memcached(简称mc)。首先，用户访问mc，如果未命中，就去访问 MySQL，之后像内存和硬盘一样，把数据复制到mc一部分。 Redis 和mc都是缓存，并且都是驻留在内存中运行的，这大大提升了高数据量web访问的访问速度。然而mc只是提供了简单的数据结构，比如 string存储；Redis却提供了大量的数据结构，比如string、list、set、hashset、sorted set这些，这使得用户方便了好多，毕竟封装了一层实用的功能，同时实现了同样的效果，当然用Redis而慢慢舍弃mc。 内存和硬盘的关系，硬盘放置主体数据用于持久化存储，而内存则是当前运行的那部分数据，CPU访问内存而不是磁盘，这大大提升了运行的速度，当然这是基于程序的局部化访问原理。 推理到 Redis + MySQL，它是内存+磁盘关系的一个映射，MySQL 放在磁盘，Redis放在内存，这样的话，web应用每次只访问Redis，如果没有找到的数据，才去访问 MySQL。 然而 Redis + MySQL 和内存+磁盘的用法最好是不同的。 前者是内存数据库，数据保存在内存中，当然速度快。 后者是关系型数据库，功能强大，数据访问也就慢。 像memcache，MongoDB，Redis，都属于No SQL系列。 FastJSON、Gson和Jackson性能对比（网摘）JSON序列化(Object =&gt; JSON)测试样本数量为100000个，为了保证每个类库在测试中都能处理同一个样本，先把样本Java对象保存在文件中。每个类库测试3次，每次循环测试10遍，去掉最快速度和最慢速度，对剩下的8遍求平均值作为最终的速，取3次测试中最好的平均速度作为最终的测试数据。 类库 样本数量 执行次数 最长时间(毫秒) 最短时间(毫秒) 平均时间(毫秒) FastJSON 100000 10 2291.22 1416.70 1454.93 Jackson 100000 10 1980.92 841.91 880.82 Gson 100000 10 2383.02 1469.08 1520.38 从测试数据可知，FastJSON和GsonJSON序列化的速度差不多，Jackson是最快的（用时Gson少大约600毫秒）。 JSON反序列化(JSON =&gt; Object)测试样本数量为100000个，为了保证每个类库在测试中都能处理同一个样本，先把样本JSON对象保存在文件中。每个类库测试3次，每次循环测试10遍，去掉最快速度和最慢速度，对剩下的8遍求平均值作为最终的速，取3次测试中最好的平均速度作为最终的测试数据。 类库 样本数量 执行次数 最长时间(毫秒) 最短时间(毫秒) 平均时间(毫秒) FastJSON 100000 10 7942.31 6340.55 6526.41 Jackson 100000 10 7957.22 6623.85 6815.41 Gson 100000 10 8235.15 7006.06 7364.75 从测试数据可知，三个类库在反序列化上性能比较接近，Gson稍微差一些。 总结把Java对象JSON序列化，Jackson速度最快，在测试中比Gson快接近50%，FastJSON和Gson速度接近。把JSON反序列化成Java对象，FastJSON、Jackson速度接近，Gson速度稍慢，不过差距很小。","categories":[{"name":"Java","slug":"Java","permalink":"https://maiyikai.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://maiyikai.github.io/tags/Java/"}]},{"title":"SpringBoot Druid(alibaba)--未完待续","slug":"1548754787","date":"2019-01-29T18:00:00.000Z","updated":"2019-10-12T12:21:09.263Z","comments":true,"path":"2019/01/30/1548754787/","link":"","permalink":"https://maiyikai.github.io/2019/01/30/1548754787/","excerpt":"Druid简介据我所知Druid目前有两个，两个项目虽然名字相同，但是作用却截然不同。它们分别为： 由美国广告技术公司MetaMarkets创建的一个分布式的支持实时分析的数据存储系统（Data Store）–Druid，开源于2012 年晚期 由阿里巴巴创建的一个数据库连接池的项目–Druid","text":"Druid简介据我所知Druid目前有两个，两个项目虽然名字相同，但是作用却截然不同。它们分别为： 由美国广告技术公司MetaMarkets创建的一个分布式的支持实时分析的数据存储系统（Data Store）–Druid，开源于2012 年晚期 由阿里巴巴创建的一个数据库连接池的项目–Druid 这里来我们只介绍由阿里巴巴开源的Druid项目 Druid–alibabaDruid是什么由阿alibaba在提供的介绍是：Druid是Java语言中最好的数据库连接池。Druid能够提供强大的监控和扩展功能。 关键词：数据库连接池、监控、扩展功能 Maven依赖Maven地址：http://central.maven.org/maven2/com/alibaba/druid/ 依赖配置： 123456&lt;!-- https://mvnrepository.com/artifact/com.alibaba/druid --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;$&#123;druid-version&#125;&lt;/version&gt;&lt;/dependency&gt; alibaba Druid源码开源地址:https://github.com/alibaba/druid Druid支持的数据库 数据库 支持状态 mysql 支持，大规模使用 oracle 支持，大规模使用 sqlserver 支持 postgres 支持 db2 支持 h2 支持 derby 支持 sqlite 支持 sybase 支持 Druid支持通过数据库URL自动识别驱动类 前缀 DriverCLass 描述信息 jdbc:odps com.aliyun.odps.jdbc.OdpsDriver jdbc:derby org.apache.derby.jdbc.EmbeddedDriver jdbc:mysql com.mysql.jdbc.Driver jdbc:oracle oracle.jdbc.driver.OracleDriver jdbc:microsoft com.microsoft.jdbc.sqlserver.SQLServerDriver jdbc:sybase:Tds com.sybase.jdbc2.jdbc.SybDriver jdbc:jtds net.sourceforge.jtds.jdbc.Driver jdbc:postgresql org.postgresql.Driver jdbc:fake com.alibaba.druid.mock.MockDriver jdbc:mock com.alibaba.druid.mock.MockDriver jdbc:hsqldb org.hsqldb.jdbcDriver jdbc:db2 COM.ibm.db2.jdbc.app.DB2Driver DB2的JDBC Driver十分混乱，这个匹配不一定对 jdbc:sqlite org.sqlite.JDBC jdbc:ingres com.ingres.jdbc.IngresDriver jdbc:h2 org.h2.Driver jdbc:mckoi com.mckoi.JDBCDriver jdbc:cloudscape COM.cloudscape.core.JDBCDriver jdbc:informix-sqli com.informix.jdbc.IfxDriver jdbc:timesten com.timesten.jdbc.TimesTenDriver jdbc:as400 com.ibm.as400.access.AS400JDBCDriver jdbc:sapdb com.sap.dbtech.jdbc.DriverSapDB jdbc:JSQLConnect com.jnetdirect.jsql.JSQLDriver jdbc:JTurbo com.newatlanta.jturbo.driver.Driver jdbc:firebirdsql org.firebirdsql.jdbc.FBDriver jdbc:interbase interbase.interclient.Driver jdbc:pointbase com.pointbase.jdbc.jdbcUniversalDriver jdbc:edbc ca.edbc.jdbc.EdbcDriver jdbc:mimer:multi1 com.mimer.jdbc.Driver SpringBoot Druid开发工具与包 idea SpringBoot 2.1.2.RELEASE MySQL Druid 1.1.10 fastjson 1.2.54 pom.xml依赖12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.2.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.myk&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;druid&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-jdbc --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.10&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.41&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/com.alibaba/fastjson --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.54&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; application.yaml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657server: port: 8001mybatis: mapper-locations: classpath:mapper/*.xmlspring: datasource: druid: # 连接池的配置 url: jdbc:mysql://$&#123;mysql_host&#125;:$&#123;mysql_port&#125;/[database]?useUnicode=true&amp;characterEncoding=UTF8 # 数据库连接 username: root password: 123456 driver-class-name: com.mysql.jdbc.Driver # 驱动类 initial-size: 10 # 初始化大小 max-active: 50 # 最大活跃数 min-idle: 5 # 最小空闲值.当空闲的连接数少于阀值时，连接池就会预申请去一些连接，以免洪峰来时来不及申请 max-wait: 20 # 最大等待 pool-prepared-statements: false #池的预编译，即PSCache max-pool-prepared-statement-per-connection-size: 10 # 每个连接上PSCache的最大值 validation-query: SELECT 1 FROM DUAL # 连接验证，mysql空闲八小时就会自动断开所有的连接，所以需要这一条语句保持 validation-query-timeout: 60000 # 连接超时时间 test-on-borrow: true # 检测池里连接的可用性 test-on-return: false # 连接归还到连接池时是否测试该连接 test-while-idle: true #当连接空闲时，是否执行连接测试. time-between-eviction-runs-millis: 30000 #指定空闲连接检查、废弃连接清理、空闲连接池大小调整之间的操作时间间隔 min-evictable-idle-time-millis: 30000 #指定一个空闲连接最少空闲多久后可被清除. filters: stat,slf4j # 配置监控统计拦截的filters，去掉后监控界面sql无法统计，&apos;wall&apos;用于防火墙 # 监控配置 # WebStatFilter配置 web-stat-filter: enabled: true # 是否启用StatFilter默认值true url-pattern: /* exclusions: &apos;*.js,*.gif,*.jpg,*.bmp,*.png,*.css,*.ico,/druid/* &apos; # 排除一些不必要的url，比如.js,/jslib/等等 session-stat-enable: true session-stat-max-count: 100 # 默认sessionStatMaxCount是1000个，你也可以按需要进行配置 profile-enable: true # druid 0.2.7版本开始支持profile，配置profileEnable能够监控单个url调用的sql列表 # StatViewServlet配置 stat-view-servlet: enabled: true #是否启用StatViewServlet默认值true url-pattern: /druid/* reset-enable: true login-username: maiyikai login-password: 123456 allow: 10.9.2.206 deny: 10.9.2.159 filter: stat: db-type: h2 log-slow-sql: true slow-sql-millis: 2000 wall: enabled: true db-type: h2 config: delete-allow: false drop-table-allow: false","categories":[{"name":"DataSource","slug":"DataSource","permalink":"https://maiyikai.github.io/categories/DataSource/"}],"tags":[{"name":"DataSource","slug":"DataSource","permalink":"https://maiyikai.github.io/tags/DataSource/"},{"name":"Druid","slug":"Druid","permalink":"https://maiyikai.github.io/tags/Druid/"}]},{"title":"Spring Boot DataSource配置","slug":"1548731189","date":"2019-01-29T11:00:00.000Z","updated":"2019-10-12T12:21:09.262Z","comments":true,"path":"2019/01/29/1548731189/","link":"","permalink":"https://maiyikai.github.io/2019/01/29/1548731189/","excerpt":"数据库基础知识理解 SQL组成： DML、DDL、DCL、TCL SQL组成名词解释： DML:数据操纵语言（Data Manipulation Language, DML）是SQL语言中，负责对数据库对象运行数据访问工作的指令集，操作语句：","text":"数据库基础知识理解 SQL组成： DML、DDL、DCL、TCL SQL组成名词解释： DML:数据操纵语言（Data Manipulation Language, DML）是SQL语言中，负责对数据库对象运行数据访问工作的指令集，操作语句： INSERT ：将数据插入到表或视图 DELETE ：从表或视图删除数据 SELECT ：从表或视图中获取数据 UPDATE ：更新表或视图中的数据 MERGE ： 对数据进行合并操作(插入/更新/删除) DDL:数据库模式定义语言DDL(Data Definition Language)，是用于描述数据库中要存储的现实世界实体的语言。操作语句： CREATE : 在数据库中创建新的数据对象 ALTER : 修改数据库中对象的数据结构 DROP : 删除数据库中的对象（可以删除数据表、索引、触发程序、条件约束以及数据表的权限等） DISABLE/ENABLE TRIGGER : 修改触发器的状态 UPDATE STATISTIC : 更新表/视图统计信息 TRUNCATE TABLE : 清空表中数据 COMMENT : 给数据对象添加注释 RENAME : 更改数据对象名称 DCL:DCL数据库控制语言不同于程序设计语言。是用来设置或更改数据库用户或角色权限的语句，操作语句： GRANT: 赋予用户某种控制权限 DENY REVOKE：取消用户某种控制权限 … … TCL:事务控制语言，管理事务,操作语句 COMMIT : 保存已完成事务动作结果 SAVEPOINT : 保存事务相关数据和状态用以可能的回滚操作 ROLLBACK : 恢复事务相关数据至上一次COMMIT操作之后 SET TRANSACTION : 设置事务选项 DataSource文件配置根据需求自定义配置，真实情况用不了这么多的配置 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192spring: dao: exceptiontranslation: enabled: # 是否开启PersistenceExceptionTranslationPostProcessor，默认为true datasource: abandon-when-percentage-full: # 设定超时被废弃的连接占到多少比例时要被关闭或上报 allow-pool-suspension: #使用Hikari pool时，是否允许连接池暂停，默认为: false alternate-username-allowed: #是否允许替代的用户名. auto-commit: #指定updates是否自动提交 catalog: #指定默认的catalog commit-on-return: #设置当连接被归还时，是否要提交所有还未完成的事务 connection-init-sql: #指定连接被创建，再被添加到连接池之前执行的sql. connection-init-sqls: #使用DBCP connection pool时，指定初始化时要执行的sql connection-properties: [key]: #在使用DBCP connection pool时指定要配置的属性 connection-test-query: #指定校验连接合法性执行的sql语句 connection-timeout: #指定连接的超时时间，毫秒单位. continue-on-error: #在初始化数据库时，遇到错误是否继续，默认false data: #指定Data (DML)脚本 data-source-class-name: #指定数据源的全限定名. data-source-jndi: #指定jndi的地址 data-source-properties: [key]: #使用Hikari connection pool时，指定要设置的属性 db-properties: #使用Tomcat connection pool，指定要设置的属性 default-auto-commit: #是否自动提交. default-catalog: #指定连接默认的catalog. default-read-only: #是否设置默认连接只读. default-transaction-isolation: #指定连接的事务的默认隔离级别. driver-class-name: #指定driver的类名，默认从jdbc url中自动探测. fair-queue: #是否采用FIFO返回连接. health-check-properties: [key]: #使用Hikari connection pool时，在心跳检查时传递的属性 idle-timeout: #指定连接多久没被使用时，被设置为空闲，默认为10ms ignore-exception-on-pre-load: #当初始化连接池时，是否忽略异常. init-sql: #当连接创建时，执行的sql initial-size: #指定启动连接池时，初始建立的连接数量 initialization-fail-fast: #当创建连接池时，没法创建指定最小连接数量是否抛异常 initialize: #指定初始化数据源，是否用data.sql来初始化，默认: true isolate-internal-queries: #指定内部查询是否要被隔离，默认为false jdbc-interceptors: #使用Tomcat connection pool时，指定jdbc拦截器，分号分隔 jdbc-url: #指定JDBC URL. jmx-enabled: #是否开启JMX，默认为: false jndi-name: #指定jndi的名称. leak-detection-threshold: #使用Hikari connection pool时，多少毫秒检测一次连接泄露. log-abandoned: #使用DBCP connection pool，是否追踪废弃statement或连接，默认为: false log-validation-errors: #当使用Tomcat connection pool是否打印校验错误. login-timeout: #指定连接数据库的超时时间. max-active: #指定连接池中最大的活跃连接数. max-age: #指定连接池中连接的最大年龄 max-idle: #指定连接池最大的空闲连接数量. max-lifetime: #指定连接池中连接的最大生存时间，毫秒单位. max-open-prepared-statements: #指定最大的打开的prepared statements数量. max-wait: #指定连接池等待连接返回的最大等待时间，毫秒单位. maximum-pool-size: #指定连接池最大的连接数，包括使用中的和空闲的连接. min-evictable-idle-time-millis: #指定一个空闲连接最少空闲多久后可被清除. min-idle: #指定必须保持连接的最小值(For DBCP and Tomcat connection pools) minimum-idle: #指定连接维护的最小空闲连接数，当使用HikariCP时指定. name: #指定数据源名. num-tests-per-eviction-run: #指定运行每个idle object evictor线程时的对象数量 password: #指定数据库密码. platform: #指定schema要使用的Platform(schema-$&#123;platform&#125;.sql)，默认为: all pool-name: #指定连接池名字. pool-prepared-statements: #指定是否池化statements. propagate-interrupt-state: #在等待连接时，如果线程被中断，是否传播中断状态. read-only: #当使用Hikari connection pool时，是否标记数据源只读 register-mbeans: #指定Hikari connection pool是否注册JMX MBeans. remove-abandoned: #指定当连接超过废弃超时时间时，是否立刻删除该连接. remove-abandoned-timeout: #指定连接应该被废弃的时间. rollback-on-return: #在归还连接时，是否回滚等待中的事务. schema: #指定Schema (DDL)脚本. separator: #指定初始化脚本的语句分隔符，默认: ; sql-script-encoding: #指定SQL scripts编码. suspect-timeout: #指定打印废弃连接前的超时时间. test-on-borrow: #当从连接池借用连接时，是否测试该连接. test-on-connect: #创建时，是否测试连接 test-on-return: #在连接归还到连接池时是否测试该连接. test-while-idle: #当连接空闲时，是否执行连接测试. time-between-eviction-runs-millis: #指定空闲连接检查、废弃连接清理、空闲连接池大小调整之间的操作时间间隔 transaction-isolation: #指定事务隔离级别，使用Hikari connection pool时指定 url: #指定JDBC URL. use-disposable-connection-facade: #是否对连接进行包装，防止连接关闭之后被使用. use-equals: #比较方法名时是否使用String.equals()替换==. use-lock: #是否对连接操作加锁 username: #指定数据库名. validation-interval: #指定多少ms执行一次连接校验. validation-query: #指定获取连接时连接校验的sql查询语句. validation-query-timeout: #指定连接校验查询的超时时间. validation-timeout: #设定连接校验的超时时间，当使用Hikari connection pool时指定 validator-class-name: #用来测试查询的validator全限定名. xa: data-source-class-name: #指定数据源的全限定名. properties: #指定传递给XA data source的属性 JPA文件配置JPA是Java Persistence API的简称，中文名Java持久层API，是JDK 5.0注解或XML描述对象－关系表的映射关系，并将运行期的实体对象持久化到数据库中。Sun引入新的JPA ORM规范出于两个原因：其一，简化现有Java EE和Java SE应用开发工作；其二，Sun希望整合ORM技术，实现天下归一。 123456789101112spring: jpa: database: #指定目标数据库. database-platform: #指定目标数据库的类型. generate-ddl: #是否在启动时初始化schema，默认为false hibernate: ddl-auto: #指定DDL mode (none, validate, update, create, create-drop). 当使用内嵌数据库时，默认是create-drop，否则为none. hibernate: naming-strategy: #指定命名策略. open-in-view: #是否注册OpenEntityManagerInViewInterceptor，绑定JPA EntityManager到请求线程中，默认为: true properties: #添加额外的属性到JPA provider. show-sql: #是否开启sql的log，默认为: false JTA文件配置JTA，即Java Transaction API，JTA允许应用程序执行分布式事务处理——在两个或多个网络计算机资源上访问并且更新数据。JDBC驱动程序的JTA支持极大地增强了数据访问能力。 12345678910111213141516171819202122232425262728spring: jta: allow-multiple-lrc: #是否允许 multiple LRC，默认为: false asynchronous2-pc: #指定两阶段提交是否可以异步，默认为: false background-recovery-interval: #指定多少分钟跑一次recovery process，默认为: 1 background-recovery-interval-seconds: #指定多久跑一次recovery process，默认: 60 current-node-only-recovery: #是否过滤掉其他非本JVM的recovery，默认为: true debug-zero-resource-transaction: #是否追踪没有使用指定资源的事务，默认为: false default-transaction-timeout: #设定默认的事务超时时间，默认为60 disable-jmx: #是否禁用jmx，默认为false enabled: #是否开启JTA support，默认为: true exception-analyzer: #设置指定的异常分析类 filter-log-status: #使用Bitronix Transaction Manager时，是否写mandatory logs，开启的话，可以节省磁盘空间，但是调试会复杂写，默认为false force-batching-enabled: #使用Bitronix Transaction Manager时，是否批量写磁盘，默认为true. forced-write-enabled: #使用Bitronix Transaction Manager时，是否强制写日志到磁盘，默认为true graceful-shutdown-interval: #当使用Bitronix Transaction Manager，指定shutdown时等待事务结束的时间，超过则中断，默认为60 jndi-transaction-synchronization-registry-name: #当使用Bitronix Transaction Manager时，在JNDI下得事务同步registry，默认为: java:comp/TransactionSynchronizationRegistry jndi-user-transaction-name: #指定在JNDI使用Bitronix Transaction Manager的名称，默认:java:comp/UserTransaction journal: #当使用Bitronix Transaction Manager，指定The journal是否disk还是null还是一个类的全限定名，默认disk log-dir: #ransaction logs directory. log-part1-filename: #指定The journal fragment文件1的名字，默认: btm1.tlog log-part2-filename: #指定The journal fragment文件2的名字，默认: btm2.tlog max-log-size-in-mb: #指定journal fragments大小的最大值. 默认: 2M resource-configuration-filename: #指定Bitronix Transaction Manager配置文件名. server-id: #指定Bitronix Transaction Manager实例的id. skip-corrupted-logs: #是否忽略corrupted log files文件，默认为false. transaction-manager-id: #指定Transaction manager的唯一标识. warn-about-zero-resource-transaction: #当使用Bitronix Transaction Manager时，是否对没有使用指定资源的事务进行警告，默认为: true 参考文章: 来自思否：@codecraft&gt;SpringBoot配置属性之DataSource","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://maiyikai.github.io/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://maiyikai.github.io/tags/SpringBoot/"},{"name":"DataSource","slug":"DataSource","permalink":"https://maiyikai.github.io/tags/DataSource/"}]},{"title":"Hexo添加搜索功能与百度分析","slug":"1548657877","date":"2019-01-28T14:45:00.000Z","updated":"2019-10-12T12:21:09.262Z","comments":true,"path":"2019/01/28/1548657877/","link":"","permalink":"https://maiyikai.github.io/2019/01/28/1548657877/","excerpt":"前两篇文章讲了搭建Hexo个人博客和主题的更换: 简单搭建Hexo Hexo添加hexo-theme-miho主题","text":"前两篇文章讲了搭建Hexo个人博客和主题的更换: 简单搭建Hexo Hexo添加hexo-theme-miho主题 但是主题里边有个搜索功能，一开始使用的时候，浏览器控制台总是报错，说content.json 404 懵了，主题切换的时候没注意，然后一直想怎么弄出来这个文件 现在，开始添加搜索功能，然后在加入百度分析 搜索功能自动生成一个很简单的方法，那就是让它在构建的时候自己生成”content.json”文件 打开 Git Bash Here 程序 输入命令 npm i -S hexo-generator-json-content 安装组件 在相对应的主题目录下的 “_config.yml” 文件下加入配置代码： 123456789101112131415161718192021222324252627282930313233343536# 自动生成content.json# https://github.com/alexbruno/hexo-generator-json-contentjsonContent: meta: true keywords: false # language name option dateFormat: undefined # format string pages: title: true slug: true date: true updated: true comments: true path: true link: true permalink: true excerpt: true keywords: true # but only if root keywords option language was set text: true raw: false content: false posts: title: true slug: true date: true updated: true comments: true path: true link: true permalink: true excerpt: true keywords: true # but only if root keywords option language was set text: true raw: false content: false categories: true tags: true 依次输入命令： 输入命令hexo clean清除缓存 输入命令hexo g构建 输入命令hexo d部署 在hexo目录下会生成public文件夹，在这个文件夹下就可以看到 “content.json” 这个文件了(可以打开，建议格式化之后在区查看) 部署好之后，可以在自己的hexo主页使用搜索功能了 手动添加手动添加呢，有点费时间，不过可以自定义条件 首先来看一下有哪些配置项 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&#123; &quot;meta&quot;:&#123; &quot;title&quot;:&quot;&quot;, ## 博客标题 &quot;subtitle&quot;:&quot;&quot;, ## 博客子标题 &quot;description&quot;:&quot;&quot;, ## 博客描述 &quot;author&quot;:&quot;&quot;, ## 博客作者 &quot;url&quot;:&quot;&quot; ## 博客首页地址 &#125;, &quot;pages&quot;:[ ## 非博客博文的一些页面， 即不在hexo\\source\\_posts目录下的，但在hexo\\source下的md页面 &#123; &quot;title&quot;:&quot;&quot;, &quot;date&quot;:&quot;&quot;, ## 博客发布时间 &quot;updated&quot;:&quot;&quot;, ## 博客更新时间 &quot;comments&quot;:true, &quot;path&quot;:&quot;&quot;, ## 在当前首页地址下的路径 &quot;permalink&quot;:&quot;&quot;, ## 页面全路径 &quot;excerpt&quot;:&quot;&quot;, &quot;text&quot;:&quot;&quot; ## 页面内容 &#125; ], posts: [ ## 在hexo\\source\\_posts目录下的md文件生成的页面，即博文 &#123; &quot;title&quot;:&quot;&quot;, ## 博文标题 &quot;slug&quot;:&quot;&quot;, ## 博文md文件的文件名 &quot;date&quot;:&quot;&quot;, ## 时间 &quot;updated&quot;:&quot;&quot;, ## 更新时时间 &quot;comments&quot;:true, &quot;path&quot;:&quot;&quot;, ## 在当前首页地址下的路径 &quot;link&quot;:&quot;&quot;, &quot;permalink&quot;:&quot;&quot;, ## 页面全路径 &quot;excerpt&quot;:&quot;&quot;, ## 博文描述文字 &quot;text&quot;:&quot;&quot;, ## 博文内容 &quot;categories&quot;:[ ## 分类 &#123; &quot;name&quot;:&quot;Hexo&quot;, &quot;slug&quot;:&quot;Hexo&quot;, &quot;permalink&quot;:&quot;https://maiyikai.github.io/categories/Hexo/&quot; ## 分类文件路径 &#125; ], &quot;tags&quot;:[ ## 标签 &#123; &quot;name&quot;:&quot;Hexo&quot;, &quot;slug&quot;:&quot;Hexo&quot;, &quot;permalink&quot;:&quot;https://maiyikai.github.io/tags/Hexo/&quot; ## 便签文件的路径 &#125; ] &#125; ] &#125; 其实用不了这么多，简易版的： 1234567891011121314151617181920&#123; &quot;meta&quot;:&#123; &quot;title&quot;:&quot;&quot;, &quot;subtitle&quot;:null, &quot;description&quot;:&quot;&quot;, &quot;author&quot;:&quot;&quot;, &quot;url&quot;:&quot;&quot; &#125;, &quot;pages&quot;:[ ], &quot;posts&quot;:[ &#123; &quot;title&quot;:&quot;&quot;, &quot;comments&quot;:true, &quot;path&quot;:&quot;&quot;, &quot;text&quot;:&quot;Windows Hexo 博客 github Git GitHub&quot; ## 匹配一般只匹配title 和text的内容 &#125; ]&#125; 写好这个文件之后，把它放在hexo\\source文件夹下即可 依次输入命令： 输入命令hexo clean清除缓存 输入命令hexo g构建 输入命令hexo d部署 部署好之后，可以在自己的hexo主页使用搜索功能了 注：手动添加的方式一定要注意，添加或更新博文时，要同步更新 “content.json” 文件，否则会出问题 加入百度分析 百度分析注册/登陆地址：https://tongji.baidu.com/web/welcome/login 登陆之后，点击“代码管理&gt;&gt;代码获取”，看下图: 将这个key复制出来 修改主题目录下的 “_config.yml” 文件中的 baidu_analytics,如下图 依次输入命令： 输入命令hexo clean清除缓存 输入命令hexo g构建 输入命令hexo d部署 部署上去之后就可以了 参考文章: 来自简书：@minhow&gt;https://www.jianshu.com/p/eb9009f03178 来自Github:@alexbruno&gt;https://github.com/alexbruno/hexo-generator-json-content","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://maiyikai.github.io/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://maiyikai.github.io/tags/Hexo/"},{"name":"百度分析","slug":"百度分析","permalink":"https://maiyikai.github.io/tags/百度分析/"}]},{"title":"Hexo添加hexo-theme-miho主题","slug":"1548499757","date":"2019-01-27T10:00:00.000Z","updated":"2019-10-12T12:21:09.262Z","comments":true,"path":"2019/01/27/1548499757/","link":"","permalink":"https://maiyikai.github.io/2019/01/27/1548499757/","excerpt":"上一篇文章：简单构建Hexo，教您如何搭建一个简单的Hexo Blog https://maiyikai.github.io/2019/01/26/1548499728/","text":"上一篇文章：简单构建Hexo，教您如何搭建一个简单的Hexo Blog https://maiyikai.github.io/2019/01/26/1548499728/ 主题添加主题本文使用 hexo-theme-miho 主题 这里的主题不是我们自己写的，而是从Hexo官网主题clone过来的（开源） 复制该主题的 git 地址 打开程序 Git Bash Here ，进入博客目录下的themes目录下，clone git项目 cd themes 进入主题目录 git clone [gitAddr] [themes name] 克隆 git 项目到本地。[themes name]如果不填写，则会创建一个名为项目名的目录 输入命令ls查看是否 clone 成功绑定主题 Hexo主目录下的”_config.yml”文件部分解释 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Sitetitle: FlyingFish Blog ##页面名称，标签栏显示subtitle:description:keywords:author: maiyikai ##作者language:timezone:# URL## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;url: https://maiyikai.github.io/ ##默认的地址，后边会有一些地方用到，请改为自己的博客地址root: /permalink: :year/:month/:day/:title/permalink_defaults:# Directorysource_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render:# Writingnew_post_name: :title.md # File name of new postsdefault_layout: posttitlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tabfilename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsefuture: truehighlight: enable: true line_number: true auto_detect: false tab_replace: # Home page setting# path: Root path for your blogs index page. (default = &apos;&apos;)# per_page: Posts displayed per page. (0 = disable pagination)# order_by: Posts order. (Order by date descending by default)index_generator: path: &apos;&apos; per_page: 10 order_by: -date # Category &amp; Tagdefault_category: uncategorizedcategory_map:tag_map:# Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss# Pagination## Set per_page to 0 to disable paginationper_page: 10pagination_dir: page# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: miho ##绑定主题，，在themes目录下的git主题的目录名称# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: https://github.com/maiyikai/maiyikai.github.io.git branch: master 主题的个性化配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144# hexo-theme-miho# https://github.com/wongminho/hexo-theme-miho# Favicon of your site | 网站iconfavicon: /pen_logo.ico# Header# Keywords of your site | 网站关键字keywords: maiyikai,maiyude,FlyingFish blog# Head headline | 头部标题header_title: FlyingFish&apos;s Blog# Head description | 头部描述header_description: 随笔记# Link to your logo | logo地址logo: images/logo2.png# Link to your banner_img | 首页banner图地址banner_img: images/banner.jpg# Menu setting | 菜单设置# name: Font Awesome icon | Font Awesome 图标# title: Home Title | 标题# url: //minhow.com Url, absolute or relative path | 链接，绝对或相对路径# target: true Whether to jump out | 是否跳出menu: home: title: Home url: / target: false archive: title: Archives url: /archives target: false user: title: About url: /about target: false# Social setting, use to display social information | 社交设置，用来展示社交信息# name: Font Awesome icon | Font Awesome 图标# title: Home Icon title | 图标标题# url: //minhow.com Url, absolute or relative path | 链接，绝对或相对路径# target: true Whether to jump out | 是否跳出social: home: title: maiyikai url: //maiyikai.github.io/ target: true github: title: Github url: //github.com/maiyikai/maiyikai.github.io target: true weibo: title: Weibo url: //weibo.com/maiyikai target: true# twitter:# title: Twitter# url: //twitter.com/huangminhow# target: true #qq: weixin: title: Weixin url: //maiyikai.github.io/images/user_weixin.jpg target: true #snapchat: #telegram: #envelope-o: #facebook: #google: #linkedin:# Content# Excerpt length | 摘录长度excerpt_length: 190# Excerpt link | 摘录链接excerpt_link: more&gt;&gt;# New window open link | 新窗口打开文章open_new_link: false# Article default cover picture，size：350*150 | 文章默认封面图，尺寸：350*150cover_picture: //maiyikai.github.io/images/banner.jpg# Open background particles | 开启背景粒子open_bg_particle: true# Open animation in homepage and head | 开启主页及头部动画open_animation: true# Article# Open toc | 是否开启toctoc: true# Open share | 是否开启分享share: true# Style customization | 样式定制style: # Main color tone | 主色调 main_color: &apos;#0cc&apos;# Reward | 打赏reward: # 0-close, 1-All articles are rewarding, 2-Article&apos;s md file has reward:true attribute, only reward # 0-关闭, 1-所有文章均有打赏, 2-文章的md文件里有reward:true属性，才有打赏 status: 1 # 标题 title: ~谢谢大爷~ # 微信，关闭设为 false wechat: images/wechat_code.jpg # 支付宝，关闭设为 false alipay: images/alipay_code.jpg# Comments | 评论 建议不使用 gitment,,网站证书过期了，使用很麻烦# 畅言，输入appid和appkeychangyan_appid: falsechangyan_appkey: false# 友言，输入idyouyan_id: false# disqusdisqus: false# gitment https://github.com/imsun/gitmentgitment: owner: false #你的 GitHub ID repo: &apos;&apos; #存储评论的 repo client_id: &apos;&apos; #client ID client_secret: &apos;&apos; #client secret# Analytics | 分析# 站长分析，输入站点idcnzz_analytics: false# 百度分析，输入key值baidu_analytics: false# google analytics | google分析google_analytics: false# Footer# Access statistics | “不蒜子”访问量统计access_counter: on: true site_uv: 总访客数： site_pv: 总访问量：# Copyright Information | 版权信息 ---不可更改，尊重他人的智力成果权copyright: 2018 MinHow 加入评论因为加入gitment有很多的问题，让我浪费了很多的时间，所以我改为了 “畅言” 进入畅言官网,注册一个账号 拉倒下边，点击 “立即免费获取畅言” 建站，随便点一个 配置畅言的基本设置 网上随便找一个小网站 进入备案号查询 复制需要的信息即可 提交审核 静静等待 上线畅言评论功能(部署之后才能使用) 获取appid和appkey 在畅言后台管理页面-》后台总览，往下拉就可以看到了 在主题themes目录下，编辑”_config.yml”文件，找到评论配置区域，粘贴信息即可 至此，在主题 hexo-theme-miho下，畅言就配置成功了 加入搜索页面中有个搜索功能，需要一个文件的支持 进入hexo主目录下的source文件夹 在当前文件夹下创建一个文件，文件名固定content.json 写入文件内容，即搜索用的关键字(使用的时候把注解去掉)1234567891011121314151617181920&#123; &quot;meta&quot;:&#123; &quot;title&quot;:&quot;FlyingFish Blog&quot;, ##博客名 &quot;subtitle&quot;:null, &quot;description&quot;:&quot;FlyingFish Blog,&quot;, &quot;author&quot;:&quot;maiyikai&quot;, &quot;url&quot;:&quot;https://maiyikai.github.io/&quot; ##博客地址 &#125;, &quot;pages&quot;:[ ], &quot;posts&quot;:[ &#123; &quot;title&quot;:&quot;简单构建Hexo&quot;, ##文章标题 &quot;comments&quot;:true, &quot;path&quot;:&quot;2019/01/26/1548499728/&quot;, ##文章路径，在博客地址下的路径 &quot;text&quot;:&quot;Windows Hexo 博客 github Git GitHub&quot; #关键字，也可以是文章的全部文本 &#125; ]&#125; 部署上线 依次输入命令： 输入命令hexo clean清除缓存 输入命令hexo g构建 输入命令hexo d部署 部署结束之后，可以使用您的地址访问了 效果应该是和本博客当前日期的版本是一致的","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://maiyikai.github.io/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://maiyikai.github.io/tags/Hexo/"},{"name":"Github","slug":"Github","permalink":"https://maiyikai.github.io/tags/Github/"},{"name":"Hexo Themes","slug":"Hexo-Themes","permalink":"https://maiyikai.github.io/tags/Hexo-Themes/"},{"name":"畅言","slug":"畅言","permalink":"https://maiyikai.github.io/tags/畅言/"}]},{"title":"简单搭建Hexo","slug":"1548499728","date":"2019-01-26T18:00:00.000Z","updated":"2019-10-12T12:21:09.261Z","comments":true,"path":"2019/01/27/1548499728/","link":"","permalink":"https://maiyikai.github.io/2019/01/27/1548499728/","excerpt":"作为一个名不希望受约束的程序员的我来说，拥有一个属于自己的博客平台是必要的","text":"作为一个名不希望受约束的程序员的我来说，拥有一个属于自己的博客平台是必要的不瞎说了,开始吧 环境准备此处使用Windows系统环境 Git仓库准备 在已是Git用户的前提下进行，如果您还不是Git用户，请点击此处进行注册 创建一个仓库，且对仓库命名有限制(eg:如果您想要您的仓库命名为”exmple”,但实际命名应在其后边加入”.github.io”。项目必须要遵守格式：账户名.github.io) 此处使用本博客仓库地址举例 本地环境准备 安装nodejs环境 从nodejs官方网站下载nodejs，并且安装 检查是否安装成功 win+R进入cmd命令行 输入命令 node -v 检查是否输入版本号 输入命令 npm -v 检查npm命令是否安装输出的结果应该和下图相似，说明成功安装： 安装Git 如果您还没有Git，可以点击此处进行下载安装并配置 检查是否安装成功 桌面右键查看菜单是否有这两个选项： Git GUI Here Git Bash Here 打开cmd命令行，输入命令git -version查看是否有有相应的版本号，如下图： 安装hexo客户端 打开Git Hash Here程序 输入命令 npm install hexo-cli -g安装Hexo插件(和网络有关，请耐心等待) 输入命令 hexo -v查看是否有相应的版本号输出即可（安装成功才有，和上边相似） 进入博客目录，输入命令hexo init初始化hexo环境，等待结束之后在目录下会存在几个目录 node_modules：是依赖包 public：存放的是生成的页面 scaffolds：命令生成文章等的模板 source：用命令创建的各种文章 themes：主题 _config.yml：整个博客的配置 db.json：source解析所得到的 package.json：项目所需模块项目的配置信息 Git授权管理 绑定当前用户：打开Git Bash Here程序，分别输入命令： git config -global user.name &quot;git用户名&quot; git config -global user.email &quot;git邮箱&quot; 生产授权密钥 输入命令cd ~/.ssh切换目录，密钥文件一定要保存在这个文件夹下（有可能被隐藏） 输入命令ssh-keygen -t rsa -C &quot;git邮箱&quot; 查看.ssh文件夹下是否存在以下两个文件： id_rsa私钥 id_rsa.pub公钥 在Github中添加公钥 登录Github，点击头像下的settings，添加ssh 新建一个new ssh key，将id_rsa.pub文件里的内容复制上去 测试ssh是否添加成功 输入命令ssh -T git@github.com测试添加ssh是否成功。如果看到”Hi“后面是你的用户名，就说明成功了 hexo本地测试及部署Github本地测试 使用程序Git Bash Here进入博客目录 输入命令hexo clean清除缓存 输入命令 hexo server使用默认端口开启服务也可以自己指定端口，输入hexo server -p &quot;port&quot;就可以使用自己的端口开启服务部署Github 进入博客目录，打开文件”_config.yml”，在文件最后添加 1234deploy: type: git #部署类型 repo: gitAddr #git的仓库地址 branch: master #分支 依次输入命令： 输入命令hexo clean清除缓存 输入命令hexo g构建 输入命令hexo d部署 部署结束之后，可以使用您的地址访问了，如：https://maiyikai.github.io 页面如下图相似，就是完成了 至此，简单的部署就完成了如有疑问，可以点击博客上方的微信图标，扫码添加小弟为好友私聊哦也可以在评论区评论","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://maiyikai.github.io/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://maiyikai.github.io/tags/Hexo/"},{"name":"Github","slug":"Github","permalink":"https://maiyikai.github.io/tags/Github/"}]}]}